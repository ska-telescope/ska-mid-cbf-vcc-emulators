# This file was autogenerated from a DeTrI JSON file using the py_drivers_writer.py script.
# This file is meant to accompany the py_driver_initializer.py, and provide it with preprocessed
# driver information so as to avoid its having to load and resolve the DeTrI JSON at runtime.
# Usage: "from py_drivers import drivers, pybind_module_name"
pybind_module_name = 'talon_dx_tdc_base_tdc_vcc_pst_processing'
drivers = {'circuit_switch': {'driver': 'circuit_switch_driver', 'register_sets': {'csr': {'bridge_address': 4177526784, 'firmware_depth': 128, 'firmware_offset': 132736, 'fpga_hierarchy': 'TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|E_CIRCUIT_SWITCH|E_CSR', 'regdef': {'mnemonic': 'circuit_switch', 'version': '2.0.0', 'regset': {'name': 'circuit switch register set', 'mnemonic': 'circuit_switch', 'desc': ['The parameterized circuit switch IP block allows customized circuit switches', '1. Register configurable connections between input ports and output ports', '2. Allows duplication of input data to multiple output ports'], 'version': '2.0.0', 'author': 'William Kamp', 'email': 'will@kamputed.com', 'date': '2023-06-20', 'registers': {'number_of_ports': {'name': 'Number of Ports', 'desc': 'Actual numbers of ports as configured in the firmware.', 'addressOffset': '0x0', 'fields': {'number_of_inputs': {'name': 'Number of Input Ports', 'desc': 'Number of input ports configured in the firmware for this instance.', 'ftype': 'natural', 'access': 'ro', 'bitOffset': 0, 'bitWidth': 8}, 'number_of_outputs': {'name': 'Number of Output Ports', 'desc': 'Number of output ports configured in the firmware for this instance.', 'ftype': 'natural', 'access': 'ro', 'bitOffset': 8, 'bitWidth': 8}}}, 'input_sel': {'name': 'Input Select', 'desc': "Select the input source for this output port. Output port according to the register's index (address).", 'addressOffset': '0x04', 'repeat': 31, 'fields': {'input_select': {'name': 'input select', 'desc': ['Select input from [0 : number_of_inputs - 1] as the source for this output port.', 'To disconnect this port write the value of number_of_inputs.', 'If this output port does not exist, i.e. index >= number_of_outputs, will always read 0xFF.'], 'ftype': 'natural', 'access': 'rw', 'bitOffset': 0, 'bitWidth': 8, 'reset': '0xFF'}}}}}}}}}, 'vcc_ch20': {'driver': 'vcc_ch20_driver', 'register_sets': {'csr': {'bridge_address': 4177526784, 'firmware_depth': 128, 'firmware_offset': 132864, 'fpga_hierarchy': 'TOP|E_BASE|E_PERSONA|E_VCC|E_VCC_CH20|E_AVMM_BRIDGE', 'parameters': {'channels_out': 10, 'polarisations': 2, 'input_frame_size': 18}, 'regdef': {'mnemonic': 'vcc_ch20', 'version': '1.0.0', 'regset': {'name': 'Very Coarse Channelizer - 20 Channel Version', 'desc': ["The firmware block for the 'The Very Coarse Channelizer - 20 Channel Version'.", 'The configuration registers set the number of frames between PPS markers and', 'scaling the Frequency-Slices (FSs) before the final quantization.'], 'mnemonic': 'vcc_ch20', 'version': '1.0.0', 'author': 'T. Gunaratne', 'email': 'Thushara.Gunaratne@nrc-cnrc.gc.ca', 'date': '2021-01-14', 'referenceDocumentTitle': 'None', 'referenceDocument': 'None', 'registers': {'config_pps_frame_count': {'name': 'Config PPS Frame Count', 'desc': ['This register specifies the expected number of data-frames between PPS markers.', 'For vcc_ch20, a data-frames of 18 consecutive samples.', 'The pulse-per-second (PPS) marks the start sample of each 1 second.', 'There is an expected number of data-frames between PPS, which is different for each DISH.', 'If the count of data-frames does not match this register then the output samples are RFI flagged.'], 'addressOffset': '0x0', 'fields': {'frame_count': {'name': 'Frame Count', 'desc': 'The number of data-frames between PPS markers.', 'ftype': 'natural', 'bitOffset': 0, 'bitWidth': 32, 'reset': 220000000, 'access': 'rw'}}}, 'config_fs_sft_scl': {'name': 'Config Frequency Slice Scaling', 'desc': ['The VCC channeliser implementation has an internal gain of approximately 0.944*sqrt(20) = 4.222.', 'To correct for this we apply a scaling factor at the output. The scaling factor is split into two components:', '1. SFT, a shift-right factor that divides by a power of two, for a gain adjustment of 1/2**SFT, and', '2. SCL, a scale factor that multiplies the result with a value between 1 and 0.', 'For unity gain, we must correct the output by 1/4.222 = 0.2369 which can be decomposed into two terms, 1/4 * 4/4.222,', 'Therefore, from the first term, 1/4 = 1/(2**SFT) => SFT = 2, and', 'subsequently from the second term, 4/4.222 = 2**SFT/4.222 = 0.9475, and converting to a 16 bit unsigned value, SCL = 0.9475*65536 = 62094.', 'These are the default values for the registers.', '', 'There are 20 repeats of this register.', 'Entries  0-9  correspond to polarization 0,', 'Entries 10-19 correspond to polarization 1.'], 'addressOffset': '0x4', 'repeat': 20, 'fields': {'fs_sft': {'name': 'Frequency Slice Shift Right', 'desc': 'The scaling factor 1/(2**FS_SFT).', 'ftype': 'natural', 'bitOffset': 0, 'bitWidth': 4, 'reset': 2, 'access': 'rw'}, 'fs_scl': {'name': 'Frequency Slice Scale', 'desc': 'The fractional scaling factor FS_SCL/65536.', 'ftype': 'natural', 'bitOffset': 4, 'bitWidth': 16, 'reset': 62094, 'access': 'rw'}}}}}}}}}, 'sys_id_base': {'driver': 'sys_id_driver', 'register_sets': {'csr': {'bridge_address': 4177526784, 'firmware_depth': 16, 'firmware_offset': 1048592, 'fpga_hierarchy': 'TOP|E_BASE|E_SYS_ID|E_CSR', 'regdef': {'mnemonic': 'sys_id', 'version': '1.0.0', 'regset': {'name': 'System Identifier', 'mnemonic': 'sys_id', 'desc': ['FPGA bitstream system identification information.', 'The information in this register set is populated by a Memory Initialisation File (mif). This file is generated by the script `generate_sys_id_register_file`.', 'This allows the information to be updated after the bitstream is successfully placed and routed using the Quartus ECO process `tcl:update_mif_files` .'], 'version': '1.0.0', 'registers': {'bitstream': {'name': 'Bitstream', 'desc': [], 'fields': {'bitstream': {'name': 'Bitstream Identifier', 'desc': ['Identification number that uniquely identifies this bitstream.', 'Calculated as the least significant 32 bits of the md5 checksum of the bitsream name.', "For example: 'ska-mid-cbf-tdc-correlator' => `$ echo -n ska-mid-cbf-tdc-correlator | md5sum | cut -c 25-32` returns: `f3923f36`.", "If the bitstream is a base bitstream with partially reconfigurable regions then the revision string doesn't include the PR region. e.g. 'talon_dx-tdc-base'."], 'bitOffset': 0, 'bitWidth': 32, 'ftype': 'natural', 'access': 'ro'}}}, 'version': {'name': 'Bitstream Version', 'desc': ['The semantic version of the bitstream. See https://semver.org/', 'Given a version number MAJOR.MINOR.PATCH, increment the:', ' * MAJOR version when you make incompatible API changes,', ' * MINOR version when you add functionality in a backwards compatible manner, and', ' * PATCH version when you make backwards compatible bug fixes.', 'Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.'], 'width': 32, 'fields': {'major': {'name': 'Major Version', 'desc': 'The major version. Incremented when incompatible API changes are made.', 'ftype': 'natural', 'bitOffset': 24, 'bitWidth': 8, 'access': 'ro', 'reset': 0, 'repeat': 1}, 'minor': {'name': 'Minor Version', 'desc': 'The minor version. Incremented when functionality is added in a backwards compatible manner.', 'ftype': 'natural', 'bitOffset': 16, 'bitWidth': 8, 'access': 'ro', 'reset': 0}, 'patch': {'name': 'Patch Version', 'desc': 'The patch version. Incremented when backwards compatible bug fixes are made.', 'ftype': 'natural', 'bitOffset': 8, 'bitWidth': 8, 'access': 'ro', 'reset': 0}, 'prerelease': {'name': 'Pre-release Version', 'desc': 'The prerelease version. Incremented when a testing image is made. For published bitstreams this should be zero.', 'ftype': 'natural', 'bitOffset': 0, 'bitWidth': 8, 'access': 'ro', 'reset': 0}}}, 'commit': {'name': 'Git Commit Hash', 'desc': '', 'fields': {'commit': {'name': 'Git Commit Hash', 'desc': 'Least significant 32b of the git commit hash for the bitstream base or persona.', 'bitOffset': 0, 'bitWidth': 32, 'ftype': 'natural', 'access': 'ro'}}}, 'scratch': {'name': 'Scratch', 'desc': 'A register that you can write and read-back to test basic register bus access.', 'fields': {'scratch': {'name': 'Scratch', 'desc': 'Write-readback field.', 'bitOffset': 0, 'bitWidth': 32, 'ftype': 'natural', 'access': 'rw'}}}}}}}}}, 'eth1': {'driver': 'ethernet_100g_driver', 'register_sets': {'phy': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1052160, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_PHY', 'regdef': {'mnemonic': 'Ethernet_100G_PHY', 'version': '19.2.1', 'regset': {'name': 'Physical Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_PHY', 'desc': ['Physical Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.1', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'revid': {'name': 'REVID', 'addressOffset': '0x00', 'fields': {'REVID': {'name': 'Revision ID', 'desc': 'IP core PHY module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'scratch': {'name': 'SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'scratch': {'name': 'SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'phy_name_0': {'name': 'PHY_NAME_0', 'addressOffset': '0x08', 'fields': {'phy_name_0': {'name': 'PHY_NAME_0', 'desc': "First characters of IP core variation identifier string, '100' = 0x00313030.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00313030'}, 'phy_name_1': {'name': 'PHY_NAME_1', 'addressOffset': '0x0C', 'fields': {'phy_name_1': {'name': 'PHY_NAME_1', 'desc': "Next characters of IP core variation identifier string, 'GE' = 0x00004745.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00004745'}, 'phy_name_2': {'name': 'PHY_NAME_2', 'addressOffset': '0x10', 'fields': {'phy_name_2': {'name': 'PHY_NAME_2', 'desc': "Final characters of IP core variation identifier string, 'pcs' = 0x00706373.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00706373'}, 'phy_config': {'name': 'PHY_CONFIG', 'addressOffset': '0x40', 'desc': 'PHY configuration registers.', 'fields': {'eio_sys_rst': {'name': 'EIO_SYS_RST', 'desc': 'Full system reset (except registers). Set this bit to initiate the internal reset sequence.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SystemReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'soft_txp_rst': {'name': 'SOFT_TXP_RST', 'desc': 'TX soft reset.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SoftTxpReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'soft_rxp_rst': {'name': 'SOFT_RXP_RST', 'desc': 'RX soft reset.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SoftRxpReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'set_ref_lock': {'name': 'SET_REF_LOCK', 'desc': 'Directs the RX CDR PLL to lock to the reference clock.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SetRefLock', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate lock. Write 0 to clear lock bit.'}, 'set_data_lock': {'name': 'SET_DATA_LOCK', 'desc': 'Directs the RX CDR PLL to lock to data.', 'bitOffset': 5, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SetDataLock', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate lock. Write 0 to clear lock bit.'}}}, 'word_lock': {'name': 'WORD_LOCK', 'addressOffset': '0x48', 'fields': {'word_lock': {'name': 'WORD_LOCK', 'desc': 'Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual channel has identified 66 bit block boundaries in the serial data stream. If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 0, 'bitWidth': 20, 'access': 'ro'}}}, 'eio_sloop': {'name': 'EIO_SLOOP', 'addressOffset': '0x4C', 'fields': {'eio_sloop': {'name': 'EIO_SLOOP', 'desc': 'Serial PMA Loopback. Setting a bit puts the corresponding transceiver in serial loopback mode. In serial loopback mode, the TX lane loops back to the RX lane on an internal loopback path.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'eio_flag_sel': {'name': 'EIO_FLAG_SEL', 'addressOffset': '0x50', 'fields': {'eio_flag_sel': {'name': 'EIO_FLAG_SEL', 'desc': ['FIFO flag select. Supports indirect addressing of individual FIFO flags in the 10G PCS Native PHY IP core. Program this register with the encoding for a specific FIFO flag. The flag values (one per transceiver) are then accessible in the EIO_FLAGS register. The value in the EIO_FLAG_SEL register directs the IP core to make available the following FIFO flag:', "* 3'b000: TX FIFO full", "* 3'b001: TX FIFO empty", "* 3'b010: TX FIFO partially full", "* 3'b011: TX FIFO partially empty", "* 3'b100: RX FIFO full", "* 3'b101: RX FIFO empty", "* 3'b110: RX FIFO partially full", "* 3'b111: RX FIFO partially empty"], 'bitOffset': 0, 'bitWidth': 3, 'reset': 0, 'access': 'rw'}}}, 'eio_flags': {'name': 'EIO_FLAGS', 'addressOffset': '0x54', 'fields': {'eio_flags': {'name': 'EIO_FLAGS', 'desc': 'PCS indirect data. To read a FIFO flag, set the value in the EIO_FLAG_SEL register to indicate the flag you want to read. After you specify the flag in the EIO_FLAG_SEL', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'eio_freq_lock': {'name': 'EIO_FREQ_LOCK', 'addressOffset': '0x84', 'fields': {'eio_freq_lock': {'name': 'EIO_FREQ_LOCK', 'desc': 'Each of the lower order four bits, when asserted, indicates that the corresponding lane RX clock data recovery (CDR)  phaselocked loop (PLL) is locked.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'ro'}}}, 'phy_clk': {'name': 'PHY_CLK', 'addressOffset': '0x88', 'fields': {'tx_reset_done': {'name': 'TX_RESET_DONE', 'desc': 'If set to 1, indicates the TX transceivers have completed reset.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'tx_core_clock_stable': {'name': 'TX_CORE_CLOCK_STABLE', 'desc': 'If set to 1, indicates the TX core clock is stable. And if the Enable RS-FEC is turned on, the FEC TX PLL has acquired frequency lock.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'rx_core_clock_stable': {'name': 'RX_CORE_CLOCK_STABLE', 'desc': 'If set to 1, indicates the RX core clock is stable. And if the Enable RS-FEC is turned on, the FEC RX PLL has acquired frequency lock.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}}}, 'frm_err': {'name': 'FRM_ERR', 'addressOffset': '0x8C', 'fields': {'frm_err': {'name': 'FRM_ERR', 'desc': "Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual lane has a frame error. You can read this register to determine if the IP core sustains a low number of frame errors, below the threshold to lose word lock. These bits are sticky, unless the virtual lane loses word lock. Write 1'b1 to the SCLR_FRM_ERR register to clear. If a virtual lane loses word lock, it clears the corresponding register bit. Each bit in this register has a valid value only if the corresponding bit in the WORD_LOCK register at offset 0x312 has the value of 1.  If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 0, 'bitWidth': 20, 'access': 'ro'}}}, 'sclr_frm_err': {'name': 'SCLR_FRM_ERR', 'addressOffset': '0x90', 'fields': {'sclr_frm_err': {'name': 'SCLR_FRM_ERR', 'desc': "Synchronous clear for FRM_ERR register. Write 1'b1 to this register to clear the FRM_ERR register and bit [1] of the LANE_DESKEWED register. A single bit clears all sticky framing errors. This bit does not auto-clear. Write a 1'b0 to continue logging frame errors. If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw', 'tangoCommand': 'SyncClearFrameError', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear FRM_ERR register. Write 0 to continue logging frame errors.'}}}, 'EIO_RX_SOFT_PURGE_S': {'name': 'EIO_RX_SOFT_PURGE_S', 'addressOffset': '0x94', 'fields': {'clear_rx_fifo': {'name': 'clear RX FIFO', 'desc': 'Set to clear the RX FIFO for all four physical lanes.', 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}, 'disable_bitslip': {'name': 'Disable bitslip request', 'desc': 'If set to 1, disables the bitslip request from PCS to PMA.', 'bitOffset': 11, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}, 'disable_autoadaption': {'name': 'Disable Autoadaption', 'desc': 'If set to 1, holds auto adaptation module in Idle state. If set to 0, releases auto adaptation module from the Idle state.', 'bitOffset': 12, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}}}, 'RX_PCS_FULLY_ALIGNED_S': {'name': 'RX_PCS_FULLY_ALIGNED_S', 'addressOffset': '0x98', 'fields': {'rx_pcs_fully_aligned': {'name': 'RX PCS fully aligned status', 'desc': 'RX PCS is fully aligned, If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'ro', 'ftype': 'boolean'}, 'RX_PCS_HI_BER': {'name': 'RX PCS High Bit Error Rate', 'desc': 'RX PCS in a high BER state, If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 1, 'bitWidth': 1, 'reset': 0, 'access': 'ro', 'ftype': 'boolean'}}}, 'err_inj': {'name': 'ERR_INJ', 'addressOffset': '0x9C', 'fields': {'err_inj': {'name': 'Error Inject to lane', 'desc': 'When set to 1, injects an error in the corresponding lane. The register is rising-edge triggered. Write a 0 to clear.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'am_lock': {'name': 'Alignment Marker Lock', 'addressOffset': '0xA0', 'fields': {'am_lock': {'name': 'Alignment Marker Lock', 'desc': ['When bit [0] is asserted, indicates that the IP core has identified virtual lane alignment markers in the data stream of all 20 virtual lanes, and has ordered the virtual lanes.', 'If Enable RS-FEC is turned on, the value is always zero.'], 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}}}, 'lane_deskewed': {'name': 'LANE_DESKEWED', 'addressOffset': '0xA4', 'fields': {'all_lanes_deskewed': {'name': 'ALL_LANES_DESKEWED', 'desc': 'Indicates all lanes are deskewed.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'deskew_change': {'name': 'DESKEW_CHANGE', 'desc': "When asserted indicates a change in lanes deskewed status. To clear this sticky bit, write 1'b1 to the corresponding bit of the SCLR_FRM_ERR register. This is a latched signal. If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}}}, 'pcs_vlane_0_to_4': {'name': 'PCS_VLANE_0_to_4', 'addressOffset': '0xC0', 'fields': {'vlane_a': {'name': 'VLANE_A', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_5_to_9': {'name': 'PCS_VLANE_5_to_9', 'addressOffset': '0xC4', 'fields': {'vlane_b': {'name': 'VLANE_B', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_10_to_14': {'name': 'PCS_VLANE_10_to_14', 'addressOffset': '0xC8', 'fields': {'vlane_c': {'name': 'VLANE_C', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_15_to_19': {'name': 'PCS_VLANE_15_to_19', 'addressOffset': '0xCC', 'fields': {'vlane_d': {'name': 'VLANE_D', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'khz_ref': {'name': 'KHZ_REF', 'addressOffset': '0x100', 'fields': {'khz_ref': {'name': 'KHZ_REF - Deprecated', 'desc': 'Deprecated.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_rx': {'name': 'KHZ_RX', 'addressOffset': '0x104', 'fields': {'khz_rx': {'name': 'KHZ_RX', 'desc': 'RX clock (clk_rxmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_tx': {'name': 'KHZ_TX', 'addressOffset': '0x108', 'fields': {'khz_tx': {'name': 'KHZ_TX', 'desc': 'TX clock (clk_txmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_tx_rs': {'name': 'KHZ_TX_RS', 'addressOffset': '0x10C', 'fields': {'khz_tx_rs': {'name': 'KHZ_TX_RS', 'desc': 'TX clock (clk_tx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_rx_rs': {'name': 'KHZ_RX_RS', 'addressOffset': '0x110', 'fields': {'khz_rx_rs': {'name': 'KHZ_RX_RS', 'desc': 'RX clock (clk_rx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'enable_rsfec': {'name': 'ENABLE_RSFEC', 'addressOffset': '0x140', 'fields': {'enable_rsfec': {'name': 'ENABLE_RSFEC', 'desc': 'Allows you to dynamically control the RS-FEC block which is part of the data path. This register is available only if the Enable RSFEC  is turned on. When the RS-FEC block is enabled, writing 1 enables the RS-FEC data path and writing 0 disables the RS-FEC data path. Note: In a configuration where the RS-FEC + KR feature is enabled, this register has no effect because the data path always includes the RS-FEC by default.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw', 'tangoCommand': 'EnableRsFec', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to enable RS-FEC datapath. Write 0 to disable RS-FEC datapath.'}}}}}}}, 'rx_mac': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049920, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_MAC', 'regdef': {'mnemonic': 'Ethernet_100G_rx_MAC', 'version': '19.2.0', 'regset': {'name': 'Receive Media Access Control (RX-MAC) Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_rx_MAC', 'desc': ['Receive MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'dsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'rxmac_revid': {'name': 'RXMAC_REVID', 'addressOffset': '0x00', 'fields': {'rxmac_revid': {'name': 'RXMAC_REVID', 'desc': 'RX MAC revision ID. 0x0809 2017', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoAttName': 'rxMacRevid'}}, 'tangoTestValue': '0x08092017'}, 'rxmac_scratch': {'name': 'RXMAC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'rxmac_scratch': {'name': 'RXMAC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'rxmac_name_0': {'name': 'RXMAC_NAME_0', 'addressOffset': '0x08', 'fields': {'rxmac_name_0': {'name': 'RXMAC_NAME_0', 'desc': "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x31303067'}, 'rxmac_name_1': {'name': 'RXMAC_NAME_1', 'addressOffset': '0x0C', 'fields': {'rxmac_name_1': {'name': 'RXMAC_NAME_1', 'desc': "Next 4 characters of IP core variation identifier string, 'MACR' = 0x4D414352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x4d414352'}, 'rxmac_name_2': {'name': 'RXMAC_NAME_2', 'addressOffset': '0x10', 'fields': {'rxmac_name_2': {'name': 'RXMAC_NAME_2', 'desc': "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x78435352'}, 'rxmac_size_config': {'name': 'RXMAC_SIZE_CONFIG', 'addressOffset': '0x18', 'fields': {'rxmac_size_config': {'name': 'RXMAC_SIZE_CONFIG', 'desc': 'Specifies the maximum frame length available. The MAC asserts l8_rx_error[3] when the length of the received frame exceeds the value of this register. If the IP core receives an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_RX_OVERSIZE counter. The minimum value of this register is 64 (decimal).', 'bitOffset': 0, 'bitWidth': 16, 'access': 'rw', 'reset': '0x2580'}}}, 'mac_crc_config': {'name': 'MAC_CRC_CONFIG', 'addressOffset': '0x1C', 'fields': {'mac_crc_config': {'name': 'MAC_CRC_CONFIG', 'desc': "he RX CRC forwarding configuration register. The following encodings are defined: 1'b0 : Remove RX CRC, do not forward it to the RX client interface 1'b1 : Retain RX CRC, forward it to the RX client interface In either case, the IP core checks the incoming RX CRC and flags errors.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}, 'rx_link_fault': {'name': 'RX_LINK_FAULT', 'addressOffset': '0x20', 'fields': {'link_fault': {'name': 'LINK_FAULT', 'desc': 'Link Fault Status Register. For unidirectional Link Fault, implements IEEE 802.3 Ethernet Clause 66.', 'bitOffset': 0, 'bitWidth': 2, 'access': 'ro'}}}, 'rxmac_control': {'name': 'RXMAC_CONTROL', 'addressOffset': '0x28', 'fields': {'preamble_check': {'name': 'PREAMBLE_CHECK', 'desc': 'Preamble check. Strict SFD checking option to compare each packet preamble to 0x555555555555. This field is available only if you turn on Enable Strict SFD check.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoCommand': 'RxMacCtrlPreambleCheck', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to enable checking. Write 0 to clear.'}, 'sfd_check': {'name': 'SFD_CHECK', 'desc': 'SFD check. Strict SFD checking option to compare each SFD byte to 0x5D. This field is available only if you turn on Enable Strict SFD check.', 'bitOffset': 3, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoCommand': 'RxMacCtrlSfdCheck', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate check. Write 0 to clear.'}, 'rx_vlan_detect_disable': {'name': 'RX_VLAN_DETECT_DISABLE', 'desc': 'VLAN detection disabled. This bit is deasserted by default implying VLAN detection is enabled.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'RxMacCtrlVlanDetectDisable', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to disable vlan detection. Write 0 to clear.'}}}}}}}, 'rx_rsfec': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049984, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_RSFEC', 'regdef': {'mnemonic': 'Ethernet_100G_rx_RSFEC', 'version': '19.2.0', 'regset': {'name': 'Receive Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_rx_RSFEC', 'desc': ['Receive RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'rx_rsfec_revid': {'name': 'RX_RSFEC_REVID', 'addressOffset': '0x00', 'fields': {'rx_rsfec_revid': {'name': 'RX_RSFEC_REVID', 'desc': 'Reed-Solomon FEC RX module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'rx_rsfec_scratch': {'name': 'RX_RSFEC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'rx_rsfec_scratch': {'name': 'RX_RSFEC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}, 'rx_rsfec_name_0': {'name': 'RX_RSFEC_NAME_0', 'addressOffset': '0x08', 'fields': {'rx_rsfec_name_0': {'name': 'RX_RSFEC_NAME_0', 'desc': "Final 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x67303031'}, 'rx_rsfec_name_1': {'name': 'RX_RSFEC_NAME_1', 'addressOffset': '0x0C', 'fields': {'rx_rsfec_name_1': {'name': 'RX_RSFEC_NAME_1', 'desc': "Middle 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x45465352'}, 'rx_rsfec_name_2': {'name': 'RX_RSFEC_NAME_2', 'addressOffset': '0x10', 'fields': {'rx_rsfec_name_2': {'name': 'RX_RSFEC_NAME_2', 'desc': "Initial 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x58526f43'}, 'bypass_restart': {'name': 'BYPASS_RESTART', 'addressOffset': '0x14', 'fields': {'restart': {'name': 'RESTART', 'desc': "Restart state machines. When 1'b1, specifies the IP core restarts the FEC synchronization and alignment state machines. Bit self-clears after alignment marker synchronization is restarted. (Refer to Figure 91-8 and Figure 91-9 in IEEE Standard 802.3bj-2014).", 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}, 'bypass': {'name': 'BYPASS', 'desc': "Bypass RS-FEC decoder. When 1'b1, specifies the IP core bypasses the RSFEC decoder. When 1'b0, enables RSFEC error correction.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}, 'rx_fec_status': {'name': 'RX_FEC_STATUS', 'addressOffset': '0x18', 'fields': {'fec_lane': {'name': 'FEC_LANE', 'desc': 'Two bits per lane hold the FEC lane number when the corresponding amps_lock bit (in register bits [3:0]) has the value of 1.', 'bitOffset': 8, 'bitWidth': 2, 'access': 'ro', 'repeat': 4, 'skip': 2}, 'fec_align_status': {'name': 'FEC_ALIGN_STATUS', 'desc': "Alignment marker lock status. When 1'b1, indicates all lanes are synchronized and aligned. When 1'b0, indicates the deskew process is not yet complete. (Refer to Figure 91-9 in IEEE Standard 802.3bj-2014).", 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'amps_lock': {'name': 'AMPS_LOCK', 'desc': 'Each bit indicates that the receiver has detected the location of the alignment marker payload sequence for the corresponding FEC lane. (Refer to Figure 91-8 in IEEE Standard 802.3bj-2014).', 'bitOffset': 0, 'bitWidth': 4, 'access': 'ro'}}}, 'corrected_cw': {'name': 'CORRECTED_CW', 'addressOffset': '0x1C', 'fields': {'corrected_cw': {'name': 'CORRECTED_CW', 'desc': '32-bit counter that contains the number of corrected FEC codewords processed. The value resets to zero upon read and holds at max count.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'uncorrected_cw': {'name': 'UNCORRECTED_CW', 'addressOffset': '0x20', 'fields': {'uncorrected_cw': {'name': 'UNCORRECTED_CW', 'desc': '32-bit counter that contains the number of uncorrected FEC codewords processed. The value resets to zero upon read and holds at max count. This register gets updated based on the error correction logic even when BYPASS_RESTART bit [0] is 1.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}}}}}, 'rx_statistics': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1052672, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_STAT', 'regdef': {'mnemonic': 'Ethernet_100G_rx_statistics', 'version': '19.2.0', 'regset': {'name': 'Receive Statistics (Intel Stratix10 100GbE MAC)', 'desc': ['Receive Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'mnemonic': 'Ethernet_100G_rx_statistics', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'cntr_rx_fragments': {'name': 'CNTR_RX_FRAGMENTS', 'addressOffset': '0x00', 'width': 64, 'fields': {'cntr_rx_fragments': {'name': 'CNTR_RX_FRAGMENTS', 'desc': 'Number of received frames less than 64 bytes and reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_jabbers': {'name': 'CNTR_RX_JABBERS', 'addressOffset': '0x08', 'width': 64, 'fields': {'cntr_rx_jabbers': {'name': 'CNTR_RX_JABBERS', 'desc': 'Number of received oversized frames reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_fcs': {'name': 'CNTR_RX_FCS', 'addressOffset': '0x10', 'width': 64, 'fields': {'cntr_rx_fcs': {'name': 'CNTR_RX_FCS', 'desc': 'Number of received packets with FCS errors. This register maintains a count of the number of pulses on the l<n>_rx_fcs_error or rx_fcs_error output signal', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_crcerr': {'name': 'CNTR_RX_CRCERR', 'addressOffset': '0x18', 'width': 64, 'fields': {'cntr_rx_crcerr': {'name': 'CNTR_RX_CRCERR', 'desc': 'Number of received frames with a frame of length at least 64, with CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_data_err': {'name': 'CNTR_RX_MCAST_DATA_ERR', 'addressOffset': '0x20', 'width': 64, 'fields': {'cntr_rx_mcast_data_err': {'name': 'CNTR_RX_MCAST_DATA_ERR', 'desc': 'Number of errored multicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_data_err': {'name': 'CNTR_RX_BCAST_DATA_ERR', 'addressOffset': '0x28', 'width': 64, 'fields': {'cntr_rx_bcast_data_err': {'name': 'CNTR_RX_BCAST_DATA_ERR', 'desc': 'Number of errored broadcast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_data_err': {'name': 'CNTR_RX_UCAST_DATA_ERR', 'addressOffset': '0x30', 'width': 64, 'fields': {'cntr_rx_ucast_data_err': {'name': 'CNTR_RX_UCAST_DATA_ERR', 'desc': 'Number of errored unicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_ctrl_err': {'name': 'CNTR_RX_MCAST_CTRL_ERR', 'addressOffset': '0x38', 'width': 64, 'fields': {'cntr_rx_mcast_ctrl_err': {'name': 'CNTR_RX_MCAST_CTRL_ERR', 'desc': 'Number of errored multicast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_ctrl_err': {'name': 'CNTR_RX_BCAST_CTRL_ERR', 'addressOffset': '0x40', 'width': 64, 'fields': {'cntr_rx_bcast_ctrl_err': {'name': 'CNTR_RX_BCAST_CTRL_ERR', 'desc': 'Number of errored broadcast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_ctrl_err': {'name': 'CNTR_RX_UCAST_CTRL_ERR', 'addressOffset': '0x48', 'width': 64, 'fields': {'cntr_rx_ucast_ctrl_err': {'name': 'CNTR_RX_UCAST_CTRL_ERR', 'desc': 'Number of errored unicast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_pause_err': {'name': 'CNTR_RX_PAUSE_ERR', 'addressOffset': '0x50', 'width': 64, 'fields': {'cntr_rx_pause_err': {'name': 'CNTR_RX_PAUSE_ERR', 'desc': 'Number of errored pause frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxPauseErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_64b': {'name': 'CNTR_RX_64B', 'addressOffset': '0x58', 'width': 64, 'fields': {'cntr_rx_64b': {'name': 'CNTR_RX_64B', 'desc': 'Number of 64-byte received frames, including the CRC field but excluding the preamble and SFD bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx64B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_65to127b': {'name': 'CNTR_RX_65to127B', 'addressOffset': '0x60', 'width': 64, 'fields': {'cntr_rx_65to127b': {'name': 'CNTR_RX_65to127B', 'desc': 'Number of received frames between 65-127 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx65to127B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_128to255b': {'name': 'CNTR_RX_128to255B', 'addressOffset': '0x68', 'width': 64, 'fields': {'cntr_rx_128to255b': {'name': 'CNTR_RX_128to255B', 'desc': 'Number of received frames between 128-255 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx128to255B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_256to511b': {'name': 'CNTR_RX_256to511B', 'addressOffset': '0x70', 'width': 64, 'fields': {'cntr_rx_256to511b': {'name': 'CNTR_RX_256to511B', 'desc': 'Number of received frames between 256-511 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx256to511B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_512to1023b': {'name': 'CNTR_RX_512to1023B', 'addressOffset': '0x78', 'width': 64, 'fields': {'cntr_rx_512to1023b': {'name': 'CNTR_RX_512to1023B', 'desc': 'Number of received frames between 512-1023 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx512to1023B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_1024to1518b': {'name': 'CNTR_RX_1024to1518B', 'addressOffset': '0x80', 'width': 64, 'fields': {'cntr_rx_1024to1518b': {'name': 'CNTR_RX_1024to1518B', 'desc': 'Number of received frames between 1024-1518 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx1024to1518B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_1519tomaxb': {'name': 'CNTR_RX_1519toMAXB', 'addressOffset': '0x88', 'width': 64, 'fields': {'cntr_rx_1519tomaxb': {'name': 'CNTR_RX_1519toMAXB', 'desc': 'Number of received frames between 1519 bytes and the maximum size defined in the RXMAC_SIZE_CONFIG register', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx1519toMaxB', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_oversize': {'name': 'CNTR_RX_OVERSIZE', 'addressOffset': '0x90', 'width': 64, 'fields': {'cntr_rx_oversize': {'name': 'CNTR_RX_OVERSIZE', 'desc': 'Number of oversized frames (frames with more bytes than the number specified in the RXMAC_SIZE_CONFIG register) received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxOversize', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_data_ok': {'name': 'CNTR_RX_MCAST_DATA_OK', 'addressOffset': '0x98', 'width': 64, 'fields': {'cntr_rx_mcast_data_ok': {'name': 'CNTR_RX_MCAST_DATA_OK', 'desc': 'Number of valid multicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_data_ok': {'name': 'CNTR_RX_BCAST_DATA_OK', 'addressOffset': '0xA0', 'width': 64, 'fields': {'cntr_rx_bcast_data_ok': {'name': 'CNTR_RX_BCAST_DATA_OK', 'desc': 'Number of valid broadcast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_data_ok': {'name': 'CNTR_RX_UCAST_DATA_OK', 'addressOffset': '0xA8', 'width': 64, 'fields': {'cntr_rx_ucast_data_ok': {'name': 'CNTR_RX_UCAST_DATA_OK', 'desc': 'Number of valid unicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_ctrl': {'name': 'CNTR_RX_MCAST_CTRL', 'addressOffset': '0xB0', 'width': 64, 'fields': {'cntr_rx_mcast_ctrl': {'name': 'CNTR_RX_MCAST_CTRL', 'desc': 'Number of valid multicast frames received, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_ctrl': {'name': 'CNTR_RX_BCAST_CTRL', 'addressOffset': '0xB8', 'width': 64, 'fields': {'cntr_rx_bcast_ctrl': {'name': 'CNTR_RX_BCAST_CTRL', 'desc': 'Number of valid broadcast frames received, excluding data frames(lower 32 bits)', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_ctrl': {'name': 'CNTR_RX_UCAST_CTRL', 'addressOffset': '0xC0', 'width': 64, 'fields': {'cntr_rx_ucast_ctrl': {'name': 'CNTR_RX_UCAST_CTRL', 'desc': 'Number of valid unicast frames received, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_pause': {'name': 'CNTR_RX_PAUSE', 'addressOffset': '0xC8', 'width': 64, 'fields': {'cntr_rx_pause': {'name': 'CNTR_RX_PAUSE', 'desc': 'Number of received pause frames, with or without error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxPause', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_runt': {'name': 'CNTR_RX_RUNT', 'addressOffset': '0xD0', 'width': 64, 'fields': {'cntr_rx_runt': {'name': 'CNTR_RX_RUNT', 'desc': 'Number of received runt packets A run is a packet of size less than 64 bytes but greater than eight bytes. If a packet is eight bytes or smaller, it is considered a decoding error and not a runt frame, and the IP core does not flag it nor count it as a runt.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxRunt', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_config': {'name': 'CNTR_RX_CONFIG', 'addressOffset': '0x114', 'fields': {'rx_shadow_req': {'name': 'RX_SHADOW_REQ', 'desc': 'Shadow request (active high): When set to the value of 1, RX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigShadowRequest', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to pause Rx statistics. Write 0 to clear.'}, 'rx_parity_err_clr': {'name': 'RX_PARITY_ERR_CLR', 'desc': 'Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_RX_STATUS[0]. This bit (CNTR_RX_CONFIG[1]) is self-clearing.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigParityErrorClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear the parity bit.'}, 'rx_cnt_clr': {'name': 'RX_CNT_CLR', 'desc': 'Software can set this bit to the value of 1 to reset all of the Rx statistics registers at the same time. This bit is self-clearing.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigCounterClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear all Rx Statistics registers.'}}}, 'cntr_rx_status': {'name': 'CNTR_RX_STATUS', 'addressOffset': '0x118', 'fields': {'rx_cnt_pause': {'name': 'RX_CNT_PAUSE', 'desc': 'Indicates that the RX statistics registers are paused (while CNTR_RX_CONFIG[2] is asserted).', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'rx_parity_err': {'name': 'RX_PARITY_ERR', 'desc': 'Indicates the presence of at least one parity error in the RX statistics counters.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'rxpayloadoctetsok': {'name': 'RxPayloadOctetsOK', 'addressOffset': '0x180', 'width': 64, 'fields': {'rxpayloadoctetsok': {'name': 'RxPayloadOctetsOK', 'desc': 'Number of received payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the RX MAC (bit [1] of the RXMAC_CONTROL register at offset 0x50A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsReceivedOK in section 5.2.2.1.14 of the IEEE Standard 802.3-2008.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'RxPayloadOctetsOK', 'tangoDataType': 'DevULong64'}}}, 'rxframeoctetsok': {'name': 'RxFrameOctetsOK', 'addressOffset': '0x188', 'width': 64, 'fields': {'rxframeoctetsok': {'name': 'RxFrameOctetsOK', 'desc': 'Number of received bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifInOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and RX etherStatsOctets in RFC2819 (Remote Network Monitoring Management Information Base (RMON)).', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'RxFrameOctetsOK', 'tangoDataType': 'DevULong64'}}}}}}}, 'tx_mac': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1050048, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_MAC', 'regdef': {'mnemonic': 'Ethernet_100G_tx_MAC', 'version': '19.2.0', 'regset': {'name': 'Transmit Media Access Control (TX-MAC) Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_MAC', 'desc': ['Transmit MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'dsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'txmac_revid': {'name': 'TXMAC_REVID', 'addressOffset': '0x00', 'fields': {'txmac_revid': {'name': 'TXMAC_REVID', 'desc': 'TX MAC revision ID. 0x0809 2017', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'txmac_scratch': {'name': 'TXMAC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'txmac_scratch': {'name': 'TXMAC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'txmac_name_0': {'name': 'TXMAC_NAME_0', 'addressOffset': '0x08', 'fields': {'txmac_name_0': {'name': 'TXMAC_NAME_0', 'desc': "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x31303067'}, 'txmac_name_1': {'name': 'TXMAC_NAME_1', 'addressOffset': '0x0C', 'fields': {'txmac_name_1': {'name': 'TXMAC_NAME_1', 'desc': "Next 4 characters of IP core variation identifier string, 'MACT' = 0x4D414354.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x4D414354'}, 'txmac_name_2': {'name': 'TXMAC_NAME_2', 'addressOffset': '0x10', 'fields': {'txmac_name_2': {'name': 'TXMAC_NAME_2', 'desc': "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x78435352'}, 'tx_link_fault': {'name': 'TX_LINK_FAULT', 'addressOffset': '0x14', 'desc': 'Link Fault Configuration Register.', 'fields': {'force_remote_fault': {'name': 'FORCE_REMOTE_FAULT', 'desc': 'When link fault generation is enabled, stops data transmission and forces transmission of a remote fault.', 'bitOffset': 3, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultForceRemote', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to stop data transmission and force transmistion of a remote fault. Write 0 to clear.'}, 'disable_remote_fault': {'name': 'DISABLE_REMOTE_FAULT', 'desc': "When both link fault reporting and unidirectional transport are enabled, the core transmits data and does not transmit remote faults (RF). This bit takes effect when the value of this register is 28'hX4'b0111.", 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultDisableRemote', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to disable. Write 0 to clear.'}, 'unidir_enable': {'name': 'UNIDIR_ENABLE', 'desc': 'When asserted, the core includes Clause 66 support for the remote link fault reporting on the Ethernet link.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultUnidirEnable', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to include clause 66 support for remote link fault reporting. Write 0 to clear'}, 'pcs_gen_fault_sequence': {'name': 'PCS_GEN_FAULT_SEQUENCE', 'desc': "The following encodings are defined: 1'b1: The PCS generates the proper fault sequence on Ethernet link, when conditions are met. 1'b0: The PCS does not generate the fault sequence.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 1, 'tangoCommand': 'TxLinkFaultPcsGenSequence', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to generate fault sequence. Write 0 to clear.'}}}, 'ipg_col_rem': {'name': 'IPG_COL_REM', 'addressOffset': '0x18', 'fields': {'ipg_col_rem': {'name': 'IPG_COL_REM', 'desc': 'Specifies the number of IDLE columns to be removed in every Alignment Marker period to compensate for alignment marker insertion. You can program this register to a larger value than the default value, for clock compensation.', 'bitOffset': 0, 'bitWidth': 7, 'access': 'rw', 'reset': 20}}}, 'txmac_size_config': {'name': 'TXMAC_SIZE_CONFIG', 'addressOffset': '0x1C', 'fields': {'max_tx_size_config': {'name': 'MAX_TX_SIZE_CONFIG', 'desc': 'Specifies the maximum TX frame length. Frames that are longer are considered oversized. However, the IP core does transmit them. If the IP core transmits an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_TX_OVERSIZE counter. The minimum value of this register is 64 (decimal).', 'bitOffset': 0, 'bitWidth': 16, 'access': 'rw', 'reset': '0x2580'}}}, 'tx_mac_control': {'name': 'TX_MAC_CONTROL', 'addressOffset': '0x28', 'fields': {'tx_vlan_detect_disable': {'name': 'TX_VLAN_DETECT_DISABLE', 'desc': 'This bit is deasserted by default, implying VLAN detection is enabled.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}}}}}, 'tx_rsfec': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1050112, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_RSFEC', 'regdef': {'mnemonic': 'Ethernet_100G_tx_RSFEC', 'version': '19.2.0', 'regset': {'name': 'Transmit Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_RSFEC', 'desc': ['Transmit RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'tx_rsfec_revid': {'name': 'TX_RSFEC_REVID', 'addressOffset': '0x00', 'fields': {'tx_rsfec_revid': {'name': 'TX_RSFEC_REVID', 'desc': 'Reed-Solomon FEC TX module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'tx_rsfec_scratch': {'name': 'TX_RSFEC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'tx_rsfec_scratch': {'name': 'TX_RSFEC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}, 'tx_rsfec_name_0': {'name': 'TX_RSFEC_NAME_0', 'addressOffset': '0x08', 'fields': {'tx_rsfec_name_0': {'name': 'TX_RSFEC_NAME_0', 'desc': "Final 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x67303031'}, 'tx_rsfec_name_1': {'name': 'TX_RSFEC_NAME_1', 'addressOffset': '0x0C', 'fields': {'tx_rsfec_name_1': {'name': 'TX_RSFEC_NAME_1', 'desc': "Middle 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x45465352'}, 'tx_rsfec_name_2': {'name': 'TX_RSFEC_NAME_2', 'addressOffset': '0x10', 'fields': {'tx_rsfec_name_2': {'name': 'TX_RSFEC_NAME_2', 'desc': "Initial 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x58546f43'}, 'err_ins_en': {'name': 'ERR_INS_EN', 'addressOffset': '0x14', 'fields': {'err_ins_single': {'name': 'ERR_INS_SINGLE', 'desc': 'Enables error insertion for single FEC codeword. This bit selfclears after the Reed-Solomon FEC transmitter inserts the error.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'err_ins_all': {'name': 'ERR_INS_ALL', 'desc': 'Enables error insertion for every FEC codeword. Specifies that the Reed-Solomon FEC transmitter should insert the error in every FEC codeword.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'err_mask': {'name': 'ERR_MASK', 'addressOffset': '0x18', 'fields': {'sym_32': {'name': 'SYM_32', 'desc': 'Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies whether the RSFEC transmitter corrupts symbol 32 (of symbols 0-32) in each corrupted group. Specifically, the value of 1 directs the IP core to corrupt symbol 32 according to BIT_MASK.', 'bitOffset': 24, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'bit_mask': {'name': 'BIT_MASK', 'desc': 'Specifies which of the ten bits the RS-FEC transmitter corrupts in each corrupted symbol. Specifically, the value of 1 in bit [n+8] directs the IP core to corrupt bit [n] in each corrupted symbol.', 'bitOffset': 8, 'bitWidth': 10, 'access': 'rw'}, 'group_num': {'name': 'GROUP_NUM', 'desc': "Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies the single group of 33 symbols that the RS-FEC transmitter corrupts in the current FEC codeword. The following values are defined: 4'b000: First group of 33 symbols (symbols 0-32) 4'b0001: Second group of symbols (symbols 33-65) ... 4'b1110: Second-to-final group of symbols (symbols 462-494) 4'b1111: Final group of symbols (symbols 495-527, or {chk[13:0],sym[514:495]}) Continuous corruption of groups 0-3 might lead to strange behavior as result of alignment marker corruption.", 'bitOffset': 0, 'bitWidth': 4, 'access': 'rw'}}}, 'symbol_err_mask': {'name': 'SYMBOL_ERR_MASK', 'addressOffset': '0x1C', 'fields': {'symbol_err_mask': {'name': 'SYMBOL_ERR_MASK', 'desc': 'Each FEC codeword consists of 16 groups of 33 symbols. This register specifies which of the lower order 32 symbols in a group the RS-FEC transmitter corrupts. Specifically the value of 1 in bit [n] directs the IP core to corrupt symbol n.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}}}}}, 'tx_statistics': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1053184, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_STAT', 'regdef': {'mnemonic': 'Ethernet_100G_tx_statistics', 'version': '19.2.0', 'regset': {'name': 'Transmit Statistics (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_statistics', 'desc': ['Transmit Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'cntr_tx_fragments': {'name': 'CNTR_TX_FRAGMENTS', 'addressOffset': '0x00', 'width': 64, 'fields': {'cntr_tx_fragments': {'name': 'CNTR_TX_FRAGMENTS', 'desc': 'Number of transmitted frames less than 64 bytes and reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_jabbers': {'name': 'CNTR_TX_JABBERS', 'addressOffset': '0x08', 'width': 64, 'fields': {'cntr_tx_jabbers': {'name': 'CNTR_TX_JABBERS', 'desc': 'Number of transmitted oversized frames reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_fcs': {'name': 'CNTR_TX_FCS', 'addressOffset': '0x10', 'width': 64, 'fields': {'cntr_tx_fcs': {'name': 'CNTR_TX_FCS', 'desc': 'Number of transmitted packets with FCS errors.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_crcerr': {'name': 'CNTR_TX_CRCERR', 'addressOffset': '0x18', 'width': 64, 'fields': {'cntr_tx_crcerr': {'name': 'CNTR_TX_CRCERR', 'desc': 'Number of transmitted frames with a frame of length at least 64 reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_data_err': {'name': 'CNTR_TX_MCAST_DATA_ERR', 'addressOffset': '0x20', 'width': 64, 'fields': {'cntr_tx_mcast_data_err': {'name': 'CNTR_TX_MCAST_DATA_ERR', 'desc': 'Number of errored multicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_data_err': {'name': 'CNTR_TX_BCAST_DATA_ERR', 'addressOffset': '0x28', 'width': 64, 'fields': {'cntr_tx_bcast_data_err': {'name': 'CNTR_TX_BCAST_DATA_ERR', 'desc': 'Number of errored broadcast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_data_err': {'name': 'CNTR_TX_UCAST_DATA_ERR', 'addressOffset': '0x30', 'width': 64, 'fields': {'cntr_tx_ucast_data_err': {'name': 'CNTR_TX_UCAST_DATA_ERR', 'desc': 'Number of errored unicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_ctrl_err': {'name': 'CNTR_TX_MCAST_CTRL_ERR', 'addressOffset': '0x38', 'width': 64, 'fields': {'cntr_tx_mcast_ctrl_err': {'name': 'CNTR_TX_MCAST_CTRL_ERR', 'desc': 'Number of errored multicast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_ctrl_err': {'name': 'CNTR_TX_BCAST_CTRL_ERR', 'addressOffset': '0x40', 'width': 64, 'fields': {'cntr_tx_bcast_ctrl_err': {'name': 'CNTR_TX_BCAST_CTRL_ERR', 'desc': 'Number of errored broadcast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_ctrl_err': {'name': 'CNTR_TX_UCAST_CTRL_ERR', 'addressOffset': '0x48', 'width': 64, 'fields': {'cntr_tx_ucast_ctrl_err': {'name': 'CNTR_TX_UCAST_CTRL_ERR', 'desc': 'Number of errored unicast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_pause_err': {'name': 'CNTR_TX_PAUSE_ERR', 'addressOffset': '0x50', 'width': 64, 'fields': {'cntr_tx_pause_err': {'name': 'CNTR_TX_PAUSE_ERR', 'desc': 'Number of errored pause frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_64b': {'name': 'CNTR_TX_64B', 'addressOffset': '0x58', 'width': 64, 'fields': {'cntr_tx_64b': {'name': 'CNTR_TX_64B', 'desc': 'Number of 64-byte transmitted frames, including the CRC field but excluding the preamble and SFD bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_65to127b': {'name': 'CNTR_TX_65to127B', 'addressOffset': '0x60', 'width': 64, 'fields': {'cntr_tx_65to127b': {'name': 'CNTR_TX_65to127B', 'desc': 'Number of transmitted frames between 65-127 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_128to255b': {'name': 'CNTR_TX_128to255B', 'addressOffset': '0x68', 'width': 64, 'fields': {'cntr_tx_128to255b': {'name': 'CNTR_TX_128to255B', 'desc': 'Number of transmitted frames between 128-255 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_256to511b': {'name': 'CNTR_TX_256to511B', 'addressOffset': '0x70', 'width': 64, 'fields': {'cntr_tx_256to511b': {'name': 'CNTR_TX_256to511B', 'desc': 'Number of transmitted frames between 256-511 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_512to1023b': {'name': 'CNTR_TX_512to1023B', 'addressOffset': '0x78', 'width': 64, 'fields': {'cntr_tx_512to1023b': {'name': 'CNTR_TX_512to1023B', 'desc': 'Number of transmitted frames between 512-1023 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_1024to1518b': {'name': 'CNTR_TX_1024to1518B', 'addressOffset': '0x80', 'width': 64, 'fields': {'cntr_tx_1024to1518b': {'name': 'CNTR_TX_1024to1518B', 'desc': 'Number of transmitted frames between 1024-1518 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_1519tomaxb': {'name': 'CNTR_TX_1519toMAXB', 'addressOffset': '0x88', 'width': 64, 'fields': {'cntr_tx_1519tomaxb': {'name': 'CNTR_TX_1519toMAXB', 'desc': 'Number of transmitted frames of size between 1519 bytes and the number of bytes specified in the MAX_TX_SIZE_CONFIG register', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_oversize': {'name': 'CNTR_TX_OVERSIZE', 'addressOffset': '0x90', 'width': 64, 'fields': {'cntr_tx_oversize': {'name': 'CNTR_TX_OVERSIZE', 'desc': 'Number of oversized frames (frames with more bytes than the number specified in the MAX_TX_SIZE_CONFIG register) transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_data_ok': {'name': 'CNTR_TX_MCAST_DATA_OK', 'addressOffset': '0x98', 'width': 64, 'fields': {'cntr_tx_mcast_data_ok': {'name': 'CNTR_TX_MCAST_DATA_OK', 'desc': 'Number of valid multicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_data_ok': {'name': 'CNTR_TX_BCAST_DATA_OK', 'addressOffset': '0xA0', 'width': 64, 'fields': {'cntr_tx_bcast_data_ok': {'name': 'CNTR_TX_BCAST_DATA_OK', 'desc': 'Number of valid broadcast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_data_ok': {'name': 'CNTR_TX_UCAST_DATA_OK', 'addressOffset': '0xA8', 'width': 64, 'fields': {'cntr_tx_ucast_data_ok': {'name': 'CNTR_TX_UCAST_DATA_OK', 'desc': 'Number of valid unicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_ctrl': {'name': 'CNTR_TX_MCAST_CTRL', 'addressOffset': '0xB0', 'width': 64, 'fields': {'cntr_tx_mcast_ctrl': {'name': 'CNTR_TX_MCAST_CTRL', 'desc': 'Number of valid multicast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_ctrl': {'name': 'CNTR_TX_BCAST_CTRL', 'addressOffset': '0xB8', 'width': 64, 'fields': {'cntr_tx_bcast_ctrl': {'name': 'CNTR_TX_BCAST_CTRL', 'desc': 'Number of valid broadcast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_ctrl': {'name': 'CNTR_TX_UCAST_CTRL', 'addressOffset': '0xC0', 'width': 64, 'fields': {'cntr_tx_ucast_ctrl': {'name': 'CNTR_TX_UCAST_CTRL', 'desc': 'Number of valid unicast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_pause': {'name': 'CNTR_TX_PAUSE', 'addressOffset': '0xC8', 'width': 64, 'fields': {'cntr_tx_pause': {'name': 'CNTR_TX_PAUSE', 'desc': 'Number of valid pause frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_runt': {'name': 'CNTR_TX_RUNT', 'addressOffset': '0xD0', 'width': 64, 'fields': {'cntr_tx_runt': {'name': 'CNTR_TX_RUNT', 'desc': 'Number of transmitted runt packets. The IP core does not transmit frames of length less than nine bytes. The IP core pads frames of length nine bytes to 64 bytes to extend them to 64 bytes. Therefore, this counter does not increment in normal operating conditions.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_config': {'name': 'CNTR_TX_CONFIG', 'addressOffset': '0x114', 'fields': {'tx_shadow_req': {'name': 'TX_SHADOW_REQ', 'desc': 'Shadow request (active high): When set to the value of 1, TX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigShadowRequest', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to pause Tx statistics. Write 0 to release.'}, 'tx_parity_err_clr': {'name': 'TX_PARITY_ERR_CLR', 'desc': 'Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_TX_STATUS[0]. This bit (CNTR_TX_CONFIG[1]) is self-clearing.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigParityErrorClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear the parity bit.'}, 'tx_cnt_clr': {'name': 'TX_CNT_CLR', 'desc': 'Software can set this bit to the value of 1 to reset all of the TX statistics registers at the same time. This bit is self-clearing.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigCounterClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to reset all Tx statistics.'}}}, 'cntr_tx_status': {'name': 'CNTR_TX_STATUS', 'addressOffset': '0x118', 'fields': {'tx_cnt_pause': {'name': 'TX_CNT_PAUSE', 'desc': 'Indicates that the TX statistics registers are paused (while CNTR_TX_CONFIG[2] is asserted).', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'tx_parity_err': {'name': 'TX_PARITY_ERR', 'desc': 'Indicates the presence of at least one parity error in the TX statistics counters.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'txpayloadoctetsok': {'name': 'TxPayloadOctetsOK', 'addressOffset': '0x180', 'width': 64, 'fields': {'txpayloadoctetsok': {'name': 'TxPayloadOctetsOK', 'desc': 'Number of transmitted payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the TX MAC (bit[1] of the TX_MAC_CONTROL register at offset 0x40A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsTransmittedOK in section 5.2.2.1.8 of the IEEE Standard 802.3-2008.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'txframeoctetsok': {'name': 'TxFrameOctetsOK', 'addressOffset': '0x188', 'width': 64, 'fields': {'txframeoctetsok': {'name': 'TxFrameOctetsOK', 'desc': 'Number of transmitted bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifOutOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and TX etherStatsOctets in RFC2819(Remote Network Monitoring Management Information Base (RMON)).', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}}}}}, 'qsfp': {'bridge_address': 4177526784, 'firmware_depth': 8, 'firmware_offset': 1048584, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[1]|E_100GBE|G_QSFP_CTRL|E_QSFP', 'regdef': {'mnemonic': 'qsfp_ctrl', 'version': '1.0.0', 'regset': {'name': 'QSFP Control', 'mnemonic': 'qsfp_ctrl', 'desc': 'QSFP Low-Speed Signaling', 'version': '1.0.0', 'tangoClassName': 'DsTalonDxQsfpCtrl', 'tangoClassTitle': 'Talon-DX QSFP Module Control TANGO Device', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX QSFP Control Intel Stratix 10 FPGA IP Core Module.', 'registers': {'ctrl': {'name': 'Control', 'addressOffset': '0x0', 'desc': 'QSFP Low-Speed Control.', 'fields': {'mod_sel_n': {'name': 'mod_sel_n', 'desc': "When set to '0', the QSFP module responds to 2-wire serial communication commands. When set to '1' the module does not respond to or acknowledge any 2-wire interface communication from the host. This allows the use of multiple QSFP module on a single 2-wire bus.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoAttName': 'modeSelect', 'tangoAttDesc': 'Read or write the mode select value directly to the register using the attribute construct.', 'tangoAttLabel': 'Mode Select', 'tangoCommand': 'ModeSelect', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 0 to configure QSFP to respond to 2-wire serial comm commands, Write 1 to disable 2-wire interface.'}, 'reset_n': {'name': 'reset_n', 'desc': "Toggling this field to '0' then back to '1' initiates a complete QSFP module reset, returning all user module settings to their default state. The module indicates completion of reset by posting an interrupt signal.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoAttName': 'reset', 'tangoAttDesc': 'Read or write the reset bit directly to the register via the attribute construct.', 'tangoAttLabel': 'Reset', 'tangoCommand': 'ResetDevice', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 0 then write 1 to initiate a complete QSFP module reset.'}, 'lowpwr': {'name': 'lowpwr', 'desc': "Setting this field to '1' sets the module in low-power mode. This essentially disables the laser and receiver but keeps the I2C accessable.", 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoAttName': 'lowPower', 'tangoAttDesc': 'Read or write the low power bit directly to the register via the attribute construct.', 'tangoAttLabel': 'Low Power', 'tangoCommand': 'LowPower', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to set module in low-power mode. Write 0 to remove from low-power mode.'}}}, 'status': {'name': 'Status', 'addressOffset': '0x4', 'desc': 'QSFP Low-Speed Status.', 'fields': {'mod_prs_n': {'name': 'mod_prs_n', 'desc': "When read as '0' this field indicates that the QSFP module is present. When read as '1' this field indicates that the QSFP module is not present.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro', 'tangoAttName': 'present'}, 'interrupt_n': {'name': 'interrupt_n', 'desc': "When read as '0' this field indicates that the module has a pending interrupt that can be serviced through the 2-wire serial interface.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro', 'tangoAttName': 'interrupt'}}}}}}}}}, 'eth0': {'driver': 'ethernet_100g_driver', 'register_sets': {'phy': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1050624, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_PHY', 'regdef': {'mnemonic': 'Ethernet_100G_PHY', 'version': '19.2.1', 'regset': {'name': 'Physical Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_PHY', 'desc': ['Physical Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.1', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'revid': {'name': 'REVID', 'addressOffset': '0x00', 'fields': {'REVID': {'name': 'Revision ID', 'desc': 'IP core PHY module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'scratch': {'name': 'SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'scratch': {'name': 'SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'phy_name_0': {'name': 'PHY_NAME_0', 'addressOffset': '0x08', 'fields': {'phy_name_0': {'name': 'PHY_NAME_0', 'desc': "First characters of IP core variation identifier string, '100' = 0x00313030.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00313030'}, 'phy_name_1': {'name': 'PHY_NAME_1', 'addressOffset': '0x0C', 'fields': {'phy_name_1': {'name': 'PHY_NAME_1', 'desc': "Next characters of IP core variation identifier string, 'GE' = 0x00004745.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00004745'}, 'phy_name_2': {'name': 'PHY_NAME_2', 'addressOffset': '0x10', 'fields': {'phy_name_2': {'name': 'PHY_NAME_2', 'desc': "Final characters of IP core variation identifier string, 'pcs' = 0x00706373.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'phyName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x00706373'}, 'phy_config': {'name': 'PHY_CONFIG', 'addressOffset': '0x40', 'desc': 'PHY configuration registers.', 'fields': {'eio_sys_rst': {'name': 'EIO_SYS_RST', 'desc': 'Full system reset (except registers). Set this bit to initiate the internal reset sequence.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SystemReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'soft_txp_rst': {'name': 'SOFT_TXP_RST', 'desc': 'TX soft reset.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SoftTxpReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'soft_rxp_rst': {'name': 'SOFT_RXP_RST', 'desc': 'RX soft reset.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SoftRxpReset', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate reset. Write 0 to clear reset bit.'}, 'set_ref_lock': {'name': 'SET_REF_LOCK', 'desc': 'Directs the RX CDR PLL to lock to the reference clock.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SetRefLock', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate lock. Write 0 to clear lock bit.'}, 'set_data_lock': {'name': 'SET_DATA_LOCK', 'desc': 'Directs the RX CDR PLL to lock to data.', 'bitOffset': 5, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'SetDataLock', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate lock. Write 0 to clear lock bit.'}}}, 'word_lock': {'name': 'WORD_LOCK', 'addressOffset': '0x48', 'fields': {'word_lock': {'name': 'WORD_LOCK', 'desc': 'Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual channel has identified 66 bit block boundaries in the serial data stream. If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 0, 'bitWidth': 20, 'access': 'ro'}}}, 'eio_sloop': {'name': 'EIO_SLOOP', 'addressOffset': '0x4C', 'fields': {'eio_sloop': {'name': 'EIO_SLOOP', 'desc': 'Serial PMA Loopback. Setting a bit puts the corresponding transceiver in serial loopback mode. In serial loopback mode, the TX lane loops back to the RX lane on an internal loopback path.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'eio_flag_sel': {'name': 'EIO_FLAG_SEL', 'addressOffset': '0x50', 'fields': {'eio_flag_sel': {'name': 'EIO_FLAG_SEL', 'desc': ['FIFO flag select. Supports indirect addressing of individual FIFO flags in the 10G PCS Native PHY IP core. Program this register with the encoding for a specific FIFO flag. The flag values (one per transceiver) are then accessible in the EIO_FLAGS register. The value in the EIO_FLAG_SEL register directs the IP core to make available the following FIFO flag:', "* 3'b000: TX FIFO full", "* 3'b001: TX FIFO empty", "* 3'b010: TX FIFO partially full", "* 3'b011: TX FIFO partially empty", "* 3'b100: RX FIFO full", "* 3'b101: RX FIFO empty", "* 3'b110: RX FIFO partially full", "* 3'b111: RX FIFO partially empty"], 'bitOffset': 0, 'bitWidth': 3, 'reset': 0, 'access': 'rw'}}}, 'eio_flags': {'name': 'EIO_FLAGS', 'addressOffset': '0x54', 'fields': {'eio_flags': {'name': 'EIO_FLAGS', 'desc': 'PCS indirect data. To read a FIFO flag, set the value in the EIO_FLAG_SEL register to indicate the flag you want to read. After you specify the flag in the EIO_FLAG_SEL', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'eio_freq_lock': {'name': 'EIO_FREQ_LOCK', 'addressOffset': '0x84', 'fields': {'eio_freq_lock': {'name': 'EIO_FREQ_LOCK', 'desc': 'Each of the lower order four bits, when asserted, indicates that the corresponding lane RX clock data recovery (CDR)  phaselocked loop (PLL) is locked.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'ro'}}}, 'phy_clk': {'name': 'PHY_CLK', 'addressOffset': '0x88', 'fields': {'tx_reset_done': {'name': 'TX_RESET_DONE', 'desc': 'If set to 1, indicates the TX transceivers have completed reset.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'tx_core_clock_stable': {'name': 'TX_CORE_CLOCK_STABLE', 'desc': 'If set to 1, indicates the TX core clock is stable. And if the Enable RS-FEC is turned on, the FEC TX PLL has acquired frequency lock.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'rx_core_clock_stable': {'name': 'RX_CORE_CLOCK_STABLE', 'desc': 'If set to 1, indicates the RX core clock is stable. And if the Enable RS-FEC is turned on, the FEC RX PLL has acquired frequency lock.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}}}, 'frm_err': {'name': 'FRM_ERR', 'addressOffset': '0x8C', 'fields': {'frm_err': {'name': 'FRM_ERR', 'desc': "Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual lane has a frame error. You can read this register to determine if the IP core sustains a low number of frame errors, below the threshold to lose word lock. These bits are sticky, unless the virtual lane loses word lock. Write 1'b1 to the SCLR_FRM_ERR register to clear. If a virtual lane loses word lock, it clears the corresponding register bit. Each bit in this register has a valid value only if the corresponding bit in the WORD_LOCK register at offset 0x312 has the value of 1.  If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 0, 'bitWidth': 20, 'access': 'ro'}}}, 'sclr_frm_err': {'name': 'SCLR_FRM_ERR', 'addressOffset': '0x90', 'fields': {'sclr_frm_err': {'name': 'SCLR_FRM_ERR', 'desc': "Synchronous clear for FRM_ERR register. Write 1'b1 to this register to clear the FRM_ERR register and bit [1] of the LANE_DESKEWED register. A single bit clears all sticky framing errors. This bit does not auto-clear. Write a 1'b0 to continue logging frame errors. If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw', 'tangoCommand': 'SyncClearFrameError', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear FRM_ERR register. Write 0 to continue logging frame errors.'}}}, 'EIO_RX_SOFT_PURGE_S': {'name': 'EIO_RX_SOFT_PURGE_S', 'addressOffset': '0x94', 'fields': {'clear_rx_fifo': {'name': 'clear RX FIFO', 'desc': 'Set to clear the RX FIFO for all four physical lanes.', 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}, 'disable_bitslip': {'name': 'Disable bitslip request', 'desc': 'If set to 1, disables the bitslip request from PCS to PMA.', 'bitOffset': 11, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}, 'disable_autoadaption': {'name': 'Disable Autoadaption', 'desc': 'If set to 1, holds auto adaptation module in Idle state. If set to 0, releases auto adaptation module from the Idle state.', 'bitOffset': 12, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}}}, 'RX_PCS_FULLY_ALIGNED_S': {'name': 'RX_PCS_FULLY_ALIGNED_S', 'addressOffset': '0x98', 'fields': {'rx_pcs_fully_aligned': {'name': 'RX PCS fully aligned status', 'desc': 'RX PCS is fully aligned, If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'ro', 'ftype': 'boolean'}, 'RX_PCS_HI_BER': {'name': 'RX PCS High Bit Error Rate', 'desc': 'RX PCS in a high BER state, If Enable RS-FEC is turned on, the value is always zero.', 'bitOffset': 1, 'bitWidth': 1, 'reset': 0, 'access': 'ro', 'ftype': 'boolean'}}}, 'err_inj': {'name': 'ERR_INJ', 'addressOffset': '0x9C', 'fields': {'err_inj': {'name': 'Error Inject to lane', 'desc': 'When set to 1, injects an error in the corresponding lane. The register is rising-edge triggered. Write a 0 to clear.', 'bitOffset': 0, 'bitWidth': 4, 'reset': 0, 'access': 'rw'}}}, 'am_lock': {'name': 'Alignment Marker Lock', 'addressOffset': '0xA0', 'fields': {'am_lock': {'name': 'Alignment Marker Lock', 'desc': ['When bit [0] is asserted, indicates that the IP core has identified virtual lane alignment markers in the data stream of all 20 virtual lanes, and has ordered the virtual lanes.', 'If Enable RS-FEC is turned on, the value is always zero.'], 'bitOffset': 0, 'bitWidth': 1, 'reset': 0, 'access': 'rw', 'ftype': 'boolean'}}}, 'lane_deskewed': {'name': 'LANE_DESKEWED', 'addressOffset': '0xA4', 'fields': {'all_lanes_deskewed': {'name': 'ALL_LANES_DESKEWED', 'desc': 'Indicates all lanes are deskewed.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'deskew_change': {'name': 'DESKEW_CHANGE', 'desc': "When asserted indicates a change in lanes deskewed status. To clear this sticky bit, write 1'b1 to the corresponding bit of the SCLR_FRM_ERR register. This is a latched signal. If Enable RS-FEC is turned on, the value is always zero.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}}}, 'pcs_vlane_0_to_4': {'name': 'PCS_VLANE_0_to_4', 'addressOffset': '0xC0', 'fields': {'vlane_a': {'name': 'VLANE_A', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_5_to_9': {'name': 'PCS_VLANE_5_to_9', 'addressOffset': '0xC4', 'fields': {'vlane_b': {'name': 'VLANE_B', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_10_to_14': {'name': 'PCS_VLANE_10_to_14', 'addressOffset': '0xC8', 'fields': {'vlane_c': {'name': 'VLANE_C', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'pcs_vlane_15_to_19': {'name': 'PCS_VLANE_15_to_19', 'addressOffset': '0xCC', 'fields': {'vlane_d': {'name': 'VLANE_D', 'desc': "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.", 'bitOffset': 0, 'bitWidth': 5, 'repeat': 5, 'skip': 5, 'access': 'ro', 'tangoParentName': True, 'tangoImageX': 5, 'tangoImageY': 1}}}, 'khz_ref': {'name': 'KHZ_REF', 'addressOffset': '0x100', 'fields': {'khz_ref': {'name': 'KHZ_REF - Deprecated', 'desc': 'Deprecated.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_rx': {'name': 'KHZ_RX', 'addressOffset': '0x104', 'fields': {'khz_rx': {'name': 'KHZ_RX', 'desc': 'RX clock (clk_rxmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_tx': {'name': 'KHZ_TX', 'addressOffset': '0x108', 'fields': {'khz_tx': {'name': 'KHZ_TX', 'desc': 'TX clock (clk_txmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_tx_rs': {'name': 'KHZ_TX_RS', 'addressOffset': '0x10C', 'fields': {'khz_tx_rs': {'name': 'KHZ_TX_RS', 'desc': 'TX clock (clk_tx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'khz_rx_rs': {'name': 'KHZ_RX_RS', 'addressOffset': '0x110', 'fields': {'khz_rx_rs': {'name': 'KHZ_RX_RS', 'desc': 'RX clock (clk_rx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'enable_rsfec': {'name': 'ENABLE_RSFEC', 'addressOffset': '0x140', 'fields': {'enable_rsfec': {'name': 'ENABLE_RSFEC', 'desc': 'Allows you to dynamically control the RS-FEC block which is part of the data path. This register is available only if the Enable RSFEC  is turned on. When the RS-FEC block is enabled, writing 1 enables the RS-FEC data path and writing 0 disables the RS-FEC data path. Note: In a configuration where the RS-FEC + KR feature is enabled, this register has no effect because the data path always includes the RS-FEC by default.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw', 'tangoCommand': 'EnableRsFec', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to enable RS-FEC datapath. Write 0 to disable RS-FEC datapath.'}}}}}}}, 'rx_mac': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049664, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_MAC', 'regdef': {'mnemonic': 'Ethernet_100G_rx_MAC', 'version': '19.2.0', 'regset': {'name': 'Receive Media Access Control (RX-MAC) Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_rx_MAC', 'desc': ['Receive MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'dsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'rxmac_revid': {'name': 'RXMAC_REVID', 'addressOffset': '0x00', 'fields': {'rxmac_revid': {'name': 'RXMAC_REVID', 'desc': 'RX MAC revision ID. 0x0809 2017', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoAttName': 'rxMacRevid'}}, 'tangoTestValue': '0x08092017'}, 'rxmac_scratch': {'name': 'RXMAC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'rxmac_scratch': {'name': 'RXMAC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'rxmac_name_0': {'name': 'RXMAC_NAME_0', 'addressOffset': '0x08', 'fields': {'rxmac_name_0': {'name': 'RXMAC_NAME_0', 'desc': "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x31303067'}, 'rxmac_name_1': {'name': 'RXMAC_NAME_1', 'addressOffset': '0x0C', 'fields': {'rxmac_name_1': {'name': 'RXMAC_NAME_1', 'desc': "Next 4 characters of IP core variation identifier string, 'MACR' = 0x4D414352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x4d414352'}, 'rxmac_name_2': {'name': 'RXMAC_NAME_2', 'addressOffset': '0x10', 'fields': {'rxmac_name_2': {'name': 'RXMAC_NAME_2', 'desc': "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x78435352'}, 'rxmac_size_config': {'name': 'RXMAC_SIZE_CONFIG', 'addressOffset': '0x18', 'fields': {'rxmac_size_config': {'name': 'RXMAC_SIZE_CONFIG', 'desc': 'Specifies the maximum frame length available. The MAC asserts l8_rx_error[3] when the length of the received frame exceeds the value of this register. If the IP core receives an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_RX_OVERSIZE counter. The minimum value of this register is 64 (decimal).', 'bitOffset': 0, 'bitWidth': 16, 'access': 'rw', 'reset': '0x2580'}}}, 'mac_crc_config': {'name': 'MAC_CRC_CONFIG', 'addressOffset': '0x1C', 'fields': {'mac_crc_config': {'name': 'MAC_CRC_CONFIG', 'desc': "he RX CRC forwarding configuration register. The following encodings are defined: 1'b0 : Remove RX CRC, do not forward it to the RX client interface 1'b1 : Retain RX CRC, forward it to the RX client interface In either case, the IP core checks the incoming RX CRC and flags errors.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}, 'rx_link_fault': {'name': 'RX_LINK_FAULT', 'addressOffset': '0x20', 'fields': {'link_fault': {'name': 'LINK_FAULT', 'desc': 'Link Fault Status Register. For unidirectional Link Fault, implements IEEE 802.3 Ethernet Clause 66.', 'bitOffset': 0, 'bitWidth': 2, 'access': 'ro'}}}, 'rxmac_control': {'name': 'RXMAC_CONTROL', 'addressOffset': '0x28', 'fields': {'preamble_check': {'name': 'PREAMBLE_CHECK', 'desc': 'Preamble check. Strict SFD checking option to compare each packet preamble to 0x555555555555. This field is available only if you turn on Enable Strict SFD check.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoCommand': 'RxMacCtrlPreambleCheck', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to enable checking. Write 0 to clear.'}, 'sfd_check': {'name': 'SFD_CHECK', 'desc': 'SFD check. Strict SFD checking option to compare each SFD byte to 0x5D. This field is available only if you turn on Enable Strict SFD check.', 'bitOffset': 3, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoCommand': 'RxMacCtrlSfdCheck', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to initiate check. Write 0 to clear.'}, 'rx_vlan_detect_disable': {'name': 'RX_VLAN_DETECT_DISABLE', 'desc': 'VLAN detection disabled. This bit is deasserted by default implying VLAN detection is enabled.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoCommand': 'RxMacCtrlVlanDetectDisable', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to disable vlan detection. Write 0 to clear.'}}}}}}}, 'rx_rsfec': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049728, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_RSFEC', 'regdef': {'mnemonic': 'Ethernet_100G_rx_RSFEC', 'version': '19.2.0', 'regset': {'name': 'Receive Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_rx_RSFEC', 'desc': ['Receive RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'rx_rsfec_revid': {'name': 'RX_RSFEC_REVID', 'addressOffset': '0x00', 'fields': {'rx_rsfec_revid': {'name': 'RX_RSFEC_REVID', 'desc': 'Reed-Solomon FEC RX module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'rx_rsfec_scratch': {'name': 'RX_RSFEC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'rx_rsfec_scratch': {'name': 'RX_RSFEC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}, 'rx_rsfec_name_0': {'name': 'RX_RSFEC_NAME_0', 'addressOffset': '0x08', 'fields': {'rx_rsfec_name_0': {'name': 'RX_RSFEC_NAME_0', 'desc': "Final 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x67303031'}, 'rx_rsfec_name_1': {'name': 'RX_RSFEC_NAME_1', 'addressOffset': '0x0C', 'fields': {'rx_rsfec_name_1': {'name': 'RX_RSFEC_NAME_1', 'desc': "Middle 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x45465352'}, 'rx_rsfec_name_2': {'name': 'RX_RSFEC_NAME_2', 'addressOffset': '0x10', 'fields': {'rx_rsfec_name_2': {'name': 'RX_RSFEC_NAME_2', 'desc': "Initial 4 characters of IP core variation identifier string, '100gRSFECoRX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'rxRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x58526f43'}, 'bypass_restart': {'name': 'BYPASS_RESTART', 'addressOffset': '0x14', 'fields': {'restart': {'name': 'RESTART', 'desc': "Restart state machines. When 1'b1, specifies the IP core restarts the FEC synchronization and alignment state machines. Bit self-clears after alignment marker synchronization is restarted. (Refer to Figure 91-8 and Figure 91-9 in IEEE Standard 802.3bj-2014).", 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}, 'bypass': {'name': 'BYPASS', 'desc': "Bypass RS-FEC decoder. When 1'b1, specifies the IP core bypasses the RSFEC decoder. When 1'b0, enables RSFEC error correction.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}, 'rx_fec_status': {'name': 'RX_FEC_STATUS', 'addressOffset': '0x18', 'fields': {'fec_lane': {'name': 'FEC_LANE', 'desc': 'Two bits per lane hold the FEC lane number when the corresponding amps_lock bit (in register bits [3:0]) has the value of 1.', 'bitOffset': 8, 'bitWidth': 2, 'access': 'ro', 'repeat': 4, 'skip': 2}, 'fec_align_status': {'name': 'FEC_ALIGN_STATUS', 'desc': "Alignment marker lock status. When 1'b1, indicates all lanes are synchronized and aligned. When 1'b0, indicates the deskew process is not yet complete. (Refer to Figure 91-9 in IEEE Standard 802.3bj-2014).", 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro'}, 'amps_lock': {'name': 'AMPS_LOCK', 'desc': 'Each bit indicates that the receiver has detected the location of the alignment marker payload sequence for the corresponding FEC lane. (Refer to Figure 91-8 in IEEE Standard 802.3bj-2014).', 'bitOffset': 0, 'bitWidth': 4, 'access': 'ro'}}}, 'corrected_cw': {'name': 'CORRECTED_CW', 'addressOffset': '0x1C', 'fields': {'corrected_cw': {'name': 'CORRECTED_CW', 'desc': '32-bit counter that contains the number of corrected FEC codewords processed. The value resets to zero upon read and holds at max count.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}, 'uncorrected_cw': {'name': 'UNCORRECTED_CW', 'addressOffset': '0x20', 'fields': {'uncorrected_cw': {'name': 'UNCORRECTED_CW', 'desc': '32-bit counter that contains the number of uncorrected FEC codewords processed. The value resets to zero upon read and holds at max count. This register gets updated based on the error correction logic even when BYPASS_RESTART bit [0] is 1.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}}}}}}, 'rx_statistics': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1051136, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_STAT', 'regdef': {'mnemonic': 'Ethernet_100G_rx_statistics', 'version': '19.2.0', 'regset': {'name': 'Receive Statistics (Intel Stratix10 100GbE MAC)', 'desc': ['Receive Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'mnemonic': 'Ethernet_100G_rx_statistics', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'cntr_rx_fragments': {'name': 'CNTR_RX_FRAGMENTS', 'addressOffset': '0x00', 'width': 64, 'fields': {'cntr_rx_fragments': {'name': 'CNTR_RX_FRAGMENTS', 'desc': 'Number of received frames less than 64 bytes and reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_jabbers': {'name': 'CNTR_RX_JABBERS', 'addressOffset': '0x08', 'width': 64, 'fields': {'cntr_rx_jabbers': {'name': 'CNTR_RX_JABBERS', 'desc': 'Number of received oversized frames reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_fcs': {'name': 'CNTR_RX_FCS', 'addressOffset': '0x10', 'width': 64, 'fields': {'cntr_rx_fcs': {'name': 'CNTR_RX_FCS', 'desc': 'Number of received packets with FCS errors. This register maintains a count of the number of pulses on the l<n>_rx_fcs_error or rx_fcs_error output signal', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_crcerr': {'name': 'CNTR_RX_CRCERR', 'addressOffset': '0x18', 'width': 64, 'fields': {'cntr_rx_crcerr': {'name': 'CNTR_RX_CRCERR', 'desc': 'Number of received frames with a frame of length at least 64, with CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_data_err': {'name': 'CNTR_RX_MCAST_DATA_ERR', 'addressOffset': '0x20', 'width': 64, 'fields': {'cntr_rx_mcast_data_err': {'name': 'CNTR_RX_MCAST_DATA_ERR', 'desc': 'Number of errored multicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_data_err': {'name': 'CNTR_RX_BCAST_DATA_ERR', 'addressOffset': '0x28', 'width': 64, 'fields': {'cntr_rx_bcast_data_err': {'name': 'CNTR_RX_BCAST_DATA_ERR', 'desc': 'Number of errored broadcast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_data_err': {'name': 'CNTR_RX_UCAST_DATA_ERR', 'addressOffset': '0x30', 'width': 64, 'fields': {'cntr_rx_ucast_data_err': {'name': 'CNTR_RX_UCAST_DATA_ERR', 'desc': 'Number of errored unicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastDataErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_ctrl_err': {'name': 'CNTR_RX_MCAST_CTRL_ERR', 'addressOffset': '0x38', 'width': 64, 'fields': {'cntr_rx_mcast_ctrl_err': {'name': 'CNTR_RX_MCAST_CTRL_ERR', 'desc': 'Number of errored multicast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_ctrl_err': {'name': 'CNTR_RX_BCAST_CTRL_ERR', 'addressOffset': '0x40', 'width': 64, 'fields': {'cntr_rx_bcast_ctrl_err': {'name': 'CNTR_RX_BCAST_CTRL_ERR', 'desc': 'Number of errored broadcast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_ctrl_err': {'name': 'CNTR_RX_UCAST_CTRL_ERR', 'addressOffset': '0x48', 'width': 64, 'fields': {'cntr_rx_ucast_ctrl_err': {'name': 'CNTR_RX_UCAST_CTRL_ERR', 'desc': 'Number of errored unicast control frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastCtrlErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_pause_err': {'name': 'CNTR_RX_PAUSE_ERR', 'addressOffset': '0x50', 'width': 64, 'fields': {'cntr_rx_pause_err': {'name': 'CNTR_RX_PAUSE_ERR', 'desc': 'Number of errored pause frames received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxPauseErr', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_64b': {'name': 'CNTR_RX_64B', 'addressOffset': '0x58', 'width': 64, 'fields': {'cntr_rx_64b': {'name': 'CNTR_RX_64B', 'desc': 'Number of 64-byte received frames, including the CRC field but excluding the preamble and SFD bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx64B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_65to127b': {'name': 'CNTR_RX_65to127B', 'addressOffset': '0x60', 'width': 64, 'fields': {'cntr_rx_65to127b': {'name': 'CNTR_RX_65to127B', 'desc': 'Number of received frames between 65-127 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx65to127B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_128to255b': {'name': 'CNTR_RX_128to255B', 'addressOffset': '0x68', 'width': 64, 'fields': {'cntr_rx_128to255b': {'name': 'CNTR_RX_128to255B', 'desc': 'Number of received frames between 128-255 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx128to255B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_256to511b': {'name': 'CNTR_RX_256to511B', 'addressOffset': '0x70', 'width': 64, 'fields': {'cntr_rx_256to511b': {'name': 'CNTR_RX_256to511B', 'desc': 'Number of received frames between 256-511 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx256to511B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_512to1023b': {'name': 'CNTR_RX_512to1023B', 'addressOffset': '0x78', 'width': 64, 'fields': {'cntr_rx_512to1023b': {'name': 'CNTR_RX_512to1023B', 'desc': 'Number of received frames between 512-1023 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx512to1023B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_1024to1518b': {'name': 'CNTR_RX_1024to1518B', 'addressOffset': '0x80', 'width': 64, 'fields': {'cntr_rx_1024to1518b': {'name': 'CNTR_RX_1024to1518B', 'desc': 'Number of received frames between 1024-1518 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx1024to1518B', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_1519tomaxb': {'name': 'CNTR_RX_1519toMAXB', 'addressOffset': '0x88', 'width': 64, 'fields': {'cntr_rx_1519tomaxb': {'name': 'CNTR_RX_1519toMAXB', 'desc': 'Number of received frames between 1519 bytes and the maximum size defined in the RXMAC_SIZE_CONFIG register', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRx1519toMaxB', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_oversize': {'name': 'CNTR_RX_OVERSIZE', 'addressOffset': '0x90', 'width': 64, 'fields': {'cntr_rx_oversize': {'name': 'CNTR_RX_OVERSIZE', 'desc': 'Number of oversized frames (frames with more bytes than the number specified in the RXMAC_SIZE_CONFIG register) received', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxOversize', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_data_ok': {'name': 'CNTR_RX_MCAST_DATA_OK', 'addressOffset': '0x98', 'width': 64, 'fields': {'cntr_rx_mcast_data_ok': {'name': 'CNTR_RX_MCAST_DATA_OK', 'desc': 'Number of valid multicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_data_ok': {'name': 'CNTR_RX_BCAST_DATA_OK', 'addressOffset': '0xA0', 'width': 64, 'fields': {'cntr_rx_bcast_data_ok': {'name': 'CNTR_RX_BCAST_DATA_OK', 'desc': 'Number of valid broadcast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_data_ok': {'name': 'CNTR_RX_UCAST_DATA_OK', 'addressOffset': '0xA8', 'width': 64, 'fields': {'cntr_rx_ucast_data_ok': {'name': 'CNTR_RX_UCAST_DATA_OK', 'desc': 'Number of valid unicast frames received, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastDataOk', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_mcast_ctrl': {'name': 'CNTR_RX_MCAST_CTRL', 'addressOffset': '0xB0', 'width': 64, 'fields': {'cntr_rx_mcast_ctrl': {'name': 'CNTR_RX_MCAST_CTRL', 'desc': 'Number of valid multicast frames received, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxMcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_bcast_ctrl': {'name': 'CNTR_RX_BCAST_CTRL', 'addressOffset': '0xB8', 'width': 64, 'fields': {'cntr_rx_bcast_ctrl': {'name': 'CNTR_RX_BCAST_CTRL', 'desc': 'Number of valid broadcast frames received, excluding data frames(lower 32 bits)', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxBcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_ucast_ctrl': {'name': 'CNTR_RX_UCAST_CTRL', 'addressOffset': '0xC0', 'width': 64, 'fields': {'cntr_rx_ucast_ctrl': {'name': 'CNTR_RX_UCAST_CTRL', 'desc': 'Number of valid unicast frames received, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxUcastCtrl', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_pause': {'name': 'CNTR_RX_PAUSE', 'addressOffset': '0xC8', 'width': 64, 'fields': {'cntr_rx_pause': {'name': 'CNTR_RX_PAUSE', 'desc': 'Number of received pause frames, with or without error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxPause', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_runt': {'name': 'CNTR_RX_RUNT', 'addressOffset': '0xD0', 'width': 64, 'fields': {'cntr_rx_runt': {'name': 'CNTR_RX_RUNT', 'desc': 'Number of received runt packets A run is a packet of size less than 64 bytes but greater than eight bytes. If a packet is eight bytes or smaller, it is considered a decoding error and not a runt frame, and the IP core does not flag it nor count it as a runt.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'cntrRxRunt', 'tangoDataType': 'DevULong64'}}}, 'cntr_rx_config': {'name': 'CNTR_RX_CONFIG', 'addressOffset': '0x114', 'fields': {'rx_shadow_req': {'name': 'RX_SHADOW_REQ', 'desc': 'Shadow request (active high): When set to the value of 1, RX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigShadowRequest', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to pause Rx statistics. Write 0 to clear.'}, 'rx_parity_err_clr': {'name': 'RX_PARITY_ERR_CLR', 'desc': 'Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_RX_STATUS[0]. This bit (CNTR_RX_CONFIG[1]) is self-clearing.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigParityErrorClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear the parity bit.'}, 'rx_cnt_clr': {'name': 'RX_CNT_CLR', 'desc': 'Software can set this bit to the value of 1 to reset all of the Rx statistics registers at the same time. This bit is self-clearing.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'RxCntrConfigCounterClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear all Rx Statistics registers.'}}}, 'cntr_rx_status': {'name': 'CNTR_RX_STATUS', 'addressOffset': '0x118', 'fields': {'rx_cnt_pause': {'name': 'RX_CNT_PAUSE', 'desc': 'Indicates that the RX statistics registers are paused (while CNTR_RX_CONFIG[2] is asserted).', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'rx_parity_err': {'name': 'RX_PARITY_ERR', 'desc': 'Indicates the presence of at least one parity error in the RX statistics counters.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'rxpayloadoctetsok': {'name': 'RxPayloadOctetsOK', 'addressOffset': '0x180', 'width': 64, 'fields': {'rxpayloadoctetsok': {'name': 'RxPayloadOctetsOK', 'desc': 'Number of received payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the RX MAC (bit [1] of the RXMAC_CONTROL register at offset 0x50A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsReceivedOK in section 5.2.2.1.14 of the IEEE Standard 802.3-2008.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'RxPayloadOctetsOK', 'tangoDataType': 'DevULong64'}}}, 'rxframeoctetsok': {'name': 'RxFrameOctetsOK', 'addressOffset': '0x188', 'width': 64, 'fields': {'rxframeoctetsok': {'name': 'RxFrameOctetsOK', 'desc': 'Number of received bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifInOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and RX etherStatsOctets in RFC2819 (Remote Network Monitoring Management Information Base (RMON)).', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoCombine': 'RxFrameOctetsOK', 'tangoDataType': 'DevULong64'}}}}}}}, 'tx_mac': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049792, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_MAC', 'regdef': {'mnemonic': 'Ethernet_100G_tx_MAC', 'version': '19.2.0', 'regset': {'name': 'Transmit Media Access Control (TX-MAC) Layer (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_MAC', 'desc': ['Transmit MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'dsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'txmac_revid': {'name': 'TXMAC_REVID', 'addressOffset': '0x00', 'fields': {'txmac_revid': {'name': 'TXMAC_REVID', 'desc': 'TX MAC revision ID. 0x0809 2017', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'txmac_scratch': {'name': 'TXMAC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'txmac_scratch': {'name': 'TXMAC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'reset': 0, 'access': 'rw'}}}, 'txmac_name_0': {'name': 'TXMAC_NAME_0', 'addressOffset': '0x08', 'fields': {'txmac_name_0': {'name': 'TXMAC_NAME_0', 'desc': "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x31303067'}, 'txmac_name_1': {'name': 'TXMAC_NAME_1', 'addressOffset': '0x0C', 'fields': {'txmac_name_1': {'name': 'TXMAC_NAME_1', 'desc': "Next 4 characters of IP core variation identifier string, 'MACT' = 0x4D414354.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x4D414354'}, 'txmac_name_2': {'name': 'TXMAC_NAME_2', 'addressOffset': '0x10', 'fields': {'txmac_name_2': {'name': 'TXMAC_NAME_2', 'desc': "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txMacName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x78435352'}, 'tx_link_fault': {'name': 'TX_LINK_FAULT', 'addressOffset': '0x14', 'desc': 'Link Fault Configuration Register.', 'fields': {'force_remote_fault': {'name': 'FORCE_REMOTE_FAULT', 'desc': 'When link fault generation is enabled, stops data transmission and forces transmission of a remote fault.', 'bitOffset': 3, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultForceRemote', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to stop data transmission and force transmistion of a remote fault. Write 0 to clear.'}, 'disable_remote_fault': {'name': 'DISABLE_REMOTE_FAULT', 'desc': "When both link fault reporting and unidirectional transport are enabled, the core transmits data and does not transmit remote faults (RF). This bit takes effect when the value of this register is 28'hX4'b0111.", 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultDisableRemote', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to disable. Write 0 to clear.'}, 'unidir_enable': {'name': 'UNIDIR_ENABLE', 'desc': 'When asserted, the core includes Clause 66 support for the remote link fault reporting on the Ethernet link.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0, 'tangoCommand': 'TxLinkFaultUnidirEnable', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to include clause 66 support for remote link fault reporting. Write 0 to clear'}, 'pcs_gen_fault_sequence': {'name': 'PCS_GEN_FAULT_SEQUENCE', 'desc': "The following encodings are defined: 1'b1: The PCS generates the proper fault sequence on Ethernet link, when conditions are met. 1'b0: The PCS does not generate the fault sequence.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 1, 'tangoCommand': 'TxLinkFaultPcsGenSequence', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to generate fault sequence. Write 0 to clear.'}}}, 'ipg_col_rem': {'name': 'IPG_COL_REM', 'addressOffset': '0x18', 'fields': {'ipg_col_rem': {'name': 'IPG_COL_REM', 'desc': 'Specifies the number of IDLE columns to be removed in every Alignment Marker period to compensate for alignment marker insertion. You can program this register to a larger value than the default value, for clock compensation.', 'bitOffset': 0, 'bitWidth': 7, 'access': 'rw', 'reset': 20}}}, 'txmac_size_config': {'name': 'TXMAC_SIZE_CONFIG', 'addressOffset': '0x1C', 'fields': {'max_tx_size_config': {'name': 'MAX_TX_SIZE_CONFIG', 'desc': 'Specifies the maximum TX frame length. Frames that are longer are considered oversized. However, the IP core does transmit them. If the IP core transmits an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_TX_OVERSIZE counter. The minimum value of this register is 64 (decimal).', 'bitOffset': 0, 'bitWidth': 16, 'access': 'rw', 'reset': '0x2580'}}}, 'tx_mac_control': {'name': 'TX_MAC_CONTROL', 'addressOffset': '0x28', 'fields': {'tx_vlan_detect_disable': {'name': 'TX_VLAN_DETECT_DISABLE', 'desc': 'This bit is deasserted by default, implying VLAN detection is enabled.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'reset': 0}}}}}}}, 'tx_rsfec': {'bridge_address': 4177526784, 'firmware_depth': 64, 'firmware_offset': 1049856, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_RSFEC', 'regdef': {'mnemonic': 'Ethernet_100G_tx_RSFEC', 'version': '19.2.0', 'regset': {'name': 'Transmit Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_RSFEC', 'desc': ['Transmit RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'tx_rsfec_revid': {'name': 'TX_RSFEC_REVID', 'addressOffset': '0x00', 'fields': {'tx_rsfec_revid': {'name': 'TX_RSFEC_REVID', 'desc': 'Reed-Solomon FEC TX module revision ID = 0x08092017.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro'}}, 'tangoTestValue': '0x08092017'}, 'tx_rsfec_scratch': {'name': 'TX_RSFEC_SCRATCH', 'addressOffset': '0x04', 'tangoIgnore': True, 'fields': {'tx_rsfec_scratch': {'name': 'TX_RSFEC_SCRATCH', 'desc': 'Scratch register available for testing.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}, 'tx_rsfec_name_0': {'name': 'TX_RSFEC_NAME_0', 'addressOffset': '0x08', 'fields': {'tx_rsfec_name_0': {'name': 'TX_RSFEC_NAME_0', 'desc': "Final 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x67303031'}, 'tx_rsfec_name_1': {'name': 'TX_RSFEC_NAME_1', 'addressOffset': '0x0C', 'fields': {'tx_rsfec_name_1': {'name': 'TX_RSFEC_NAME_1', 'desc': "Middle 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x45465352'}, 'tx_rsfec_name_2': {'name': 'TX_RSFEC_NAME_2', 'addressOffset': '0x10', 'fields': {'tx_rsfec_name_2': {'name': 'TX_RSFEC_NAME_2', 'desc': "Initial 4 characters of IP core variation identifier string, '100gRSFECoTX'.", 'bitOffset': 0, 'bitWidth': 32, 'access': 'ro', 'tangoCombine': 'txRsfecName', 'tangoDataType': 'DevString'}}, 'tangoTestValue': '0x58546f43'}, 'err_ins_en': {'name': 'ERR_INS_EN', 'addressOffset': '0x14', 'fields': {'err_ins_single': {'name': 'ERR_INS_SINGLE', 'desc': 'Enables error insertion for single FEC codeword. This bit selfclears after the Reed-Solomon FEC transmitter inserts the error.', 'bitOffset': 4, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'err_ins_all': {'name': 'ERR_INS_ALL', 'desc': 'Enables error insertion for every FEC codeword. Specifies that the Reed-Solomon FEC transmitter should insert the error in every FEC codeword.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'err_mask': {'name': 'ERR_MASK', 'addressOffset': '0x18', 'fields': {'sym_32': {'name': 'SYM_32', 'desc': 'Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies whether the RSFEC transmitter corrupts symbol 32 (of symbols 0-32) in each corrupted group. Specifically, the value of 1 directs the IP core to corrupt symbol 32 according to BIT_MASK.', 'bitOffset': 24, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'bit_mask': {'name': 'BIT_MASK', 'desc': 'Specifies which of the ten bits the RS-FEC transmitter corrupts in each corrupted symbol. Specifically, the value of 1 in bit [n+8] directs the IP core to corrupt bit [n] in each corrupted symbol.', 'bitOffset': 8, 'bitWidth': 10, 'access': 'rw'}, 'group_num': {'name': 'GROUP_NUM', 'desc': "Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies the single group of 33 symbols that the RS-FEC transmitter corrupts in the current FEC codeword. The following values are defined: 4'b000: First group of 33 symbols (symbols 0-32) 4'b0001: Second group of symbols (symbols 33-65) ... 4'b1110: Second-to-final group of symbols (symbols 462-494) 4'b1111: Final group of symbols (symbols 495-527, or {chk[13:0],sym[514:495]}) Continuous corruption of groups 0-3 might lead to strange behavior as result of alignment marker corruption.", 'bitOffset': 0, 'bitWidth': 4, 'access': 'rw'}}}, 'symbol_err_mask': {'name': 'SYMBOL_ERR_MASK', 'addressOffset': '0x1C', 'fields': {'symbol_err_mask': {'name': 'SYMBOL_ERR_MASK', 'desc': 'Each FEC codeword consists of 16 groups of 33 symbols. This register specifies which of the lower order 32 symbols in a group the RS-FEC transmitter corrupts. Specifically the value of 1 in bit [n] directs the IP core to corrupt symbol n.', 'bitOffset': 0, 'bitWidth': 32, 'access': 'rw'}}}}}}}, 'tx_statistics': {'bridge_address': 4177526784, 'firmware_depth': 512, 'firmware_offset': 1051648, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_STAT', 'regdef': {'mnemonic': 'Ethernet_100G_tx_statistics', 'version': '19.2.0', 'regset': {'name': 'Transmit Statistics (Intel Stratix10 100GbE MAC)', 'mnemonic': 'Ethernet_100G_tx_statistics', 'desc': ['Transmit Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'For full documentation refer to the Intel Documentation for the IP core.'], 'referenceDocumentTitle': 'Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide', 'referenceDocument': 'https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605', 'version': '19.2.0', 'tangoClassName': 'DsTalonDx100GigEth', 'tangoClassTitle': 'Talon-DX 100 Gigabit Ethernet Device Server', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.', 'registers': {'cntr_tx_fragments': {'name': 'CNTR_TX_FRAGMENTS', 'addressOffset': '0x00', 'width': 64, 'fields': {'cntr_tx_fragments': {'name': 'CNTR_TX_FRAGMENTS', 'desc': 'Number of transmitted frames less than 64 bytes and reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_jabbers': {'name': 'CNTR_TX_JABBERS', 'addressOffset': '0x08', 'width': 64, 'fields': {'cntr_tx_jabbers': {'name': 'CNTR_TX_JABBERS', 'desc': 'Number of transmitted oversized frames reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_fcs': {'name': 'CNTR_TX_FCS', 'addressOffset': '0x10', 'width': 64, 'fields': {'cntr_tx_fcs': {'name': 'CNTR_TX_FCS', 'desc': 'Number of transmitted packets with FCS errors.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_crcerr': {'name': 'CNTR_TX_CRCERR', 'addressOffset': '0x18', 'width': 64, 'fields': {'cntr_tx_crcerr': {'name': 'CNTR_TX_CRCERR', 'desc': 'Number of transmitted frames with a frame of length at least 64 reporting a CRC error', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_data_err': {'name': 'CNTR_TX_MCAST_DATA_ERR', 'addressOffset': '0x20', 'width': 64, 'fields': {'cntr_tx_mcast_data_err': {'name': 'CNTR_TX_MCAST_DATA_ERR', 'desc': 'Number of errored multicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_data_err': {'name': 'CNTR_TX_BCAST_DATA_ERR', 'addressOffset': '0x28', 'width': 64, 'fields': {'cntr_tx_bcast_data_err': {'name': 'CNTR_TX_BCAST_DATA_ERR', 'desc': 'Number of errored broadcast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_data_err': {'name': 'CNTR_TX_UCAST_DATA_ERR', 'addressOffset': '0x30', 'width': 64, 'fields': {'cntr_tx_ucast_data_err': {'name': 'CNTR_TX_UCAST_DATA_ERR', 'desc': 'Number of errored unicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_ctrl_err': {'name': 'CNTR_TX_MCAST_CTRL_ERR', 'addressOffset': '0x38', 'width': 64, 'fields': {'cntr_tx_mcast_ctrl_err': {'name': 'CNTR_TX_MCAST_CTRL_ERR', 'desc': 'Number of errored multicast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_ctrl_err': {'name': 'CNTR_TX_BCAST_CTRL_ERR', 'addressOffset': '0x40', 'width': 64, 'fields': {'cntr_tx_bcast_ctrl_err': {'name': 'CNTR_TX_BCAST_CTRL_ERR', 'desc': 'Number of errored broadcast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_ctrl_err': {'name': 'CNTR_TX_UCAST_CTRL_ERR', 'addressOffset': '0x48', 'width': 64, 'fields': {'cntr_tx_ucast_ctrl_err': {'name': 'CNTR_TX_UCAST_CTRL_ERR', 'desc': 'Number of errored unicast control frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_pause_err': {'name': 'CNTR_TX_PAUSE_ERR', 'addressOffset': '0x50', 'width': 64, 'fields': {'cntr_tx_pause_err': {'name': 'CNTR_TX_PAUSE_ERR', 'desc': 'Number of errored pause frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_64b': {'name': 'CNTR_TX_64B', 'addressOffset': '0x58', 'width': 64, 'fields': {'cntr_tx_64b': {'name': 'CNTR_TX_64B', 'desc': 'Number of 64-byte transmitted frames, including the CRC field but excluding the preamble and SFD bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_65to127b': {'name': 'CNTR_TX_65to127B', 'addressOffset': '0x60', 'width': 64, 'fields': {'cntr_tx_65to127b': {'name': 'CNTR_TX_65to127B', 'desc': 'Number of transmitted frames between 65-127 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_128to255b': {'name': 'CNTR_TX_128to255B', 'addressOffset': '0x68', 'width': 64, 'fields': {'cntr_tx_128to255b': {'name': 'CNTR_TX_128to255B', 'desc': 'Number of transmitted frames between 128-255 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_256to511b': {'name': 'CNTR_TX_256to511B', 'addressOffset': '0x70', 'width': 64, 'fields': {'cntr_tx_256to511b': {'name': 'CNTR_TX_256to511B', 'desc': 'Number of transmitted frames between 256-511 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_512to1023b': {'name': 'CNTR_TX_512to1023B', 'addressOffset': '0x78', 'width': 64, 'fields': {'cntr_tx_512to1023b': {'name': 'CNTR_TX_512to1023B', 'desc': 'Number of transmitted frames between 512-1023 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_1024to1518b': {'name': 'CNTR_TX_1024to1518B', 'addressOffset': '0x80', 'width': 64, 'fields': {'cntr_tx_1024to1518b': {'name': 'CNTR_TX_1024to1518B', 'desc': 'Number of transmitted frames between 1024-1518 bytes', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_1519tomaxb': {'name': 'CNTR_TX_1519toMAXB', 'addressOffset': '0x88', 'width': 64, 'fields': {'cntr_tx_1519tomaxb': {'name': 'CNTR_TX_1519toMAXB', 'desc': 'Number of transmitted frames of size between 1519 bytes and the number of bytes specified in the MAX_TX_SIZE_CONFIG register', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_oversize': {'name': 'CNTR_TX_OVERSIZE', 'addressOffset': '0x90', 'width': 64, 'fields': {'cntr_tx_oversize': {'name': 'CNTR_TX_OVERSIZE', 'desc': 'Number of oversized frames (frames with more bytes than the number specified in the MAX_TX_SIZE_CONFIG register) transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_data_ok': {'name': 'CNTR_TX_MCAST_DATA_OK', 'addressOffset': '0x98', 'width': 64, 'fields': {'cntr_tx_mcast_data_ok': {'name': 'CNTR_TX_MCAST_DATA_OK', 'desc': 'Number of valid multicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_data_ok': {'name': 'CNTR_TX_BCAST_DATA_OK', 'addressOffset': '0xA0', 'width': 64, 'fields': {'cntr_tx_bcast_data_ok': {'name': 'CNTR_TX_BCAST_DATA_OK', 'desc': 'Number of valid broadcast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_data_ok': {'name': 'CNTR_TX_UCAST_DATA_OK', 'addressOffset': '0xA8', 'width': 64, 'fields': {'cntr_tx_ucast_data_ok': {'name': 'CNTR_TX_UCAST_DATA_OK', 'desc': 'Number of valid unicast frames transmitted, excluding control frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_mcast_ctrl': {'name': 'CNTR_TX_MCAST_CTRL', 'addressOffset': '0xB0', 'width': 64, 'fields': {'cntr_tx_mcast_ctrl': {'name': 'CNTR_TX_MCAST_CTRL', 'desc': 'Number of valid multicast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_bcast_ctrl': {'name': 'CNTR_TX_BCAST_CTRL', 'addressOffset': '0xB8', 'width': 64, 'fields': {'cntr_tx_bcast_ctrl': {'name': 'CNTR_TX_BCAST_CTRL', 'desc': 'Number of valid broadcast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_ucast_ctrl': {'name': 'CNTR_TX_UCAST_CTRL', 'addressOffset': '0xC0', 'width': 64, 'fields': {'cntr_tx_ucast_ctrl': {'name': 'CNTR_TX_UCAST_CTRL', 'desc': 'Number of valid unicast frames transmitted, excluding data frames', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_pause': {'name': 'CNTR_TX_PAUSE', 'addressOffset': '0xC8', 'width': 64, 'fields': {'cntr_tx_pause': {'name': 'CNTR_TX_PAUSE', 'desc': 'Number of valid pause frames transmitted', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_runt': {'name': 'CNTR_TX_RUNT', 'addressOffset': '0xD0', 'width': 64, 'fields': {'cntr_tx_runt': {'name': 'CNTR_TX_RUNT', 'desc': 'Number of transmitted runt packets. The IP core does not transmit frames of length less than nine bytes. The IP core pads frames of length nine bytes to 64 bytes to extend them to 64 bytes. Therefore, this counter does not increment in normal operating conditions.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'cntr_tx_config': {'name': 'CNTR_TX_CONFIG', 'addressOffset': '0x114', 'fields': {'tx_shadow_req': {'name': 'TX_SHADOW_REQ', 'desc': 'Shadow request (active high): When set to the value of 1, TX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.', 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigShadowRequest', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to pause Tx statistics. Write 0 to release.'}, 'tx_parity_err_clr': {'name': 'TX_PARITY_ERR_CLR', 'desc': 'Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_TX_STATUS[0]. This bit (CNTR_TX_CONFIG[1]) is self-clearing.', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigParityErrorClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to clear the parity bit.'}, 'tx_cnt_clr': {'name': 'TX_CNT_CLR', 'desc': 'Software can set this bit to the value of 1 to reset all of the TX statistics registers at the same time. This bit is self-clearing.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw', 'tangoCommand': 'TxCntrConfigCounterClear', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to reset all Tx statistics.'}}}, 'cntr_tx_status': {'name': 'CNTR_TX_STATUS', 'addressOffset': '0x118', 'fields': {'tx_cnt_pause': {'name': 'TX_CNT_PAUSE', 'desc': 'Indicates that the TX statistics registers are paused (while CNTR_TX_CONFIG[2] is asserted).', 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}, 'tx_parity_err': {'name': 'TX_PARITY_ERR', 'desc': 'Indicates the presence of at least one parity error in the TX statistics counters.', 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'rw'}}}, 'txpayloadoctetsok': {'name': 'TxPayloadOctetsOK', 'addressOffset': '0x180', 'width': 64, 'fields': {'txpayloadoctetsok': {'name': 'TxPayloadOctetsOK', 'desc': 'Number of transmitted payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the TX MAC (bit[1] of the TX_MAC_CONTROL register at offset 0x40A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsTransmittedOK in section 5.2.2.1.8 of the IEEE Standard 802.3-2008.', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}, 'txframeoctetsok': {'name': 'TxFrameOctetsOK', 'addressOffset': '0x188', 'width': 64, 'fields': {'txframeoctetsok': {'name': 'TxFrameOctetsOK', 'desc': 'Number of transmitted bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifOutOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and TX etherStatsOctets in RFC2819(Remote Network Monitoring Management Information Base (RMON)).', 'bitOffset': 0, 'bitWidth': 64, 'access': 'ro', 'tangoDataType': 'DevULong64'}}}}}}}, 'qsfp': {'bridge_address': 4177526784, 'firmware_depth': 8, 'firmware_offset': 1048576, 'fpga_hierarchy': 'TOP|E_BASE|G_100GBE[0]|E_100GBE|G_QSFP_CTRL|E_QSFP', 'regdef': {'mnemonic': 'qsfp_ctrl', 'version': '1.0.0', 'regset': {'name': 'QSFP Control', 'mnemonic': 'qsfp_ctrl', 'desc': 'QSFP Low-Speed Signaling', 'version': '1.0.0', 'tangoClassName': 'DsTalonDxQsfpCtrl', 'tangoClassTitle': 'Talon-DX QSFP Module Control TANGO Device', 'tangoClassDescription': 'TANGO Device Server for monitor and control of Talon-DX QSFP Control Intel Stratix 10 FPGA IP Core Module.', 'registers': {'ctrl': {'name': 'Control', 'addressOffset': '0x0', 'desc': 'QSFP Low-Speed Control.', 'fields': {'mod_sel_n': {'name': 'mod_sel_n', 'desc': "When set to '0', the QSFP module responds to 2-wire serial communication commands. When set to '1' the module does not respond to or acknowledge any 2-wire interface communication from the host. This allows the use of multiple QSFP module on a single 2-wire bus.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoAttName': 'modeSelect', 'tangoAttDesc': 'Read or write the mode select value directly to the register using the attribute construct.', 'tangoAttLabel': 'Mode Select', 'tangoCommand': 'ModeSelect', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 0 to configure QSFP to respond to 2-wire serial comm commands, Write 1 to disable 2-wire interface.'}, 'reset_n': {'name': 'reset_n', 'desc': "Toggling this field to '0' then back to '1' initiates a complete QSFP module reset, returning all user module settings to their default state. The module indicates completion of reset by posting an interrupt signal.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 1, 'access': 'rw', 'tangoAttName': 'reset', 'tangoAttDesc': 'Read or write the reset bit directly to the register via the attribute construct.', 'tangoAttLabel': 'Reset', 'tangoCommand': 'ResetDevice', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 0 then write 1 to initiate a complete QSFP module reset.'}, 'lowpwr': {'name': 'lowpwr', 'desc': "Setting this field to '1' sets the module in low-power mode. This essentially disables the laser and receiver but keeps the I2C accessable.", 'bitOffset': 2, 'bitWidth': 1, 'ftype': 'boolean', 'reset': 0, 'access': 'rw', 'tangoAttName': 'lowPower', 'tangoAttDesc': 'Read or write the low power bit directly to the register via the attribute construct.', 'tangoAttLabel': 'Low Power', 'tangoCommand': 'LowPower', 'tangoCommandArginType': 'DevULong', 'tangoCommandArginDesc': 'Write 1 to set module in low-power mode. Write 0 to remove from low-power mode.'}}}, 'status': {'name': 'Status', 'addressOffset': '0x4', 'desc': 'QSFP Low-Speed Status.', 'fields': {'mod_prs_n': {'name': 'mod_prs_n', 'desc': "When read as '0' this field indicates that the QSFP module is present. When read as '1' this field indicates that the QSFP module is not present.", 'bitOffset': 0, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro', 'tangoAttName': 'present'}, 'interrupt_n': {'name': 'interrupt_n', 'desc': "When read as '0' this field indicates that the module has a pending interrupt that can be serviced through the 2-wire serial interface.", 'bitOffset': 1, 'bitWidth': 1, 'ftype': 'boolean', 'access': 'ro', 'tangoAttName': 'interrupt'}}}}}}}}}}
