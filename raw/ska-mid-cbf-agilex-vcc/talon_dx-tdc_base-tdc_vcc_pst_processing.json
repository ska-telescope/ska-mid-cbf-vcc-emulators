{
    "drivers": {
        "circuit_switch": {
            "driver": "circuit_switch_driver",
            "register_sets": {
                "csr": {
                    "$ref": "#/DeTrI/TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|E_CIRCUIT_SWITCH|E_CSR"
                }
            }
        },
        "vcc_ch20": {
            "driver": "vcc_ch20_driver",
            "register_sets": {
                "csr": {
                    "$ref": "#/DeTrI/TOP|E_BASE|E_PERSONA|E_VCC|E_VCC_CH20|E_AVMM_BRIDGE"
                }
            }
        },
        "sys_id_base": {
            "driver": "sys_id_driver",
            "register_sets": {
                "csr": {
                    "$ref": "#/DeTrI/TOP|E_BASE|E_SYS_ID|E_CSR"
                }
            }
        },
        "eth1": {
            "driver": "ethernet_100g_driver",
            "register_sets": {
                "phy": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_PHY"
                },
                "rx_mac": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_MAC"
                },
                "rx_rsfec": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_RSFEC"
                },
                "rx_statistics": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_STAT"
                },
                "tx_mac": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_MAC"
                },
                "tx_rsfec": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_RSFEC"
                },
                "tx_statistics": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_STAT"
                },
                "qsfp": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[1]|E_100GBE|G_QSFP_CTRL|E_QSFP"
                }
            }
        },
        "eth0": {
            "driver": "ethernet_100g_driver",
            "register_sets": {
                "phy": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_PHY"
                },
                "rx_mac": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_MAC"
                },
                "rx_rsfec": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_RSFEC"
                },
                "rx_statistics": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_STAT"
                },
                "tx_mac": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_MAC"
                },
                "tx_rsfec": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_RSFEC"
                },
                "tx_statistics": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_STAT"
                },
                "qsfp": {
                    "$ref": "#/DeTrI/TOP|E_BASE|G_100GBE[0]|E_100GBE|G_QSFP_CTRL|E_QSFP"
                }
            }
        }
    },
    "RegisterSetDefinitions": {
        "slim.tx_slim_reg_pkg": {
            "name": "Transmit Serial Interconnect IP Block",
            "desc": "The register set used to monitor and control the IP block facilitating the high performance serial protocol. Based on the Serial Interconnect IP Design Specification dated 2017-01-23, prepared by William Kamp.",
            "mnemonic": "tx_slim",
            "version": "1.0.0",
            "author": "William Kamp",
            "email": "william.kamp@aut.ac.nz",
            "date": "2018-11-13",
            "referenceDocumentTitle": "Serial Interconnect IP Design Specificaition",
            "referenceDocument": "T1-DS-00201",
            "registers": {
                "control_and_status": {
                    "name": "Control and Status",
                    "desc": "Control and status register.",
                    "addressOffset": "0x0",
                    "width": 32,
                    "fields": {
                        "latch_counters": {
                            "name": "Latch Counters",
                            "desc": "Write '1' to Latch the counters at the end of the current packet, or immediately if not in a packet. Read '0'.",
                            "bitOffset": 31,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "scl"
                        },
                        "clear_counters": {
                            "name": "Clear Counters",
                            "desc": "Write '1' to Clear the counters at the end of the current packet, or immediately if not in a packet.",
                            "bitOffset": 30,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "scl"
                        },
                        "counter_width": {
                            "name": "Counter Width",
                            "desc": "The width of the counters in this instance. Units of bits. The counters will wrap back to zero when they exceed 2^<counter_width>-1. If zero, then there are no counters.",
                            "bitOffset": 24,
                            "bitWidth": 6,
                            "ftype": "natural",
                            "access": "ro"
                        },
                        "xcvr_rate": {
                            "name": "Transceiver Bit Rate",
                            "desc": "The approximate bit rate of the transceiver. This combined with the counter width can be used to determine the maximum polling period before the counters wrap. Units are 10e9 bits per second (Gbps). Zero means 'unknown'.",
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "access": "ro"
                        },
                        "phy_reset": {
                            "name": "Physical layer (transceiver) Reset",
                            "desc": "Write '1' to put the transmit PHY into reset. Write '0' to clear the reset.",
                            "ftype": "boolean",
                            "bitOffset": 5,
                            "bitWidth": 1,
                            "access": "rw"
                        },
                        "sup_user_idle": {
                            "name": "Support User Idle Word",
                            "desc": "True when the functionality of setting a user idle word is available. See the Idle Control Word register.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        }
                    }
                },
                "idle_control_word": {
                    "name": "Idle Control Word",
                    "addressOffset": "0x08",
                    "width": 64,
                    "fields": {
                        "idle_ctrl_word": {
                            "name": "Idle Control Word",
                            "desc": "Runtime configuration of the user portion of the idle control word that will be transmitted. The receiving end should be configured to match.",
                            "bitWidth": 56,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "rw"
                        }
                    }
                },
                "word_counter": {
                    "name": "Word Counter",
                    "addressOffset": "0x10",
                    "width": 64,
                    "fields": {
                        "word_count": {
                            "name": "Word Count",
                            "desc": "Count of the number of 64b/66b data words (excluding idle control words) that have been transmitted. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "packet_counter": {
                    "name": "Packet Counter",
                    "addressOffset": "0x18",
                    "width": 64,
                    "fields": {
                        "packet_count": {
                            "name": "Packet Count",
                            "desc": "Counter of the number of packets transmitted. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "idle_word_counter": {
                    "name": "Idle Word Counter",
                    "addressOffset": "0x20",
                    "width": 64,
                    "fields": {
                        "idle_word_count": {
                            "name": "Idle Word Count",
                            "desc": "Counter of the number of idle control words transmitted. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                }
            }
        },
        "slim.rx_slim_reg_pkg": {
            "name": "Receive Serial Interconnect IP Block",
            "desc": "The register set used to monitor and control the IP block facilitating the high performance serial protocol. Based on the Serial Interconnect IP Design Specification dated 2017-01-23, prepared by William Kamp.",
            "mnemonic": "rx_slim",
            "version": "1.0.0",
            "author": "William Kamp",
            "email": "william.kamp@aut.ac.nz",
            "date": "2018-11-13",
            "referenceDocumentTitle": "Serial Interconnect IP Design Specificaition",
            "referenceDocument": "T1-DS-00201",
            "registers": {
                "control_and_status": {
                    "name": "Control and Status",
                    "desc": "Control and status register.",
                    "addressOffset": "0x0",
                    "width": 32,
                    "fields": {
                        "latch_counters": {
                            "name": "Latch Counters",
                            "desc": "Write '1' to Latch the counters at the end of the current packet, or immediately if not in a packet. Read '0'.",
                            "bitOffset": 31,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "scl"
                        },
                        "clear_counters": {
                            "name": "Clear Counters",
                            "desc": "Write '1' to Clear the counters at the end of the current packet, or immediately if not in a packet.",
                            "bitOffset": 30,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "scl"
                        },
                        "counter_width": {
                            "name": "Counter Width",
                            "desc": "The actual bit width of the counters in this instance. The counters will wrap back to zero when they exceed 2^<counter_width>-1. If zero, then there are no counters.",
                            "bitOffset": 24,
                            "bitWidth": 6,
                            "ftype": "natural",
                            "access": "ro"
                        },
                        "xcvr_rate": {
                            "name": "Transceiver Bit Rate",
                            "desc": "The approximate bit rate of the transceiver. This combined with the counter width can be used to determine the maximum polling period before the counters wrap. Units are 10e9 bits per second (Gbps). Zero means 'unknown'.",
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "access": "ro"
                        },
                        "serial_loopback_enable": {
                            "name": "Serial Loopback Enable",
                            "desc": "Write '1' to enable the serial loopback feature of the transceiver - receiving data directly from the transmitter pin. Write '0' to disable and receive data from the receiver pin.",
                            "ftype": "boolean",
                            "bitOffset": 6,
                            "bitWidth": 1,
                            "reset": 1,
                            "access": "rw"
                        },
                        "phy_reset": {
                            "name": "Physical Layer (transceiver) Reset",
                            "desc": "Write '1' to put the transmit PHY into reset. Write '0' to clear the reset.",
                            "ftype": "boolean",
                            "bitOffset": 5,
                            "bitWidth": 1,
                            "access": "rw"
                        },
                        "sup_user_idle": {
                            "name": "Support User Idle Word",
                            "desc": "True when the functionality of setting a user idle word is available. See the Idle Control Word register.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "block_lost": {
                            "name": "66b Block Alignment Lost",
                            "desc": "64b/66b block alignment has transitioned from '1' to '0' at least once since last cleared. Read '0' = No transition, RX block alignment has not been lost. Read '1' = Transition occurred, RX block alignment has been discontinuous. Alignment was lost since last cleared. Write '1' to reset.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "block_aligned": {
                            "name": "66b Block Alignment",
                            "desc": "Current status of 64b/66b block alignment. Read '1' = Aligned. Read '0' = Unaligned.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "cdr_lost": {
                            "name": "Clock Data Recovery (CDR) Lock Lost",
                            "desc": "CDR lock has transitioned from '1' to '0' at least once since last cleared, indicating link has been unstable. Read '0' = No transition, CDR PLL has not lost lock. Read '1' = Transition occurred, CDR PLL has lost lock since last cleared. Write '1' to clear.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "cdr_locked": {
                            "name": "Clock Data Recovery (CDR) Locked",
                            "desc": "Current state of the CDR (clock data recovery) PLL (phase locked loop). Read '1' = CDR locked to data. Read '0' = CDR not locked to data.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        }
                    }
                },
                "idle_control_word": {
                    "name": "Idle Control Word",
                    "addressOffset": "0x08",
                    "width": 64,
                    "fields": {
                        "idle_ctrl_word": {
                            "name": "Idle Control Word",
                            "desc": "If user idle control words are supported (see `sup_user_idle`). Read this register to get the last idle control word that was be captured from the received data stream. Write this field to set the idle control word used for error comparison.",
                            "bitWidth": 56,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "rw"
                        }
                    }
                },
                "word_counter": {
                    "name": "Word Counter",
                    "addressOffset": "0x10",
                    "width": 64,
                    "fields": {
                        "word_count": {
                            "name": "Word Count",
                            "desc": "Count of the number of 64b/66b data words (excluding idle control words) that have been transmitted. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "packet_counter": {
                    "name": "Packet Counter",
                    "addressOffset": "0x18",
                    "width": 64,
                    "fields": {
                        "packet_count": {
                            "name": "Packet Count",
                            "desc": "Counter of the number of packets transmitted. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "idle_word_counter": {
                    "name": "Idle Word Counter",
                    "addressOffset": "0x20",
                    "width": 64,
                    "fields": {
                        "idle_count": {
                            "name": "Idle Word Count",
                            "desc": "Counter of the number of idle control words received (including ones in error). Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "idle_error_counter": {
                    "name": "Idle Error Counter",
                    "addressOffset": "0x28",
                    "width": 64,
                    "fields": {
                        "idle_error_count": {
                            "name": "Idle Error Count",
                            "desc": "Count of the number of idle control words received with an error. This and the Idle Word Counter can be used to estimate the bit-error-rate (BER) of the link. If all idle words are in error then possibly the Idle Control Word register of the transmitter does not match that of the receiver - or the links are not wired like you think they are. Actual bit width of this counter described by `counter_width`.",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_PHY_reg_pkg": {
            "name": "Physical Layer (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_PHY",
            "desc": [
                "Physical Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.1",
            "tangoClassName": "DsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "revid": {
                    "name": "REVID",
                    "addressOffset": "0x00",
                    "fields": {
                        "REVID": {
                            "name": "Revision ID",
                            "desc": "IP core PHY module revision ID = 0x08092017.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    },
                    "tangoTestValue": "0x08092017"
                },
                "scratch": {
                    "name": "SCRATCH",
                    "addressOffset": "0x04",
                    "tangoIgnore": true,
                    "fields": {
                        "scratch": {
                            "name": "SCRATCH",
                            "desc": "Scratch register available for testing.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "phy_name_0": {
                    "name": "PHY_NAME_0",
                    "addressOffset": "0x08",
                    "fields": {
                        "phy_name_0": {
                            "name": "PHY_NAME_0",
                            "desc": "First characters of IP core variation identifier string, '100' = 0x00313030.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "phyName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x00313030"
                },
                "phy_name_1": {
                    "name": "PHY_NAME_1",
                    "addressOffset": "0x0C",
                    "fields": {
                        "phy_name_1": {
                            "name": "PHY_NAME_1",
                            "desc": "Next characters of IP core variation identifier string, 'GE' = 0x00004745.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "phyName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x00004745"
                },
                "phy_name_2": {
                    "name": "PHY_NAME_2",
                    "addressOffset": "0x10",
                    "fields": {
                        "phy_name_2": {
                            "name": "PHY_NAME_2",
                            "desc": "Final characters of IP core variation identifier string, 'pcs' = 0x00706373.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "phyName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x00706373"
                },
                "phy_config": {
                    "name": "PHY_CONFIG",
                    "addressOffset": "0x40",
                    "desc": "PHY configuration registers.",
                    "fields": {
                        "eio_sys_rst": {
                            "name": "EIO_SYS_RST",
                            "desc": "Full system reset (except registers). Set this bit to initiate the internal reset sequence.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SystemReset",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate reset. Write 0 to clear reset bit."
                        },
                        "soft_txp_rst": {
                            "name": "SOFT_TXP_RST",
                            "desc": "TX soft reset.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SoftTxpReset",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate reset. Write 0 to clear reset bit."
                        },
                        "soft_rxp_rst": {
                            "name": "SOFT_RXP_RST",
                            "desc": "RX soft reset.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SoftRxpReset",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate reset. Write 0 to clear reset bit."
                        },
                        "set_ref_lock": {
                            "name": "SET_REF_LOCK",
                            "desc": "Directs the RX CDR PLL to lock to the reference clock.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SetRefLock",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate lock. Write 0 to clear lock bit."
                        },
                        "set_data_lock": {
                            "name": "SET_DATA_LOCK",
                            "desc": "Directs the RX CDR PLL to lock to data.",
                            "bitOffset": 5,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SetDataLock",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate lock. Write 0 to clear lock bit."
                        }
                    }
                },
                "word_lock": {
                    "name": "WORD_LOCK",
                    "addressOffset": "0x48",
                    "fields": {
                        "word_lock": {
                            "name": "WORD_LOCK",
                            "desc": "Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual channel has identified 66 bit block boundaries in the serial data stream. If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 0,
                            "bitWidth": 20,
                            "access": "ro"
                        }
                    }
                },
                "eio_sloop": {
                    "name": "EIO_SLOOP",
                    "addressOffset": "0x4C",
                    "fields": {
                        "eio_sloop": {
                            "name": "EIO_SLOOP",
                            "desc": "Serial PMA Loopback. Setting a bit puts the corresponding transceiver in serial loopback mode. In serial loopback mode, the TX lane loops back to the RX lane on an internal loopback path.",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "eio_flag_sel": {
                    "name": "EIO_FLAG_SEL",
                    "addressOffset": "0x50",
                    "fields": {
                        "eio_flag_sel": {
                            "name": "EIO_FLAG_SEL",
                            "desc": [
                                "FIFO flag select. Supports indirect addressing of individual FIFO flags in the 10G PCS Native PHY IP core. Program this register with the encoding for a specific FIFO flag. The flag values (one per transceiver) are then accessible in the EIO_FLAGS register. The value in the EIO_FLAG_SEL register directs the IP core to make available the following FIFO flag:",
                                "* 3'b000: TX FIFO full",
                                "* 3'b001: TX FIFO empty",
                                "* 3'b010: TX FIFO partially full",
                                "* 3'b011: TX FIFO partially empty",
                                "* 3'b100: RX FIFO full",
                                "* 3'b101: RX FIFO empty",
                                "* 3'b110: RX FIFO partially full",
                                "* 3'b111: RX FIFO partially empty"
                            ],
                            "bitOffset": 0,
                            "bitWidth": 3,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "eio_flags": {
                    "name": "EIO_FLAGS",
                    "addressOffset": "0x54",
                    "fields": {
                        "eio_flags": {
                            "name": "EIO_FLAGS",
                            "desc": "PCS indirect data. To read a FIFO flag, set the value in the EIO_FLAG_SEL register to indicate the flag you want to read. After you specify the flag in the EIO_FLAG_SEL",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "eio_freq_lock": {
                    "name": "EIO_FREQ_LOCK",
                    "addressOffset": "0x84",
                    "fields": {
                        "eio_freq_lock": {
                            "name": "EIO_FREQ_LOCK",
                            "desc": "Each of the lower order four bits, when asserted, indicates that the corresponding lane RX clock data recovery (CDR)  phaselocked loop (PLL) is locked.",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "phy_clk": {
                    "name": "PHY_CLK",
                    "addressOffset": "0x88",
                    "fields": {
                        "tx_reset_done": {
                            "name": "TX_RESET_DONE",
                            "desc": "If set to 1, indicates the TX transceivers have completed reset.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "tx_core_clock_stable": {
                            "name": "TX_CORE_CLOCK_STABLE",
                            "desc": "If set to 1, indicates the TX core clock is stable. And if the Enable RS-FEC is turned on, the FEC TX PLL has acquired frequency lock.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "rx_core_clock_stable": {
                            "name": "RX_CORE_CLOCK_STABLE",
                            "desc": "If set to 1, indicates the RX core clock is stable. And if the Enable RS-FEC is turned on, the FEC RX PLL has acquired frequency lock.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        }
                    }
                },
                "frm_err": {
                    "name": "FRM_ERR",
                    "addressOffset": "0x8C",
                    "fields": {
                        "frm_err": {
                            "name": "FRM_ERR",
                            "desc": "Each of the 20 lower order bits, when asserted, indicates that the corresponding virtual lane has a frame error. You can read this register to determine if the IP core sustains a low number of frame errors, below the threshold to lose word lock. These bits are sticky, unless the virtual lane loses word lock. Write 1'b1 to the SCLR_FRM_ERR register to clear. If a virtual lane loses word lock, it clears the corresponding register bit. Each bit in this register has a valid value only if the corresponding bit in the WORD_LOCK register at offset 0x312 has the value of 1.  If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 0,
                            "bitWidth": 20,
                            "access": "ro"
                        }
                    }
                },
                "sclr_frm_err": {
                    "name": "SCLR_FRM_ERR",
                    "addressOffset": "0x90",
                    "fields": {
                        "sclr_frm_err": {
                            "name": "SCLR_FRM_ERR",
                            "desc": "Synchronous clear for FRM_ERR register. Write 1'b1 to this register to clear the FRM_ERR register and bit [1] of the LANE_DESKEWED register. A single bit clears all sticky framing errors. This bit does not auto-clear. Write a 1'b0 to continue logging frame errors. If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "SyncClearFrameError",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to clear FRM_ERR register. Write 0 to continue logging frame errors."
                        }
                    }
                },
                "EIO_RX_SOFT_PURGE_S": {
                    "name": "EIO_RX_SOFT_PURGE_S",
                    "addressOffset": "0x94",
                    "fields": {
                        "clear_rx_fifo": {
                            "name": "clear RX FIFO",
                            "desc": "Set to clear the RX FIFO for all four physical lanes.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "rw",
                            "ftype": "boolean"
                        },
                        "disable_bitslip": {
                            "name": "Disable bitslip request",
                            "desc": "If set to 1, disables the bitslip request from PCS to PMA.",
                            "bitOffset": 11,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "rw",
                            "ftype": "boolean"
                        },
                        "disable_autoadaption": {
                            "name": "Disable Autoadaption",
                            "desc": "If set to 1, holds auto adaptation module in Idle state. If set to 0, releases auto adaptation module from the Idle state.",
                            "bitOffset": 12,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "rw",
                            "ftype": "boolean"
                        }
                    }
                },
                "RX_PCS_FULLY_ALIGNED_S": {
                    "name": "RX_PCS_FULLY_ALIGNED_S",
                    "addressOffset": "0x98",
                    "fields": {
                        "rx_pcs_fully_aligned": {
                            "name": "RX PCS fully aligned status",
                            "desc": "RX PCS is fully aligned, If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "ro",
                            "ftype": "boolean"
                        },
                        "RX_PCS_HI_BER": {
                            "name": "RX PCS High Bit Error Rate",
                            "desc": "RX PCS in a high BER state, If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "ro",
                            "ftype": "boolean"
                        }
                    }
                },
                "err_inj": {
                    "name": "ERR_INJ",
                    "addressOffset": "0x9C",
                    "fields": {
                        "err_inj": {
                            "name": "Error Inject to lane",
                            "desc": "When set to 1, injects an error in the corresponding lane. The register is rising-edge triggered. Write a 0 to clear.",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "am_lock": {
                    "name": "Alignment Marker Lock",
                    "addressOffset": "0xA0",
                    "fields": {
                        "am_lock": {
                            "name": "Alignment Marker Lock",
                            "desc": [
                                "When bit [0] is asserted, indicates that the IP core has identified virtual lane alignment markers in the data stream of all 20 virtual lanes, and has ordered the virtual lanes.",
                                "If Enable RS-FEC is turned on, the value is always zero."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 0,
                            "access": "rw",
                            "ftype": "boolean"
                        }
                    }
                },
                "lane_deskewed": {
                    "name": "LANE_DESKEWED",
                    "addressOffset": "0xA4",
                    "fields": {
                        "all_lanes_deskewed": {
                            "name": "ALL_LANES_DESKEWED",
                            "desc": "Indicates all lanes are deskewed.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "deskew_change": {
                            "name": "DESKEW_CHANGE",
                            "desc": "When asserted indicates a change in lanes deskewed status. To clear this sticky bit, write 1'b1 to the corresponding bit of the SCLR_FRM_ERR register. This is a latched signal. If Enable RS-FEC is turned on, the value is always zero.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        }
                    }
                },
                "pcs_vlane_0_to_4": {
                    "name": "PCS_VLANE_0_to_4",
                    "addressOffset": "0xC0",
                    "fields": {
                        "vlane_a": {
                            "name": "VLANE_A",
                            "desc": "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.",
                            "bitOffset": 0,
                            "bitWidth": 5,
                            "repeat": 5,
                            "skip": 5,
                            "access": "ro",
                            "tangoParentName": true,
                            "tangoImageX": 5,
                            "tangoImageY": 1
                        }
                    }
                },
                "pcs_vlane_5_to_9": {
                    "name": "PCS_VLANE_5_to_9",
                    "addressOffset": "0xC4",
                    "fields": {
                        "vlane_b": {
                            "name": "VLANE_B",
                            "desc": "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.",
                            "bitOffset": 0,
                            "bitWidth": 5,
                            "repeat": 5,
                            "skip": 5,
                            "access": "ro",
                            "tangoParentName": true,
                            "tangoImageX": 5,
                            "tangoImageY": 1
                        }
                    }
                },
                "pcs_vlane_10_to_14": {
                    "name": "PCS_VLANE_10_to_14",
                    "addressOffset": "0xC8",
                    "fields": {
                        "vlane_c": {
                            "name": "VLANE_C",
                            "desc": "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.",
                            "bitOffset": 0,
                            "bitWidth": 5,
                            "repeat": 5,
                            "skip": 5,
                            "access": "ro",
                            "tangoParentName": true,
                            "tangoImageX": 5,
                            "tangoImageY": 1
                        }
                    }
                },
                "pcs_vlane_15_to_19": {
                    "name": "PCS_VLANE_15_to_19",
                    "addressOffset": "0xCC",
                    "fields": {
                        "vlane_d": {
                            "name": "VLANE_D",
                            "desc": "PCS virtual lane mapping. Identifies the five virtual lanes detected on a physical lane. Virtual lanes are encoded with the five-bit binary virtual lane number. One virtual lane index is encoded in register bits [4:0], another in register bits [9:5], another in register bits [14:10], another in register bits [19:15], and another in register bits [24:20]. For example, if the value of the register is 25'b00001_00101_00011_00000_01000, virtual lanes 0, 1, 3, 5, and 8 map to physical lane 0. The value 0x1F in any of these fields indicates no virtual lane is recorded yet. Before the IP core asserts rx_pcs_ready, transitional values can appear in the register fields. Therefore, you should read the register three to four times to ensure you read the correct virtual lane indicators. If Enable  RS-FEC is turned on, the value remains at the reset value.",
                            "bitOffset": 0,
                            "bitWidth": 5,
                            "repeat": 5,
                            "skip": 5,
                            "access": "ro",
                            "tangoParentName": true,
                            "tangoImageX": 5,
                            "tangoImageY": 1
                        }
                    }
                },
                "khz_ref": {
                    "name": "KHZ_REF",
                    "addressOffset": "0x100",
                    "fields": {
                        "khz_ref": {
                            "name": "KHZ_REF - Deprecated",
                            "desc": "Deprecated.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "khz_rx": {
                    "name": "KHZ_RX",
                    "addressOffset": "0x104",
                    "fields": {
                        "khz_rx": {
                            "name": "KHZ_RX",
                            "desc": "RX clock (clk_rxmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "khz_tx": {
                    "name": "KHZ_TX",
                    "addressOffset": "0x108",
                    "fields": {
                        "khz_tx": {
                            "name": "KHZ_TX",
                            "desc": "TX clock (clk_txmac) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "khz_tx_rs": {
                    "name": "KHZ_TX_RS",
                    "addressOffset": "0x10C",
                    "fields": {
                        "khz_tx_rs": {
                            "name": "KHZ_TX_RS",
                            "desc": "TX clock (clk_tx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The TX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "khz_rx_rs": {
                    "name": "KHZ_RX_RS",
                    "addressOffset": "0x110",
                    "fields": {
                        "khz_rx_rs": {
                            "name": "KHZ_RX_RS",
                            "desc": "RX clock (clk_rx_rs) frequency in KHz, assuming the clk_status clock has the frequency of 100 MHz. The RX FEC clock frequency is the value in this register times the frequency of the clk_status clock, divided by 100. This register is available only if Enable RSFEC is turned on.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "enable_rsfec": {
                    "name": "ENABLE_RSFEC",
                    "addressOffset": "0x140",
                    "fields": {
                        "enable_rsfec": {
                            "name": "ENABLE_RSFEC",
                            "desc": "Allows you to dynamically control the RS-FEC block which is part of the data path. This register is available only if the Enable RSFEC  is turned on. When the RS-FEC block is enabled, writing 1 enables the RS-FEC data path and writing 0 disables the RS-FEC data path. Note: In a configuration where the RS-FEC + KR feature is enabled, this register has no effect because the data path always includes the RS-FEC by default.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "EnableRsFec",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to enable RS-FEC datapath. Write 0 to disable RS-FEC datapath."
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_rx_MAC_reg_pkg": {
            "name": "Receive Media Access Control (RX-MAC) Layer (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_rx_MAC",
            "desc": [
                "Receive MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.0",
            "tangoClassName": "dsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "rxmac_revid": {
                    "name": "RXMAC_REVID",
                    "addressOffset": "0x00",
                    "fields": {
                        "rxmac_revid": {
                            "name": "RXMAC_REVID",
                            "desc": "RX MAC revision ID. 0x0809 2017",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoAttName": "rxMacRevid"
                        }
                    },
                    "tangoTestValue": "0x08092017"
                },
                "rxmac_scratch": {
                    "name": "RXMAC_SCRATCH",
                    "addressOffset": "0x04",
                    "tangoIgnore": true,
                    "fields": {
                        "rxmac_scratch": {
                            "name": "RXMAC_SCRATCH",
                            "desc": "Scratch register available for testing.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "rxmac_name_0": {
                    "name": "RXMAC_NAME_0",
                    "addressOffset": "0x08",
                    "fields": {
                        "rxmac_name_0": {
                            "name": "RXMAC_NAME_0",
                            "desc": "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x31303067"
                },
                "rxmac_name_1": {
                    "name": "RXMAC_NAME_1",
                    "addressOffset": "0x0C",
                    "fields": {
                        "rxmac_name_1": {
                            "name": "RXMAC_NAME_1",
                            "desc": "Next 4 characters of IP core variation identifier string, 'MACR' = 0x4D414352.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x4d414352"
                },
                "rxmac_name_2": {
                    "name": "RXMAC_NAME_2",
                    "addressOffset": "0x10",
                    "fields": {
                        "rxmac_name_2": {
                            "name": "RXMAC_NAME_2",
                            "desc": "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x78435352"
                },
                "rxmac_size_config": {
                    "name": "RXMAC_SIZE_CONFIG",
                    "addressOffset": "0x18",
                    "fields": {
                        "rxmac_size_config": {
                            "name": "RXMAC_SIZE_CONFIG",
                            "desc": "Specifies the maximum frame length available. The MAC asserts l8_rx_error[3] when the length of the received frame exceeds the value of this register. If the IP core receives an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_RX_OVERSIZE counter. The minimum value of this register is 64 (decimal).",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "access": "rw",
                            "reset": "0x2580"
                        }
                    }
                },
                "mac_crc_config": {
                    "name": "MAC_CRC_CONFIG",
                    "addressOffset": "0x1C",
                    "fields": {
                        "mac_crc_config": {
                            "name": "MAC_CRC_CONFIG",
                            "desc": "he RX CRC forwarding configuration register. The following encodings are defined: 1'b0 : Remove RX CRC, do not forward it to the RX client interface 1'b1 : Retain RX CRC, forward it to the RX client interface In either case, the IP core checks the incoming RX CRC and flags errors.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "rx_link_fault": {
                    "name": "RX_LINK_FAULT",
                    "addressOffset": "0x20",
                    "fields": {
                        "link_fault": {
                            "name": "LINK_FAULT",
                            "desc": "Link Fault Status Register. For unidirectional Link Fault, implements IEEE 802.3 Ethernet Clause 66.",
                            "bitOffset": 0,
                            "bitWidth": 2,
                            "access": "ro"
                        }
                    }
                },
                "rxmac_control": {
                    "name": "RXMAC_CONTROL",
                    "addressOffset": "0x28",
                    "fields": {
                        "preamble_check": {
                            "name": "PREAMBLE_CHECK",
                            "desc": "Preamble check. Strict SFD checking option to compare each packet preamble to 0x555555555555. This field is available only if you turn on Enable Strict SFD check.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 1,
                            "access": "rw",
                            "tangoCommand": "RxMacCtrlPreambleCheck",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to enable checking. Write 0 to clear."
                        },
                        "sfd_check": {
                            "name": "SFD_CHECK",
                            "desc": "SFD check. Strict SFD checking option to compare each SFD byte to 0x5D. This field is available only if you turn on Enable Strict SFD check.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 1,
                            "access": "rw",
                            "tangoCommand": "RxMacCtrlSfdCheck",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to initiate check. Write 0 to clear."
                        },
                        "rx_vlan_detect_disable": {
                            "name": "RX_VLAN_DETECT_DISABLE",
                            "desc": "VLAN detection disabled. This bit is deasserted by default implying VLAN detection is enabled.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoCommand": "RxMacCtrlVlanDetectDisable",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to disable vlan detection. Write 0 to clear."
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_rx_RSFEC_reg_pkg": {
            "name": "Receive Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_rx_RSFEC",
            "desc": [
                "Receive RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.0",
            "tangoClassName": "DsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "rx_rsfec_revid": {
                    "name": "RX_RSFEC_REVID",
                    "addressOffset": "0x00",
                    "fields": {
                        "rx_rsfec_revid": {
                            "name": "RX_RSFEC_REVID",
                            "desc": "Reed-Solomon FEC RX module revision ID = 0x08092017.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    },
                    "tangoTestValue": "0x08092017"
                },
                "rx_rsfec_scratch": {
                    "name": "RX_RSFEC_SCRATCH",
                    "addressOffset": "0x04",
                    "tangoIgnore": true,
                    "fields": {
                        "rx_rsfec_scratch": {
                            "name": "RX_RSFEC_SCRATCH",
                            "desc": "Scratch register available for testing.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw"
                        }
                    }
                },
                "rx_rsfec_name_0": {
                    "name": "RX_RSFEC_NAME_0",
                    "addressOffset": "0x08",
                    "fields": {
                        "rx_rsfec_name_0": {
                            "name": "RX_RSFEC_NAME_0",
                            "desc": "Final 4 characters of IP core variation identifier string, '100gRSFECoRX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x67303031"
                },
                "rx_rsfec_name_1": {
                    "name": "RX_RSFEC_NAME_1",
                    "addressOffset": "0x0C",
                    "fields": {
                        "rx_rsfec_name_1": {
                            "name": "RX_RSFEC_NAME_1",
                            "desc": "Middle 4 characters of IP core variation identifier string, '100gRSFECoRX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x45465352"
                },
                "rx_rsfec_name_2": {
                    "name": "RX_RSFEC_NAME_2",
                    "addressOffset": "0x10",
                    "fields": {
                        "rx_rsfec_name_2": {
                            "name": "RX_RSFEC_NAME_2",
                            "desc": "Initial 4 characters of IP core variation identifier string, '100gRSFECoRX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "rxRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x58526f43"
                },
                "bypass_restart": {
                    "name": "BYPASS_RESTART",
                    "addressOffset": "0x14",
                    "fields": {
                        "restart": {
                            "name": "RESTART",
                            "desc": "Restart state machines. When 1'b1, specifies the IP core restarts the FEC synchronization and alignment state machines. Bit self-clears after alignment marker synchronization is restarted. (Refer to Figure 91-8 and Figure 91-9 in IEEE Standard 802.3bj-2014).",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0
                        },
                        "bypass": {
                            "name": "BYPASS",
                            "desc": "Bypass RS-FEC decoder. When 1'b1, specifies the IP core bypasses the RSFEC decoder. When 1'b0, enables RSFEC error correction.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "rx_fec_status": {
                    "name": "RX_FEC_STATUS",
                    "addressOffset": "0x18",
                    "fields": {
                        "fec_lane": {
                            "name": "FEC_LANE",
                            "desc": "Two bits per lane hold the FEC lane number when the corresponding amps_lock bit (in register bits [3:0]) has the value of 1.",
                            "bitOffset": 8,
                            "bitWidth": 2,
                            "access": "ro",
                            "repeat": 4,
                            "skip": 2
                        },
                        "fec_align_status": {
                            "name": "FEC_ALIGN_STATUS",
                            "desc": "Alignment marker lock status. When 1'b1, indicates all lanes are synchronized and aligned. When 1'b0, indicates the deskew process is not yet complete. (Refer to Figure 91-9 in IEEE Standard 802.3bj-2014).",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro"
                        },
                        "amps_lock": {
                            "name": "AMPS_LOCK",
                            "desc": "Each bit indicates that the receiver has detected the location of the alignment marker payload sequence for the corresponding FEC lane. (Refer to Figure 91-8 in IEEE Standard 802.3bj-2014).",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "access": "ro"
                        }
                    }
                },
                "corrected_cw": {
                    "name": "CORRECTED_CW",
                    "addressOffset": "0x1C",
                    "fields": {
                        "corrected_cw": {
                            "name": "CORRECTED_CW",
                            "desc": "32-bit counter that contains the number of corrected FEC codewords processed. The value resets to zero upon read and holds at max count.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                },
                "uncorrected_cw": {
                    "name": "UNCORRECTED_CW",
                    "addressOffset": "0x20",
                    "fields": {
                        "uncorrected_cw": {
                            "name": "UNCORRECTED_CW",
                            "desc": "32-bit counter that contains the number of uncorrected FEC codewords processed. The value resets to zero upon read and holds at max count. This register gets updated based on the error correction logic even when BYPASS_RESTART bit [0] is 1.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_rx_statistics_reg_pkg": {
            "name": "Receive Statistics (Intel Stratix10 100GbE MAC)",
            "desc": [
                "Receive Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "mnemonic": "Ethernet_100G_rx_statistics",
            "version": "19.2.0",
            "tangoClassName": "DsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "cntr_rx_fragments": {
                    "name": "CNTR_RX_FRAGMENTS",
                    "addressOffset": "0x00",
                    "width": 64,
                    "fields": {
                        "cntr_rx_fragments": {
                            "name": "CNTR_RX_FRAGMENTS",
                            "desc": "Number of received frames less than 64 bytes and reporting a CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_jabbers": {
                    "name": "CNTR_RX_JABBERS",
                    "addressOffset": "0x08",
                    "width": 64,
                    "fields": {
                        "cntr_rx_jabbers": {
                            "name": "CNTR_RX_JABBERS",
                            "desc": "Number of received oversized frames reporting a CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_fcs": {
                    "name": "CNTR_RX_FCS",
                    "addressOffset": "0x10",
                    "width": 64,
                    "fields": {
                        "cntr_rx_fcs": {
                            "name": "CNTR_RX_FCS",
                            "desc": "Number of received packets with FCS errors. This register maintains a count of the number of pulses on the l<n>_rx_fcs_error or rx_fcs_error output signal",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_crcerr": {
                    "name": "CNTR_RX_CRCERR",
                    "addressOffset": "0x18",
                    "width": 64,
                    "fields": {
                        "cntr_rx_crcerr": {
                            "name": "CNTR_RX_CRCERR",
                            "desc": "Number of received frames with a frame of length at least 64, with CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_mcast_data_err": {
                    "name": "CNTR_RX_MCAST_DATA_ERR",
                    "addressOffset": "0x20",
                    "width": 64,
                    "fields": {
                        "cntr_rx_mcast_data_err": {
                            "name": "CNTR_RX_MCAST_DATA_ERR",
                            "desc": "Number of errored multicast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxMcastDataErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_bcast_data_err": {
                    "name": "CNTR_RX_BCAST_DATA_ERR",
                    "addressOffset": "0x28",
                    "width": 64,
                    "fields": {
                        "cntr_rx_bcast_data_err": {
                            "name": "CNTR_RX_BCAST_DATA_ERR",
                            "desc": "Number of errored broadcast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxBcastDataErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_ucast_data_err": {
                    "name": "CNTR_RX_UCAST_DATA_ERR",
                    "addressOffset": "0x30",
                    "width": 64,
                    "fields": {
                        "cntr_rx_ucast_data_err": {
                            "name": "CNTR_RX_UCAST_DATA_ERR",
                            "desc": "Number of errored unicast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxUcastDataErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_mcast_ctrl_err": {
                    "name": "CNTR_RX_MCAST_CTRL_ERR",
                    "addressOffset": "0x38",
                    "width": 64,
                    "fields": {
                        "cntr_rx_mcast_ctrl_err": {
                            "name": "CNTR_RX_MCAST_CTRL_ERR",
                            "desc": "Number of errored multicast control frames received",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxMcastCtrlErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_bcast_ctrl_err": {
                    "name": "CNTR_RX_BCAST_CTRL_ERR",
                    "addressOffset": "0x40",
                    "width": 64,
                    "fields": {
                        "cntr_rx_bcast_ctrl_err": {
                            "name": "CNTR_RX_BCAST_CTRL_ERR",
                            "desc": "Number of errored broadcast control frames received",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxBcastCtrlErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_ucast_ctrl_err": {
                    "name": "CNTR_RX_UCAST_CTRL_ERR",
                    "addressOffset": "0x48",
                    "width": 64,
                    "fields": {
                        "cntr_rx_ucast_ctrl_err": {
                            "name": "CNTR_RX_UCAST_CTRL_ERR",
                            "desc": "Number of errored unicast control frames received",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxUcastCtrlErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_pause_err": {
                    "name": "CNTR_RX_PAUSE_ERR",
                    "addressOffset": "0x50",
                    "width": 64,
                    "fields": {
                        "cntr_rx_pause_err": {
                            "name": "CNTR_RX_PAUSE_ERR",
                            "desc": "Number of errored pause frames received",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxPauseErr",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_64b": {
                    "name": "CNTR_RX_64B",
                    "addressOffset": "0x58",
                    "width": 64,
                    "fields": {
                        "cntr_rx_64b": {
                            "name": "CNTR_RX_64B",
                            "desc": "Number of 64-byte received frames, including the CRC field but excluding the preamble and SFD bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx64B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_65to127b": {
                    "name": "CNTR_RX_65to127B",
                    "addressOffset": "0x60",
                    "width": 64,
                    "fields": {
                        "cntr_rx_65to127b": {
                            "name": "CNTR_RX_65to127B",
                            "desc": "Number of received frames between 65-127 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx65to127B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_128to255b": {
                    "name": "CNTR_RX_128to255B",
                    "addressOffset": "0x68",
                    "width": 64,
                    "fields": {
                        "cntr_rx_128to255b": {
                            "name": "CNTR_RX_128to255B",
                            "desc": "Number of received frames between 128-255 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx128to255B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_256to511b": {
                    "name": "CNTR_RX_256to511B",
                    "addressOffset": "0x70",
                    "width": 64,
                    "fields": {
                        "cntr_rx_256to511b": {
                            "name": "CNTR_RX_256to511B",
                            "desc": "Number of received frames between 256-511 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx256to511B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_512to1023b": {
                    "name": "CNTR_RX_512to1023B",
                    "addressOffset": "0x78",
                    "width": 64,
                    "fields": {
                        "cntr_rx_512to1023b": {
                            "name": "CNTR_RX_512to1023B",
                            "desc": "Number of received frames between 512-1023 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx512to1023B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_1024to1518b": {
                    "name": "CNTR_RX_1024to1518B",
                    "addressOffset": "0x80",
                    "width": 64,
                    "fields": {
                        "cntr_rx_1024to1518b": {
                            "name": "CNTR_RX_1024to1518B",
                            "desc": "Number of received frames between 1024-1518 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx1024to1518B",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_1519tomaxb": {
                    "name": "CNTR_RX_1519toMAXB",
                    "addressOffset": "0x88",
                    "width": 64,
                    "fields": {
                        "cntr_rx_1519tomaxb": {
                            "name": "CNTR_RX_1519toMAXB",
                            "desc": "Number of received frames between 1519 bytes and the maximum size defined in the RXMAC_SIZE_CONFIG register",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRx1519toMaxB",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_oversize": {
                    "name": "CNTR_RX_OVERSIZE",
                    "addressOffset": "0x90",
                    "width": 64,
                    "fields": {
                        "cntr_rx_oversize": {
                            "name": "CNTR_RX_OVERSIZE",
                            "desc": "Number of oversized frames (frames with more bytes than the number specified in the RXMAC_SIZE_CONFIG register) received",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxOversize",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_mcast_data_ok": {
                    "name": "CNTR_RX_MCAST_DATA_OK",
                    "addressOffset": "0x98",
                    "width": 64,
                    "fields": {
                        "cntr_rx_mcast_data_ok": {
                            "name": "CNTR_RX_MCAST_DATA_OK",
                            "desc": "Number of valid multicast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxMcastDataOk",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_bcast_data_ok": {
                    "name": "CNTR_RX_BCAST_DATA_OK",
                    "addressOffset": "0xA0",
                    "width": 64,
                    "fields": {
                        "cntr_rx_bcast_data_ok": {
                            "name": "CNTR_RX_BCAST_DATA_OK",
                            "desc": "Number of valid broadcast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxBcastDataOk",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_ucast_data_ok": {
                    "name": "CNTR_RX_UCAST_DATA_OK",
                    "addressOffset": "0xA8",
                    "width": 64,
                    "fields": {
                        "cntr_rx_ucast_data_ok": {
                            "name": "CNTR_RX_UCAST_DATA_OK",
                            "desc": "Number of valid unicast frames received, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxUcastDataOk",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_mcast_ctrl": {
                    "name": "CNTR_RX_MCAST_CTRL",
                    "addressOffset": "0xB0",
                    "width": 64,
                    "fields": {
                        "cntr_rx_mcast_ctrl": {
                            "name": "CNTR_RX_MCAST_CTRL",
                            "desc": "Number of valid multicast frames received, excluding data frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxMcastCtrl",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_bcast_ctrl": {
                    "name": "CNTR_RX_BCAST_CTRL",
                    "addressOffset": "0xB8",
                    "width": 64,
                    "fields": {
                        "cntr_rx_bcast_ctrl": {
                            "name": "CNTR_RX_BCAST_CTRL",
                            "desc": "Number of valid broadcast frames received, excluding data frames(lower 32 bits)",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxBcastCtrl",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_ucast_ctrl": {
                    "name": "CNTR_RX_UCAST_CTRL",
                    "addressOffset": "0xC0",
                    "width": 64,
                    "fields": {
                        "cntr_rx_ucast_ctrl": {
                            "name": "CNTR_RX_UCAST_CTRL",
                            "desc": "Number of valid unicast frames received, excluding data frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxUcastCtrl",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_pause": {
                    "name": "CNTR_RX_PAUSE",
                    "addressOffset": "0xC8",
                    "width": 64,
                    "fields": {
                        "cntr_rx_pause": {
                            "name": "CNTR_RX_PAUSE",
                            "desc": "Number of received pause frames, with or without error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxPause",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_runt": {
                    "name": "CNTR_RX_RUNT",
                    "addressOffset": "0xD0",
                    "width": 64,
                    "fields": {
                        "cntr_rx_runt": {
                            "name": "CNTR_RX_RUNT",
                            "desc": "Number of received runt packets A run is a packet of size less than 64 bytes but greater than eight bytes. If a packet is eight bytes or smaller, it is considered a decoding error and not a runt frame, and the IP core does not flag it nor count it as a runt.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "cntrRxRunt",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_rx_config": {
                    "name": "CNTR_RX_CONFIG",
                    "addressOffset": "0x114",
                    "fields": {
                        "rx_shadow_req": {
                            "name": "RX_SHADOW_REQ",
                            "desc": "Shadow request (active high): When set to the value of 1, RX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "RxCntrConfigShadowRequest",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to pause Rx statistics. Write 0 to clear."
                        },
                        "rx_parity_err_clr": {
                            "name": "RX_PARITY_ERR_CLR",
                            "desc": "Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_RX_STATUS[0]. This bit (CNTR_RX_CONFIG[1]) is self-clearing.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "RxCntrConfigParityErrorClear",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to clear the parity bit."
                        },
                        "rx_cnt_clr": {
                            "name": "RX_CNT_CLR",
                            "desc": "Software can set this bit to the value of 1 to reset all of the Rx statistics registers at the same time. This bit is self-clearing.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "RxCntrConfigCounterClear",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to clear all Rx Statistics registers."
                        }
                    }
                },
                "cntr_rx_status": {
                    "name": "CNTR_RX_STATUS",
                    "addressOffset": "0x118",
                    "fields": {
                        "rx_cnt_pause": {
                            "name": "RX_CNT_PAUSE",
                            "desc": "Indicates that the RX statistics registers are paused (while CNTR_RX_CONFIG[2] is asserted).",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "rx_parity_err": {
                            "name": "RX_PARITY_ERR",
                            "desc": "Indicates the presence of at least one parity error in the RX statistics counters.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        }
                    }
                },
                "rxpayloadoctetsok": {
                    "name": "RxPayloadOctetsOK",
                    "addressOffset": "0x180",
                    "width": 64,
                    "fields": {
                        "rxpayloadoctetsok": {
                            "name": "RxPayloadOctetsOK",
                            "desc": "Number of received payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the RX MAC (bit [1] of the RXMAC_CONTROL register at offset 0x50A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsReceivedOK in section 5.2.2.1.14 of the IEEE Standard 802.3-2008.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "RxPayloadOctetsOK",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "rxframeoctetsok": {
                    "name": "RxFrameOctetsOK",
                    "addressOffset": "0x188",
                    "width": 64,
                    "fields": {
                        "rxframeoctetsok": {
                            "name": "RxFrameOctetsOK",
                            "desc": "Number of received bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifInOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and RX etherStatsOctets in RFC2819 (Remote Network Monitoring Management Information Base (RMON)).",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoCombine": "RxFrameOctetsOK",
                            "tangoDataType": "DevULong64"
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_tx_MAC_reg_pkg": {
            "name": "Transmit Media Access Control (TX-MAC) Layer (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_tx_MAC",
            "desc": [
                "Transmit MAC Layer Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.0",
            "tangoClassName": "dsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "txmac_revid": {
                    "name": "TXMAC_REVID",
                    "addressOffset": "0x00",
                    "fields": {
                        "txmac_revid": {
                            "name": "TXMAC_REVID",
                            "desc": "TX MAC revision ID. 0x0809 2017",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    },
                    "tangoTestValue": "0x08092017"
                },
                "txmac_scratch": {
                    "name": "TXMAC_SCRATCH",
                    "addressOffset": "0x04",
                    "tangoIgnore": true,
                    "fields": {
                        "txmac_scratch": {
                            "name": "TXMAC_SCRATCH",
                            "desc": "Scratch register available for testing.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "txmac_name_0": {
                    "name": "TXMAC_NAME_0",
                    "addressOffset": "0x08",
                    "fields": {
                        "txmac_name_0": {
                            "name": "TXMAC_NAME_0",
                            "desc": "First 4 characters of IP core variation identifier string, '100g' = 0x31303067.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x31303067"
                },
                "txmac_name_1": {
                    "name": "TXMAC_NAME_1",
                    "addressOffset": "0x0C",
                    "fields": {
                        "txmac_name_1": {
                            "name": "TXMAC_NAME_1",
                            "desc": "Next 4 characters of IP core variation identifier string, 'MACT' = 0x4D414354.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x4D414354"
                },
                "txmac_name_2": {
                    "name": "TXMAC_NAME_2",
                    "addressOffset": "0x10",
                    "fields": {
                        "txmac_name_2": {
                            "name": "TXMAC_NAME_2",
                            "desc": "Final 4 characters of IP core variation identifier string, 'xCSR' = 0x78435352.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txMacName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x78435352"
                },
                "tx_link_fault": {
                    "name": "TX_LINK_FAULT",
                    "addressOffset": "0x14",
                    "desc": "Link Fault Configuration Register.",
                    "fields": {
                        "force_remote_fault": {
                            "name": "FORCE_REMOTE_FAULT",
                            "desc": "When link fault generation is enabled, stops data transmission and forces transmission of a remote fault.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0,
                            "tangoCommand": "TxLinkFaultForceRemote",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to stop data transmission and force transmistion of a remote fault. Write 0 to clear."
                        },
                        "disable_remote_fault": {
                            "name": "DISABLE_REMOTE_FAULT",
                            "desc": "When both link fault reporting and unidirectional transport are enabled, the core transmits data and does not transmit remote faults (RF). This bit takes effect when the value of this register is 28'hX4'b0111.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0,
                            "tangoCommand": "TxLinkFaultDisableRemote",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to disable. Write 0 to clear."
                        },
                        "unidir_enable": {
                            "name": "UNIDIR_ENABLE",
                            "desc": "When asserted, the core includes Clause 66 support for the remote link fault reporting on the Ethernet link.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0,
                            "tangoCommand": "TxLinkFaultUnidirEnable",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to include clause 66 support for remote link fault reporting. Write 0 to clear"
                        },
                        "pcs_gen_fault_sequence": {
                            "name": "PCS_GEN_FAULT_SEQUENCE",
                            "desc": "The following encodings are defined: 1'b1: The PCS generates the proper fault sequence on Ethernet link, when conditions are met. 1'b0: The PCS does not generate the fault sequence.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 1,
                            "tangoCommand": "TxLinkFaultPcsGenSequence",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to generate fault sequence. Write 0 to clear."
                        }
                    }
                },
                "ipg_col_rem": {
                    "name": "IPG_COL_REM",
                    "addressOffset": "0x18",
                    "fields": {
                        "ipg_col_rem": {
                            "name": "IPG_COL_REM",
                            "desc": "Specifies the number of IDLE columns to be removed in every Alignment Marker period to compensate for alignment marker insertion. You can program this register to a larger value than the default value, for clock compensation.",
                            "bitOffset": 0,
                            "bitWidth": 7,
                            "access": "rw",
                            "reset": 20
                        }
                    }
                },
                "txmac_size_config": {
                    "name": "TXMAC_SIZE_CONFIG",
                    "addressOffset": "0x1C",
                    "fields": {
                        "max_tx_size_config": {
                            "name": "MAX_TX_SIZE_CONFIG",
                            "desc": "Specifies the maximum TX frame length. Frames that are longer are considered oversized. However, the IP core does transmit them. If the IP core transmits an Ethernet frame of size greater than the number of bytes specified in this register, and the IP core includes statistics registers, the IP core increments the 64-bit CNTR_TX_OVERSIZE counter. The minimum value of this register is 64 (decimal).",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "access": "rw",
                            "reset": "0x2580"
                        }
                    }
                },
                "tx_mac_control": {
                    "name": "TX_MAC_CONTROL",
                    "addressOffset": "0x28",
                    "fields": {
                        "tx_vlan_detect_disable": {
                            "name": "TX_VLAN_DETECT_DISABLE",
                            "desc": "This bit is deasserted by default, implying VLAN detection is enabled.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_tx_RSFEC_reg_pkg": {
            "name": "Transmit Reed-Solomon Forward Error Correction (RS-FEC) (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_tx_RSFEC",
            "desc": [
                "Transmit RS-FEC Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.0",
            "tangoClassName": "DsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "tx_rsfec_revid": {
                    "name": "TX_RSFEC_REVID",
                    "addressOffset": "0x00",
                    "fields": {
                        "tx_rsfec_revid": {
                            "name": "TX_RSFEC_REVID",
                            "desc": "Reed-Solomon FEC TX module revision ID = 0x08092017.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro"
                        }
                    },
                    "tangoTestValue": "0x08092017"
                },
                "tx_rsfec_scratch": {
                    "name": "TX_RSFEC_SCRATCH",
                    "addressOffset": "0x04",
                    "tangoIgnore": true,
                    "fields": {
                        "tx_rsfec_scratch": {
                            "name": "TX_RSFEC_SCRATCH",
                            "desc": "Scratch register available for testing.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw"
                        }
                    }
                },
                "tx_rsfec_name_0": {
                    "name": "TX_RSFEC_NAME_0",
                    "addressOffset": "0x08",
                    "fields": {
                        "tx_rsfec_name_0": {
                            "name": "TX_RSFEC_NAME_0",
                            "desc": "Final 4 characters of IP core variation identifier string, '100gRSFECoTX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x67303031"
                },
                "tx_rsfec_name_1": {
                    "name": "TX_RSFEC_NAME_1",
                    "addressOffset": "0x0C",
                    "fields": {
                        "tx_rsfec_name_1": {
                            "name": "TX_RSFEC_NAME_1",
                            "desc": "Middle 4 characters of IP core variation identifier string, '100gRSFECoTX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x45465352"
                },
                "tx_rsfec_name_2": {
                    "name": "TX_RSFEC_NAME_2",
                    "addressOffset": "0x10",
                    "fields": {
                        "tx_rsfec_name_2": {
                            "name": "TX_RSFEC_NAME_2",
                            "desc": "Initial 4 characters of IP core variation identifier string, '100gRSFECoTX'.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "ro",
                            "tangoCombine": "txRsfecName",
                            "tangoDataType": "DevString"
                        }
                    },
                    "tangoTestValue": "0x58546f43"
                },
                "err_ins_en": {
                    "name": "ERR_INS_EN",
                    "addressOffset": "0x14",
                    "fields": {
                        "err_ins_single": {
                            "name": "ERR_INS_SINGLE",
                            "desc": "Enables error insertion for single FEC codeword. This bit selfclears after the Reed-Solomon FEC transmitter inserts the error.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "err_ins_all": {
                            "name": "ERR_INS_ALL",
                            "desc": "Enables error insertion for every FEC codeword. Specifies that the Reed-Solomon FEC transmitter should insert the error in every FEC codeword.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        }
                    }
                },
                "err_mask": {
                    "name": "ERR_MASK",
                    "addressOffset": "0x18",
                    "fields": {
                        "sym_32": {
                            "name": "SYM_32",
                            "desc": "Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies whether the RSFEC transmitter corrupts symbol 32 (of symbols 0-32) in each corrupted group. Specifically, the value of 1 directs the IP core to corrupt symbol 32 according to BIT_MASK.",
                            "bitOffset": 24,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "bit_mask": {
                            "name": "BIT_MASK",
                            "desc": "Specifies which of the ten bits the RS-FEC transmitter corrupts in each corrupted symbol. Specifically, the value of 1 in bit [n+8] directs the IP core to corrupt bit [n] in each corrupted symbol.",
                            "bitOffset": 8,
                            "bitWidth": 10,
                            "access": "rw"
                        },
                        "group_num": {
                            "name": "GROUP_NUM",
                            "desc": "Each FEC codeword consists of 16 groups of 33 symbols. This register field specifies the single group of 33 symbols that the RS-FEC transmitter corrupts in the current FEC codeword. The following values are defined: 4'b000: First group of 33 symbols (symbols 0-32) 4'b0001: Second group of symbols (symbols 33-65) ... 4'b1110: Second-to-final group of symbols (symbols 462-494) 4'b1111: Final group of symbols (symbols 495-527, or {chk[13:0],sym[514:495]}) Continuous corruption of groups 0-3 might lead to strange behavior as result of alignment marker corruption.",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "access": "rw"
                        }
                    }
                },
                "symbol_err_mask": {
                    "name": "SYMBOL_ERR_MASK",
                    "addressOffset": "0x1C",
                    "fields": {
                        "symbol_err_mask": {
                            "name": "SYMBOL_ERR_MASK",
                            "desc": "Each FEC codeword consists of 16 groups of 33 symbols. This register specifies which of the lower order 32 symbols in a group the RS-FEC transmitter corrupts. Specifically the value of 1 in bit [n] directs the IP core to corrupt symbol n.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "ethernet_100g.Ethernet_100G_tx_statistics_reg_pkg": {
            "name": "Transmit Statistics (Intel Stratix10 100GbE MAC)",
            "mnemonic": "Ethernet_100G_tx_statistics",
            "desc": [
                "Transmit Statistics Registers for the Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
                "For full documentation refer to the Intel Documentation for the IP core."
            ],
            "referenceDocumentTitle": "Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core User Guide",
            "referenceDocument": "https://www.intel.com/content/www/us/en/programmable/documentation/jte1495493753013.html#ezz1495493671605",
            "version": "19.2.0",
            "tangoClassName": "DsTalonDx100GigEth",
            "tangoClassTitle": "Talon-DX 100 Gigabit Ethernet Device Server",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX Low Latency 100G Ethernet Intel Stratix 10 FPGA IP Core.",
            "registers": {
                "cntr_tx_fragments": {
                    "name": "CNTR_TX_FRAGMENTS",
                    "addressOffset": "0x00",
                    "width": 64,
                    "fields": {
                        "cntr_tx_fragments": {
                            "name": "CNTR_TX_FRAGMENTS",
                            "desc": "Number of transmitted frames less than 64 bytes and reporting a CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_jabbers": {
                    "name": "CNTR_TX_JABBERS",
                    "addressOffset": "0x08",
                    "width": 64,
                    "fields": {
                        "cntr_tx_jabbers": {
                            "name": "CNTR_TX_JABBERS",
                            "desc": "Number of transmitted oversized frames reporting a CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_fcs": {
                    "name": "CNTR_TX_FCS",
                    "addressOffset": "0x10",
                    "width": 64,
                    "fields": {
                        "cntr_tx_fcs": {
                            "name": "CNTR_TX_FCS",
                            "desc": "Number of transmitted packets with FCS errors.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_crcerr": {
                    "name": "CNTR_TX_CRCERR",
                    "addressOffset": "0x18",
                    "width": 64,
                    "fields": {
                        "cntr_tx_crcerr": {
                            "name": "CNTR_TX_CRCERR",
                            "desc": "Number of transmitted frames with a frame of length at least 64 reporting a CRC error",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_mcast_data_err": {
                    "name": "CNTR_TX_MCAST_DATA_ERR",
                    "addressOffset": "0x20",
                    "width": 64,
                    "fields": {
                        "cntr_tx_mcast_data_err": {
                            "name": "CNTR_TX_MCAST_DATA_ERR",
                            "desc": "Number of errored multicast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_bcast_data_err": {
                    "name": "CNTR_TX_BCAST_DATA_ERR",
                    "addressOffset": "0x28",
                    "width": 64,
                    "fields": {
                        "cntr_tx_bcast_data_err": {
                            "name": "CNTR_TX_BCAST_DATA_ERR",
                            "desc": "Number of errored broadcast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_ucast_data_err": {
                    "name": "CNTR_TX_UCAST_DATA_ERR",
                    "addressOffset": "0x30",
                    "width": 64,
                    "fields": {
                        "cntr_tx_ucast_data_err": {
                            "name": "CNTR_TX_UCAST_DATA_ERR",
                            "desc": "Number of errored unicast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_mcast_ctrl_err": {
                    "name": "CNTR_TX_MCAST_CTRL_ERR",
                    "addressOffset": "0x38",
                    "width": 64,
                    "fields": {
                        "cntr_tx_mcast_ctrl_err": {
                            "name": "CNTR_TX_MCAST_CTRL_ERR",
                            "desc": "Number of errored multicast control frames transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_bcast_ctrl_err": {
                    "name": "CNTR_TX_BCAST_CTRL_ERR",
                    "addressOffset": "0x40",
                    "width": 64,
                    "fields": {
                        "cntr_tx_bcast_ctrl_err": {
                            "name": "CNTR_TX_BCAST_CTRL_ERR",
                            "desc": "Number of errored broadcast control frames transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_ucast_ctrl_err": {
                    "name": "CNTR_TX_UCAST_CTRL_ERR",
                    "addressOffset": "0x48",
                    "width": 64,
                    "fields": {
                        "cntr_tx_ucast_ctrl_err": {
                            "name": "CNTR_TX_UCAST_CTRL_ERR",
                            "desc": "Number of errored unicast control frames transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_pause_err": {
                    "name": "CNTR_TX_PAUSE_ERR",
                    "addressOffset": "0x50",
                    "width": 64,
                    "fields": {
                        "cntr_tx_pause_err": {
                            "name": "CNTR_TX_PAUSE_ERR",
                            "desc": "Number of errored pause frames transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_64b": {
                    "name": "CNTR_TX_64B",
                    "addressOffset": "0x58",
                    "width": 64,
                    "fields": {
                        "cntr_tx_64b": {
                            "name": "CNTR_TX_64B",
                            "desc": "Number of 64-byte transmitted frames, including the CRC field but excluding the preamble and SFD bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_65to127b": {
                    "name": "CNTR_TX_65to127B",
                    "addressOffset": "0x60",
                    "width": 64,
                    "fields": {
                        "cntr_tx_65to127b": {
                            "name": "CNTR_TX_65to127B",
                            "desc": "Number of transmitted frames between 65-127 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_128to255b": {
                    "name": "CNTR_TX_128to255B",
                    "addressOffset": "0x68",
                    "width": 64,
                    "fields": {
                        "cntr_tx_128to255b": {
                            "name": "CNTR_TX_128to255B",
                            "desc": "Number of transmitted frames between 128-255 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_256to511b": {
                    "name": "CNTR_TX_256to511B",
                    "addressOffset": "0x70",
                    "width": 64,
                    "fields": {
                        "cntr_tx_256to511b": {
                            "name": "CNTR_TX_256to511B",
                            "desc": "Number of transmitted frames between 256-511 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_512to1023b": {
                    "name": "CNTR_TX_512to1023B",
                    "addressOffset": "0x78",
                    "width": 64,
                    "fields": {
                        "cntr_tx_512to1023b": {
                            "name": "CNTR_TX_512to1023B",
                            "desc": "Number of transmitted frames between 512-1023 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_1024to1518b": {
                    "name": "CNTR_TX_1024to1518B",
                    "addressOffset": "0x80",
                    "width": 64,
                    "fields": {
                        "cntr_tx_1024to1518b": {
                            "name": "CNTR_TX_1024to1518B",
                            "desc": "Number of transmitted frames between 1024-1518 bytes",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_1519tomaxb": {
                    "name": "CNTR_TX_1519toMAXB",
                    "addressOffset": "0x88",
                    "width": 64,
                    "fields": {
                        "cntr_tx_1519tomaxb": {
                            "name": "CNTR_TX_1519toMAXB",
                            "desc": "Number of transmitted frames of size between 1519 bytes and the number of bytes specified in the MAX_TX_SIZE_CONFIG register",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_oversize": {
                    "name": "CNTR_TX_OVERSIZE",
                    "addressOffset": "0x90",
                    "width": 64,
                    "fields": {
                        "cntr_tx_oversize": {
                            "name": "CNTR_TX_OVERSIZE",
                            "desc": "Number of oversized frames (frames with more bytes than the number specified in the MAX_TX_SIZE_CONFIG register) transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_mcast_data_ok": {
                    "name": "CNTR_TX_MCAST_DATA_OK",
                    "addressOffset": "0x98",
                    "width": 64,
                    "fields": {
                        "cntr_tx_mcast_data_ok": {
                            "name": "CNTR_TX_MCAST_DATA_OK",
                            "desc": "Number of valid multicast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_bcast_data_ok": {
                    "name": "CNTR_TX_BCAST_DATA_OK",
                    "addressOffset": "0xA0",
                    "width": 64,
                    "fields": {
                        "cntr_tx_bcast_data_ok": {
                            "name": "CNTR_TX_BCAST_DATA_OK",
                            "desc": "Number of valid broadcast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_ucast_data_ok": {
                    "name": "CNTR_TX_UCAST_DATA_OK",
                    "addressOffset": "0xA8",
                    "width": 64,
                    "fields": {
                        "cntr_tx_ucast_data_ok": {
                            "name": "CNTR_TX_UCAST_DATA_OK",
                            "desc": "Number of valid unicast frames transmitted, excluding control frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_mcast_ctrl": {
                    "name": "CNTR_TX_MCAST_CTRL",
                    "addressOffset": "0xB0",
                    "width": 64,
                    "fields": {
                        "cntr_tx_mcast_ctrl": {
                            "name": "CNTR_TX_MCAST_CTRL",
                            "desc": "Number of valid multicast frames transmitted, excluding data frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_bcast_ctrl": {
                    "name": "CNTR_TX_BCAST_CTRL",
                    "addressOffset": "0xB8",
                    "width": 64,
                    "fields": {
                        "cntr_tx_bcast_ctrl": {
                            "name": "CNTR_TX_BCAST_CTRL",
                            "desc": "Number of valid broadcast frames transmitted, excluding data frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_ucast_ctrl": {
                    "name": "CNTR_TX_UCAST_CTRL",
                    "addressOffset": "0xC0",
                    "width": 64,
                    "fields": {
                        "cntr_tx_ucast_ctrl": {
                            "name": "CNTR_TX_UCAST_CTRL",
                            "desc": "Number of valid unicast frames transmitted, excluding data frames",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_pause": {
                    "name": "CNTR_TX_PAUSE",
                    "addressOffset": "0xC8",
                    "width": 64,
                    "fields": {
                        "cntr_tx_pause": {
                            "name": "CNTR_TX_PAUSE",
                            "desc": "Number of valid pause frames transmitted",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_runt": {
                    "name": "CNTR_TX_RUNT",
                    "addressOffset": "0xD0",
                    "width": 64,
                    "fields": {
                        "cntr_tx_runt": {
                            "name": "CNTR_TX_RUNT",
                            "desc": "Number of transmitted runt packets. The IP core does not transmit frames of length less than nine bytes. The IP core pads frames of length nine bytes to 64 bytes to extend them to 64 bytes. Therefore, this counter does not increment in normal operating conditions.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "cntr_tx_config": {
                    "name": "CNTR_TX_CONFIG",
                    "addressOffset": "0x114",
                    "fields": {
                        "tx_shadow_req": {
                            "name": "TX_SHADOW_REQ",
                            "desc": "Shadow request (active high): When set to the value of 1, TX statistics collection is paused. The underlying counters continue to operate, but the readable values reflect a snapshot at the time the pause flag was activated. Write a 0 to release.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "TxCntrConfigShadowRequest",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to pause Tx statistics. Write 0 to release."
                        },
                        "tx_parity_err_clr": {
                            "name": "TX_PARITY_ERR_CLR",
                            "desc": "Parity-error clear. When software sets this bit, the IP core clears the parity bit CNTR_TX_STATUS[0]. This bit (CNTR_TX_CONFIG[1]) is self-clearing.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "TxCntrConfigParityErrorClear",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to clear the parity bit."
                        },
                        "tx_cnt_clr": {
                            "name": "TX_CNT_CLR",
                            "desc": "Software can set this bit to the value of 1 to reset all of the TX statistics registers at the same time. This bit is self-clearing.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "tangoCommand": "TxCntrConfigCounterClear",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to reset all Tx statistics."
                        }
                    }
                },
                "cntr_tx_status": {
                    "name": "CNTR_TX_STATUS",
                    "addressOffset": "0x118",
                    "fields": {
                        "tx_cnt_pause": {
                            "name": "TX_CNT_PAUSE",
                            "desc": "Indicates that the TX statistics registers are paused (while CNTR_TX_CONFIG[2] is asserted).",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        },
                        "tx_parity_err": {
                            "name": "TX_PARITY_ERR",
                            "desc": "Indicates the presence of at least one parity error in the TX statistics counters.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw"
                        }
                    }
                },
                "txpayloadoctetsok": {
                    "name": "TxPayloadOctetsOK",
                    "addressOffset": "0x180",
                    "width": 64,
                    "fields": {
                        "txpayloadoctetsok": {
                            "name": "TxPayloadOctetsOK",
                            "desc": "Number of transmitted payload bytes in frames with no FCS, undersized, oversized, or payload length errors. If VLAN detection is turned off for the TX MAC (bit[1] of the TX_MAC_CONTROL register at offset 0x40A has the value of 1), the IP core counts the VLAN header bytes (4 bytes for VLAN and 8 bytes for stacked VLAN) as payload bytes. This register is compliant with the requirements for aOctetsTransmittedOK in section 5.2.2.1.8 of the IEEE Standard 802.3-2008.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                },
                "txframeoctetsok": {
                    "name": "TxFrameOctetsOK",
                    "addressOffset": "0x188",
                    "width": 64,
                    "fields": {
                        "txframeoctetsok": {
                            "name": "TxFrameOctetsOK",
                            "desc": "Number of transmitted bytes in frames with no FCS, undersized, oversized, or payload length errors. This register is compliant with the requirements for ifOutOctets in RFC3635 (Managed Objects for Ethernet-like Interface Types) and TX etherStatsOctets in RFC2819(Remote Network Monitoring Management Information Base (RMON)).",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "tangoDataType": "DevULong64"
                        }
                    }
                }
            }
        },
        "ethernet_100g.qsfp_ctrl_reg_pkg": {
            "name": "QSFP Control",
            "mnemonic": "qsfp_ctrl",
            "desc": "QSFP Low-Speed Signaling",
            "version": "1.0.0",
            "tangoClassName": "DsTalonDxQsfpCtrl",
            "tangoClassTitle": "Talon-DX QSFP Module Control TANGO Device",
            "tangoClassDescription": "TANGO Device Server for monitor and control of Talon-DX QSFP Control Intel Stratix 10 FPGA IP Core Module.",
            "registers": {
                "ctrl": {
                    "name": "Control",
                    "addressOffset": "0x0",
                    "desc": "QSFP Low-Speed Control.",
                    "fields": {
                        "mod_sel_n": {
                            "name": "mod_sel_n",
                            "desc": "When set to '0', the QSFP module responds to 2-wire serial communication commands. When set to '1' the module does not respond to or acknowledge any 2-wire interface communication from the host. This allows the use of multiple QSFP module on a single 2-wire bus.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 1,
                            "access": "rw",
                            "tangoAttName": "modeSelect",
                            "tangoAttDesc": "Read or write the mode select value directly to the register using the attribute construct.",
                            "tangoAttLabel": "Mode Select",
                            "tangoCommand": "ModeSelect",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 0 to configure QSFP to respond to 2-wire serial comm commands, Write 1 to disable 2-wire interface."
                        },
                        "reset_n": {
                            "name": "reset_n",
                            "desc": "Toggling this field to '0' then back to '1' initiates a complete QSFP module reset, returning all user module settings to their default state. The module indicates completion of reset by posting an interrupt signal.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 1,
                            "access": "rw",
                            "tangoAttName": "reset",
                            "tangoAttDesc": "Read or write the reset bit directly to the register via the attribute construct.",
                            "tangoAttLabel": "Reset",
                            "tangoCommand": "ResetDevice",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 0 then write 1 to initiate a complete QSFP module reset."
                        },
                        "lowpwr": {
                            "name": "lowpwr",
                            "desc": "Setting this field to '1' sets the module in low-power mode. This essentially disables the laser and receiver but keeps the I2C accessable.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw",
                            "tangoAttName": "lowPower",
                            "tangoAttDesc": "Read or write the low power bit directly to the register via the attribute construct.",
                            "tangoAttLabel": "Low Power",
                            "tangoCommand": "LowPower",
                            "tangoCommandArginType": "DevULong",
                            "tangoCommandArginDesc": "Write 1 to set module in low-power mode. Write 0 to remove from low-power mode."
                        }
                    }
                },
                "status": {
                    "name": "Status",
                    "addressOffset": "0x4",
                    "desc": "QSFP Low-Speed Status.",
                    "fields": {
                        "mod_prs_n": {
                            "name": "mod_prs_n",
                            "desc": "When read as '0' this field indicates that the QSFP module is present. When read as '1' this field indicates that the QSFP module is not present.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro",
                            "tangoAttName": "present"
                        },
                        "interrupt_n": {
                            "name": "interrupt_n",
                            "desc": "When read as '0' this field indicates that the module has a pending interrupt that can be serviced through the 2-wire serial interface.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "ro",
                            "tangoAttName": "interrupt"
                        }
                    }
                }
            }
        },
        "sys_id.sys_id_reg_pkg": {
            "name": "System Identifier",
            "mnemonic": "sys_id",
            "desc": [
                "FPGA bitstream system identification information.",
                "The information in this register set is populated by a Memory Initialisation File (mif). This file is generated by the script `generate_sys_id_register_file`.",
                "This allows the information to be updated after the bitstream is successfully placed and routed using the Quartus ECO process `tcl:update_mif_files` ."
            ],
            "version": "1.0.0",
            "registers": {
                "bitstream": {
                    "name": "Bitstream",
                    "desc": [],
                    "fields": {
                        "bitstream": {
                            "name": "Bitstream Identifier",
                            "desc": [
                                "Identification number that uniquely identifies this bitstream.",
                                "Calculated as the least significant 32 bits of the md5 checksum of the bitsream name.",
                                "For example: 'ska-mid-cbf-tdc-correlator' => `$ echo -n ska-mid-cbf-tdc-correlator | md5sum | cut -c 25-32` returns: `f3923f36`.",
                                "If the bitstream is a base bitstream with partially reconfigurable regions then the revision string doesn't include the PR region. e.g. 'talon_dx-tdc-base'."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "version": {
                    "name": "Bitstream Version",
                    "desc": [
                        "The semantic version of the bitstream. See https://semver.org/",
                        "Given a version number MAJOR.MINOR.PATCH, increment the:",
                        " * MAJOR version when you make incompatible API changes,",
                        " * MINOR version when you add functionality in a backwards compatible manner, and",
                        " * PATCH version when you make backwards compatible bug fixes.",
                        "Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format."
                    ],
                    "width": 32,
                    "fields": {
                        "major": {
                            "name": "Major Version",
                            "desc": "The major version. Incremented when incompatible API changes are made.",
                            "ftype": "natural",
                            "bitOffset": 24,
                            "bitWidth": 8,
                            "access": "ro",
                            "reset": 0,
                            "repeat": 1
                        },
                        "minor": {
                            "name": "Minor Version",
                            "desc": "The minor version. Incremented when functionality is added in a backwards compatible manner.",
                            "ftype": "natural",
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "access": "ro",
                            "reset": 0
                        },
                        "patch": {
                            "name": "Patch Version",
                            "desc": "The patch version. Incremented when backwards compatible bug fixes are made.",
                            "ftype": "natural",
                            "bitOffset": 8,
                            "bitWidth": 8,
                            "access": "ro",
                            "reset": 0
                        },
                        "prerelease": {
                            "name": "Pre-release Version",
                            "desc": "The prerelease version. Incremented when a testing image is made. For published bitstreams this should be zero.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 8,
                            "access": "ro",
                            "reset": 0
                        }
                    }
                },
                "commit": {
                    "name": "Git Commit Hash",
                    "desc": "",
                    "fields": {
                        "commit": {
                            "name": "Git Commit Hash",
                            "desc": "Least significant 32b of the git commit hash for the bitstream base or persona.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "scratch": {
                    "name": "Scratch",
                    "desc": "A register that you can write and read-back to test basic register bus access.",
                    "fields": {
                        "scratch": {
                            "name": "Scratch",
                            "desc": "Write-readback field.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "talon_status.talon_status_reg_pkg": {
            "name": "Talon Status",
            "mnemonic": "talon_status",
            "desc": "FW IP Talon Status",
            "version": "1.0.0",
            "author": "Richard Hein",
            "email": "richard.hein@mda.space",
            "date": "2022-05-06",
            "registers": {
                "talon_current_fault_summary_register": {
                    "name": "Talon Current Fault Summary Register",
                    "desc": "Provides a one register summary of the current Talon status. Other registers provide more details for diagnostics. The register should return 0xC000 for no current fault conditions. Any other value would indicate a hardware or DDR4 DIMM memory module problem. This register is not intended for software use as the following registers provide the same information in greater detail. It is intended for low level testing in situations where the software stack may not be responding by doing single register peek from the console to check health without having to read and decode all the registers ",
                    "addressOffset": "0x00",
                    "fields": {
                        "iopll_locked_fault": {
                            "name": "PLL Locked Fault",
                            "desc": "Returns the vcc_base_iopll PLL locked status signal. This PLL sources the 125MHz and 100MHz clocks. Indicates a problem with source 125MHz reference clock.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "fs_iopll_locked_fault": {
                            "name": "FS PLL Locked Fault",
                            "desc": "Returns the fs_iopll PLL locked status signal. This PLL sources the 450MHz clock. Indicates a problem with source 125MHz reference clock.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "comms_iopll_locked_fault": {
                            "name": "Comms PLL Locked Fault",
                            "desc": "Returns the comms_iopll PLL locked status signal. This PLL sources the 400MHz clock. Indicates a problem with source 125MHz reference clock.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "system_clk_fault": {
                            "name": "System Clock Fault",
                            "desc": "Indicates a fault with the 125MHz source clock being not operational or not at the expected frequency. Further internal clocks are derived from this clock and would imply no other core functions are working.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_bl_fault": {
                            "name": "EMIF Bottom Left Fault",
                            "desc": "Returns the summary status of the bottom left EMIF. A high indicates a fault with calibration, PLL lock or clock frequency.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_br_fault": {
                            "name": "EMIF Bottom Right Fault",
                            "desc": "Returns the summary status of the bottom right EMIF. A high indicates a fault with calibration, PLL lock or clock frequency.",
                            "bitOffset": 5,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_tr_fault": {
                            "name": "EMIF Top Right Fault",
                            "desc": "Returns the summary status of the top right EMIF. A high indicates a fault with calibration, PLL lock or clock frequency.",
                            "bitOffset": 6,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "e100g_0_pll_fault": {
                            "name": "100GbE 0 PLL Fault",
                            "desc": "Returns the summary status of the first 100GbE transceiver's PLLs. A high indicates a fault with one of the two PLLs.",
                            "bitOffset": 7,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "e100g_1_pll_fault": {
                            "name": "100GbE 1 PLL Fault",
                            "desc": "Returns the summary status of the second 100GbE transceiver's PLLs. A high indicates a fault with one of the two PLLs.",
                            "bitOffset": 8,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "slim_pll_fault": {
                            "name": "SLIM PLL Fault",
                            "desc": "Returns the summary status of the SLIM PPLs. A high indicates a fault with at least one of the SLIMs.",
                            "bitOffset": 9,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "non_zero": {
                            "name": "Non Zero Pattern 0xC...",
                            "desc": "A non-zero 0xC fixed bit pattern to indicate successful register access confirming the HPS and DeTrI interface clocks are operational.",
                            "bitOffset": 10,
                            "bitWidth": 6,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "base_clock_frequency_register": {
                    "name": "Base Clock Frequency Register",
                    "addressOffset": "0x04",
                    "desc": "",
                    "fields": {
                        "base_clock_frequency": {
                            "name": "Base Clock Frequency",
                            "desc": "Frequency counter for the 125 MHz clock. The value returned should be 125,000,000 \u00b1 70 ppm (\u00b1 8750 Hz). This clock is the base for other derived system clocks. Updated every second.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "emif_bl_clock_frequency_register": {
                    "name": "EMIF Bottom Left Clock Frequency Register",
                    "addressOffset": "0x0C",
                    "desc": "",
                    "fields": {
                        "emif_bl_clock_frequency": {
                            "name": "EMIF bottom left clock frequency counter",
                            "desc": "Frequency counter for the EMIF interface clock. The value returned should be 333,333,333 \u00b1 70 ppm (\u00b1 23,333 Hz). Updated every second.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "emif_br_clock_frequency_register": {
                    "name": "EMIF Bottom Right Clock Frequency Register",
                    "addressOffset": "0x10",
                    "desc": "",
                    "fields": {
                        "emif_br_clock_frequency": {
                            "name": "EMIF bottom right clock frequency counter",
                            "desc": "Frequency counter for the EMIF interface clock. The value returned should be 333,333,333 \u00b1 70 ppm (\u00b1 23,333 Hz). Updated every second.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "emif_tr_clock_frequency_register": {
                    "name": "EMIF Top Right Clock Frequency Register",
                    "addressOffset": "0x14",
                    "desc": "",
                    "fields": {
                        "emif_tr_clock_frequency": {
                            "name": "EMIF top right clock frequency counter",
                            "desc": "Frequency counter for the EMIF interface clock. The value returned should be 333,333,333 \u00b1 70 ppm (\u00b1 23,333 Hz). Updated every second.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "base_clock_current_status_register": {
                    "name": "Base Clock Current Status Register",
                    "addressOffset": "0x18",
                    "desc": "",
                    "fields": {
                        "iopll_locked": {
                            "name": "PLL Locked",
                            "desc": "Returns the vcc_base_iopll PLL locked status signal. This PLL sources the 125MHz and 100MHz clocks. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "fs_iopll_locked": {
                            "name": "FS PLL Locked",
                            "desc": "Returns the fs_iopll PLL locked status signal. This PLL sources the 450MHz clock. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "comms_iopll_locked": {
                            "name": "Comms PLL Locked",
                            "desc": "Returns the comms_iopll PLL locked status signal. This PLL sources the 400MHz clock. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "base_clock_transition_status_register": {
                    "name": "Base Clock Transition Status Register",
                    "addressOffset": "0x1C",
                    "desc": "",
                    "fields": {
                        "iopll_locked_trn": {
                            "name": "PLL Locked",
                            "desc": "Returns the vcc_base_iopll PLL locked status signal. This PLL sources the 125MHz and 100MHz clocks. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "fs_iopll_locked_trn": {
                            "name": "FS PLL Locked",
                            "desc": "Returns the fs_iopll PLL locked status signal. This PLL sources the 450MHz clock. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "comms_iopll_locked_trn": {
                            "name": "Comms PLL Locked",
                            "desc": "Returns the comms_iopll PLL locked status signal. This PLL sources the 400MHz clock. Indicates a problem with source 125MHz reference clock. Should normally be True.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "emif_current_status_register": {
                    "name": "EMIF Current Status Register",
                    "addressOffset": "0x20",
                    "repeat": 3,
                    "desc": "",
                    "fields": {
                        "emif_pll_locked": {
                            "name": "PLL Locked",
                            "desc": "Returns the state of the pll_locked signal from the EMIF PLL. Failure to lock would indicate a problem with the reference clock missing or being unstable. Should normally be True.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_local_reset_done": {
                            "name": "Local Reset Done",
                            "desc": "Returns the state of the local_reset_done signal from the EMIF. Should normally be True.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_local_cal_success": {
                            "name": "Local Cal Success",
                            "desc": "Returns the state of the local_cal_success signal from the EMIF. Should normally be True.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_local_cal_fail": {
                            "name": "Local Cal Fail",
                            "desc": "Returns the state of the local_cal_fail signal from the EMIF. Indicates a fault with the interface to the DDR4 DIMM module. Should normally be False.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_amm_ready": {
                            "name": "AMM Ready",
                            "desc": "Returns the state of the amm_ready_0 signal from the EMIF. Indicates that the Avalon memory interface is ready to receive access requests. Should normally be True.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "emif_reset": {
                            "name": "EMIF Reset",
                            "desc": "Asserts the local_reset_req signal to the EMIF to restart calibration. SW must write a '1' followed by a '0' to restart calibration.",
                            "bitOffset": 5,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "emif_transition_status_register": {
                    "name": "EMIF Transition Status Register",
                    "addressOffset": "0x2C",
                    "repeat": 3,
                    "desc": "Indicates transitions in the status signals as defined in the previous register. Cleared by writing a '1' to the corresponding status bit.",
                    "fields": {
                        "emif_pll_locked_trn": {
                            "name": "PLL Locked Transition",
                            "desc": "Indicates a transition of the pll_locked signal from the EMIF PLL.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "emif_local_reset_done_trn": {
                            "name": "Local Reset Done Transition",
                            "desc": "Indicates a transition of the local_reset_done signal from the EMIF.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "emif_local_cal_success_trn": {
                            "name": "Local Cal Success Transition",
                            "desc": "Indicates a transition of the local_cal_success signal from the EMIF.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "emif_local_cal_fail_trn": {
                            "name": "Local Cal Fail Transition",
                            "desc": "Indicates a transition of local_cal_fail signal from the EMIF.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "emif_amm_ready_trn": {
                            "name": "AMM Ready Transition",
                            "desc": "Indicates a transition of the amm_ready_0 signal from the EMIF.",
                            "bitOffset": 4,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "e100g_current_status_register": {
                    "name": "100GbE Current Status Register",
                    "addressOffset": "0x38",
                    "repeat": 2,
                    "desc": "",
                    "fields": {
                        "e100g_main_pll_locked": {
                            "name": "100GbE Main ATX PLL Locked",
                            "desc": "Returns the state of the pll_locked signal from the main ATX PLL. Failure to lock would indicate a missing or unstable reference clock. Should normally be True.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "e100g_main_pll_cal_busy": {
                            "name": "100GbE Main ATX PLL Calibration Busy",
                            "desc": "Returns the state of the pll_cal_busy signal from the main ATX PLL. Failure to calibrate would indicate an unstable reference clock. Should normally be False.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "e100g_buffer_pll_locked": {
                            "name": "100GbE Buffer ATX PLL Locked",
                            "desc": "Returns the state of the pll_locked signal from the buffer ATX PLL. Failure to lock would indicate a missing or unstable reference clock. Should normally be True.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "e100g_buffer_pll_cal_busy": {
                            "name": "100GbE Buffer ATX PLL Calibration Busy",
                            "desc": "Returns the state of the pll_cal_busy signal from the buffer ATX PLL. Failure to calibrate would indicate an unstable reference clock. Should normally be False.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "e100g_transition_status_register": {
                    "name": "100GbE Transition Status Register",
                    "addressOffset": "0x40",
                    "repeat": 2,
                    "desc": "",
                    "fields": {
                        "e100g_main_pll_locked_trn": {
                            "name": "100GbE Main ATX PLL Locked",
                            "desc": "Indicates a transition of the pll_locked signal from the main ATX PLL.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "e100g_main_pll_cal_busy_trn": {
                            "name": "100GbE Main ATX PLL Calibration Busy",
                            "desc": "Indicates a transition of the pll_cal_busy signal from the main ATX PLL.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "e100g_buffer_pll_locked_trn": {
                            "name": "100GbE Buffer ATX PLL Locked",
                            "desc": "Indicates a transition of the pll_locked signal from the buffer ATX PLL.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "e100g_buffer_pll_cal_busy_trn": {
                            "name": "100GbE Buffer ATX PLL Calibration Busy",
                            "desc": "Indicates a transition of the pll_cal_busy signal from the buffer ATX PLL.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "slim_is_present_register_lsw": {
                    "name": "SLIM Is Present Register (LSW).",
                    "addressOffset": "0x48",
                    "desc": "",
                    "fields": {
                        "slim_is_present_lsw": {
                            "name": "SLIM Is Present",
                            "desc": "High when the SLIM is present in the FPGA build. Uses to mask the following corresponding SLIM status registers.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_is_present_register_msw": {
                    "name": "SLIM Is Present Register (MSW).",
                    "addressOffset": "0x4C",
                    "desc": "",
                    "fields": {
                        "slim_is_present_msw": {
                            "name": "SLIM Is Present",
                            "desc": "High when the SLIM is present in the FPGA build. Uses to mask the folowing corresponding SLIM status registers.",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_pll_locked_current_status_register_lsw": {
                    "name": "SLIM PLL Locked Current Status Register (LSW).",
                    "addressOffset": "0x50",
                    "desc": "",
                    "fields": {
                        "slim_pll_locked_status_lsw": {
                            "name": "SLIM PLL Locked Status",
                            "desc": "Status of the SLIM PLL pll_locked signals. Should normally be all True.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_pll_locked_current_status_register_msw": {
                    "name": "SLIM PLL Locked Current Status Register (MSW).",
                    "addressOffset": "0x54",
                    "desc": "",
                    "fields": {
                        "slim_pll_locked_status_msw": {
                            "name": "SLIM PLL Locked Status",
                            "desc": "Status of the SLIM PLL pll_locked signals. Should normally be all True.",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_pll_locked_transition_status_register_lsw": {
                    "name": "SLIM PLL Locked Transition Status Register (LSW).",
                    "addressOffset": "0x58",
                    "desc": "",
                    "fields": {
                        "slim_pll_locked_status_trn_lsw": {
                            "name": "SLIM Top Left PLL Locked Transition",
                            "desc": "Indicates a transition of the 8 SLIM PLL pll_locked signals",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "slim_pll_locked_transition_status_register_msw": {
                    "name": "SLIM PLL Locked Transition Status Register (MSW).",
                    "addressOffset": "0x5C",
                    "desc": "",
                    "fields": {
                        "slim_pll_locked_status_trn_msw": {
                            "name": "SLIM Top Left PLL Locked Transition",
                            "desc": "Indicates a transition of the 8 SLIM PLL pll_locked signals",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "slim_pll_cal_busy_current_status_register_lsw": {
                    "name": "SLIM PLL Calibration Busy Current Status Register (LSW).",
                    "addressOffset": "0x60",
                    "desc": "",
                    "fields": {
                        "slim_pll_cal_busy_status_lsw": {
                            "name": "SLIM PLL Calibration Busy Status",
                            "desc": "Status of the 8 SLIM PLL pll_cal_busysignals. Should normally be all False.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_pll_cal_busy_current_status_register_msw": {
                    "name": "SLIM PLL Calibration Busy Current Status Register. (MSW)",
                    "addressOffset": "0x64",
                    "desc": "",
                    "fields": {
                        "slim_pll_cal_busy_status_msw": {
                            "name": "SLIM PLL Calibration Busy Status",
                            "desc": "Status of the 8 SLIM PLL pll_cal_busysignals. Should normally be all False.",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "slim_pll_cal_busy_transition_status_register_lsw": {
                    "name": "SLIM PLL Calibration Busy Transition Register (LSW)",
                    "addressOffset": "0x68",
                    "desc": "",
                    "fields": {
                        "slim_pll_cal_busy_status_trn_lsw": {
                            "name": "SLIM PLL Calibration Busy Transition",
                            "desc": "Indicates a transition of the 8 SLIM PLL pll_cal_busysignals",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "slim_pll_cal_busy_transition_status_register_msw": {
                    "name": "SLIM PLL Calibration Busy Transition Register (MSW).",
                    "addressOffset": "0x6C",
                    "desc": "",
                    "fields": {
                        "slim_pll_cal_busy_status_trn_msw": {
                            "name": "SLIM PLL Calibration Busy Transition",
                            "desc": "Indicates a transition of the 8 SLIM PLL pll_cal_busysignals",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "led_ctrl.led_ctrl_reg_pkg": {
            "name": "Simple Light Emitting Diode Control",
            "mnemonic": "led_ctrl",
            "desc": "Simple register interface to turn LEDs on and off.",
            "version": "0.1.0",
            "registers": {
                "led_switch": {
                    "name": "LED Switch",
                    "desc": "Switch on and off LEDs.",
                    "fields": {
                        "led": {
                            "name": "LED",
                            "desc": "Set true to turn LED on. Set false to turn LED off.",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "repeat": 32
                        }
                    }
                }
            }
        },
        "vcc_ch20.vcc_ch20_reg_pkg": {
            "name": "Very Coarse Channelizer - 20 Channel Version",
            "desc": [
                "The firmware block for the 'The Very Coarse Channelizer - 20 Channel Version'.",
                "The configuration registers set the number of frames between PPS markers and",
                "scaling the Frequency-Slices (FSs) before the final quantization."
            ],
            "mnemonic": "vcc_ch20",
            "version": "1.0.0",
            "author": "T. Gunaratne",
            "email": "Thushara.Gunaratne@nrc-cnrc.gc.ca",
            "date": "2021-01-14",
            "referenceDocumentTitle": "None",
            "referenceDocument": "None",
            "registers": {
                "config_pps_frame_count": {
                    "name": "Config PPS Frame Count",
                    "desc": [
                        "This register specifies the expected number of data-frames between PPS markers.",
                        "For vcc_ch20, a data-frames of 18 consecutive samples.",
                        "The pulse-per-second (PPS) marks the start sample of each 1 second.",
                        "There is an expected number of data-frames between PPS, which is different for each DISH.",
                        "If the count of data-frames does not match this register then the output samples are RFI flagged."
                    ],
                    "addressOffset": "0x0",
                    "fields": {
                        "frame_count": {
                            "name": "Frame Count",
                            "desc": "The number of data-frames between PPS markers.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 220000000,
                            "access": "rw"
                        }
                    }
                },
                "config_fs_sft_scl": {
                    "name": "Config Frequency Slice Scaling",
                    "desc": [
                        "The VCC channeliser implementation has an internal gain of approximately 0.944*sqrt(20) = 4.222.",
                        "To correct for this we apply a scaling factor at the output. The scaling factor is split into two components:",
                        "1. SFT, a shift-right factor that divides by a power of two, for a gain adjustment of 1/2**SFT, and",
                        "2. SCL, a scale factor that multiplies the result with a value between 1 and 0.",
                        "For unity gain, we must correct the output by 1/4.222 = 0.2369 which can be decomposed into two terms, 1/4 * 4/4.222,",
                        "Therefore, from the first term, 1/4 = 1/(2**SFT) => SFT = 2, and",
                        "subsequently from the second term, 4/4.222 = 2**SFT/4.222 = 0.9475, and converting to a 16 bit unsigned value, SCL = 0.9475*65536 = 62094.",
                        "These are the default values for the registers.",
                        "",
                        "There are 20 repeats of this register.",
                        "Entries  0-9  correspond to polarization 0,",
                        "Entries 10-19 correspond to polarization 1."
                    ],
                    "addressOffset": "0x4",
                    "repeat": 20,
                    "fields": {
                        "fs_sft": {
                            "name": "Frequency Slice Shift Right",
                            "desc": "The scaling factor 1/(2**FS_SFT).",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 2,
                            "access": "rw"
                        },
                        "fs_scl": {
                            "name": "Frequency Slice Scale",
                            "desc": "The fractional scaling factor FS_SCL/65536.",
                            "ftype": "natural",
                            "bitOffset": 4,
                            "bitWidth": 16,
                            "reset": 62094,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "dish_pkt_cap.pkt_cap_reg_pkg": {
            "name": "Dish packet capture register set",
            "mnemonic": "pkt_cap",
            "desc": "Dish packet capture register set",
            "version": "1.0.0",
            "author": "Jun Li",
            "email": "jun.li@mdacoroporation.com",
            "date": "2020-06-11",
            "registers": {
                "magic_number_register": {
                    "name": "magic number register",
                    "desc": "magic number of the IP type",
                    "fields": {
                        "magic_number": {
                            "name": "magic number",
                            "desc": "magic number of the IP type",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "revision_register": {
                    "name": "revision register",
                    "desc": "Revision of this IP",
                    "fields": {
                        "revision": {
                            "name": "revision",
                            "desc": "Revision of this IP",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "reset_register": {
                    "name": "reset register",
                    "desc": "reset packet capture logic",
                    "fields": {
                        "reset": {
                            "name": "reset",
                            "desc": "reset packet capture logic",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "err_cnt_register": {
                    "name": "error count register",
                    "desc": "error count register",
                    "fields": {
                        "err_cnt": {
                            "name": "error count",
                            "desc": "error count",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "clr_err_register": {
                    "name": "clear error count",
                    "desc": "clear dish packet receiver error count",
                    "fields": {
                        "clr_err_cnt": {
                            "name": "clear error count",
                            "desc": "clear dish packet receiver error count",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "err_type_register": {
                    "name": "err_type",
                    "desc": "error type from the last erroneous packet",
                    "fields": {
                        "err_type": {
                            "name": "error type",
                            "desc": "error type from the last erroneous packet",
                            "bitOffset": 0,
                            "bitWidth": 6,
                            "ftype": "natural",
                            "access": "ro"
                        }
                    }
                },
                "pkt_cap_register": {
                    "name": "packet to capture",
                    "desc": "packet to capture",
                    "fields": {
                        "pkt_cap": {
                            "name": "capture to capture",
                            "desc": "packet to capture",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "capture_register": {
                    "name": "capture",
                    "desc": "capture a packet",
                    "fields": {
                        "capture": {
                            "name": "capture",
                            "desc": "capture a packet",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "status_register": {
                    "name": "status register",
                    "desc": "status of the IP type",
                    "fields": {
                        "ip_status": {
                            "name": "ip status",
                            "desc": "status of the IP, capture in progress",
                            "ftype": "boolean",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 1
                        }
                    }
                },
                "physical_start_address_register": {
                    "name": "HPS shared memory physical start address register",
                    "desc": "HPS shared memory physical start address register",
                    "fields": {
                        "physical_start_address": {
                            "name": "physical start address",
                            "desc": "physical start address in bytes",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "physical_end_address_register": {
                    "name": "HPS shared memory physical end address register",
                    "desc": "HPS shared memory physical end address register",
                    "fields": {
                        "physical_end_address": {
                            "name": "physical end address",
                            "desc": "physical end address in bytes",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "circuit_switch.circuit_switch_reg_pkg": {
            "name": "circuit switch register set",
            "mnemonic": "circuit_switch",
            "desc": [
                "The parameterized circuit switch IP block allows customized circuit switches",
                "1. Register configurable connections between input ports and output ports",
                "2. Allows duplication of input data to multiple output ports"
            ],
            "version": "2.0.0",
            "author": "William Kamp",
            "email": "will@kamputed.com",
            "date": "2023-06-20",
            "registers": {
                "number_of_ports": {
                    "name": "Number of Ports",
                    "desc": "Actual numbers of ports as configured in the firmware.",
                    "addressOffset": "0x0",
                    "fields": {
                        "number_of_inputs": {
                            "name": "Number of Input Ports",
                            "desc": "Number of input ports configured in the firmware for this instance.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 8
                        },
                        "number_of_outputs": {
                            "name": "Number of Output Ports",
                            "desc": "Number of output ports configured in the firmware for this instance.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 8,
                            "bitWidth": 8
                        }
                    }
                },
                "input_sel": {
                    "name": "Input Select",
                    "desc": "Select the input source for this output port. Output port according to the register's index (address).",
                    "addressOffset": "0x04",
                    "repeat": 31,
                    "fields": {
                        "input_select": {
                            "name": "input select",
                            "desc": [
                                "Select input from [0 : number_of_inputs - 1] as the source for this output port.",
                                "To disconnect this port write the value of number_of_inputs.",
                                "If this output port does not exist, i.e. index >= number_of_outputs, will always read 0xFF."
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 8,
                            "reset": "0xFF"
                        }
                    }
                }
            }
        },
        "wideband_input_buffer.wideband_input_buffer_reg_pkg": {
            "name": "Wideband Input Buffer",
            "mnemonic": "wideband_input_buffer",
            "desc": "FW IP Wideband Input Buffer",
            "version": "1.2.0",
            "author": "Richard Hein",
            "email": "richard.hein@mda.space",
            "date": "2022-08-19",
            "registers": {
                "receive_enable_register": {
                    "name": "Receive Enable Register",
                    "addressOffset": "0x00",
                    "desc": "",
                    "fields": {
                        "receive_enable": {
                            "name": "Receive Enable",
                            "desc": "When set sample packets are passed downstream starting with the first PPS packet received. When cleared samples are no longer moved into streams starting on the next PPS received. The intent of this control is to be able to cleanly enable downstream processing on system reset. This control bit enables the reception of packets received from the dish 100GbE input. When not enabled meta-frame data will not be latched.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "transport_link_fault_register": {
                    "name": "Transport Link Fault Register",
                    "desc": "The status of dish sample packets received over the 100GbE link. Normally all '0's to indicate no fault conditions. Any faults are latched high until cleared by writing a '1' to the corresponding register bit.",
                    "addressOffset": "0x04",
                    "fields": {
                        "packet_error": {
                            "name": "Packet Error",
                            "desc": "Packets tagged as errored by the Ethernet MAC. Errored packets are considered and treated the same as dropped packets with the WIB generating and inserting invalid tagged streams to maintain the expected stream flow for downstream processing. This error would also be flagged in the 100GbE MAC but also provided here for integration test. The 32 bit Packet Error Count Register is provided for monitoring. Clearing this bit by writing a '1' also clears the Packet Error Count Register.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "packet_drop": {
                            "name": "Packet Drop",
                            "desc": "Packet drop is detected when the packet number in the meta-frame doesn't match the expected packet number. Dropped packets may result from severely corrupted packets or complete link failure. The WIB will auto generate dropped packet samples for downstream processing where all samples have a value of zero and tagged as invalid. A 32 bit Packet Drop Count Register is provided for monitoring. Clearing this bit by writing a '1' also clears the Packet Drop Count Register.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "link_failure": {
                            "name": "Link Failure",
                            "desc": "Set when no packets are received. Flagged when the buffer runs empty. A 32 bit Loss of Signal Seconds Register indicating the number of seconds of link failure is provided for monitoring. Clearing this bit by writing a '1' also clears the Loss of Signal Seconds Register.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "buffer_overflow": {
                            "name": "Buffer Overflow",
                            "desc": "Indicates the buffer has overflowed due to a higher than expected sample rate. Normally this should not happen as the buffer write bandwidth is lower than the read bandwidth. An overflow would indicate a system configuration problem.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "firmware_band_register": {
                    "name": "Firmware Band Register",
                    "addressOffset": "0x08",
                    "desc": "",
                    "fields": {
                        "firmware_band": {
                            "name": "Firmware Band",
                            "desc": "Indicates the band the FPGA firmware is configured to. Value between 3 and 5. There are 3 firmware varients, one for each of the three sample bit width sizes. 3 = bands 1 to 3, 4 = band 4, 5 = bands 5a/5b. Provided as a check to ensure the correct firmware band variant has been loaded.",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "stream_rate_register": {
                    "name": "Stream Rate Register",
                    "addressOffset": "0x0C",
                    "desc": "",
                    "fields": {
                        "stream_rate": {
                            "name": "Stream Rate",
                            "desc": [
                                "Expected stream rate in polyphase streams/second. Number of expected samples per second divided by N where N is the number of output streams. For bands 1 to 3 N=18, band 4 N=27 and band 5 N=54. This is compared with the actual number of samples recieved. Any mismatch is flagged as a transport error. The divide by N simplifies and reduces resources by aligning the check counter to the N output stream channels per clock cycle.\n",
                                "The value is calculated by software using the formulas below. k is an integer value in the range of 1 to 2222 corresponding to the sampling frequency offsets.\n",
                                "+------+----------------------------------+------------------------------+",
                                "| Band | Formula                          | Range                        |",
                                "+======+==================================+==============================+",
                                "|  1   | (3.96e9 + k * 1800) / 18         | = 220,000,100 to 220,222,200 |",
                                "+------+----------------------------------+------------------------------+",
                                "|  2   | (3.96e9 + k * 1800) / 18         | = 220,000,100 to 220,222,200 |",
                                "+------+----------------------------------+------------------------------+",
                                "|  3   | (3.168e9 + k * 1800 * 0.8) / 18  | = 176,000,080 to 176,177,760 |",
                                "+------+----------------------------------+------------------------------+",
                                "|  4   | (5.94e9 + k * 1800 * 1.5) / 27   | = 220,000,100 to 220,222,200 |",
                                "+------+----------------------------------+------------------------------+",
                                "|  5   | (5.94e9 + k * 1800 * 1.5) / 54   | = 220,000,100 to 220,222,200 |",
                                "+------+----------------------------------+------------------------------+"
                            ],
                            "bitOffset": 0,
                            "bitWidth": 28,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "packet_rate_register": {
                    "name": "Packet Rate Register",
                    "addressOffset": "0x10",
                    "desc": "",
                    "fields": {
                        "packet_rate": {
                            "name": "Packet Rate",
                            "desc": [
                                "This value is used to auto insert invalid samples for lost packets. The value is calculated so as to generate lost packets at the required rate. The value corresponds to the number of 450MHz clock cycles per packet. The register value is used as a base reference which is adjusted to synchronize to the actual input packet rate. Setting this value low will cause a buffer underflow which triggers the Link Failure Fault. Setting the value high will cause a buffer overflow which triggers the Buffer Overflow Fault.\n",
                                "+------+-------+",
                                "| Band | Value |",
                                "+======+=======+",
                                "|  1   | 295   |",
                                "+------+-------+",
                                "|  2   | 295   |",
                                "+------+-------+",
                                "|  3   | 369   |",
                                "+------+-------+",
                                "|  4   | 300   |",
                                "+------+-------+",
                                "|  5   | 300   |",
                                "+------+-------+"
                            ],
                            "bitOffset": 0,
                            "bitWidth": 9,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "noise_diode_transition_holdoff_count_register": {
                    "name": "Noise Diode State Holdoff Register",
                    "addressOffset": "0x14",
                    "desc": "",
                    "fields": {
                        "noise_diode_transition_holdoff_count": {
                            "name": "Noise Diode State Holdoff",
                            "desc": "Maximum noise diode state transition time used In the advent of packet loss/corruption during a state transition. This will correspond to a configurable number of sample frames up to 2^16 = 65535 frames.",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "packet_error_count_register": {
                    "name": "Packet Error Count Register",
                    "addressOffset": "0x18",
                    "desc": "",
                    "fields": {
                        "packet_error_count": {
                            "name": "Packet Error Count",
                            "desc": "Number of packets flagged as errored by the 100GbE MAC. Cleared by writing '1' to the Packet Error Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "packet_drop_count_register": {
                    "name": "Packet Drop Count Register",
                    "addressOffset": "0x1C",
                    "desc": "",
                    "fields": {
                        "packet_drop_count": {
                            "name": "Packet Drop Count",
                            "desc": "Count of the number of packets missed. Cleared by writing '1' to the Packet Drop Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "los_seconds_register": {
                    "name": "Loss of Signal Seconds Register.",
                    "addressOffset": "0x20",
                    "desc": "",
                    "fields": {
                        "los_seconds": {
                            "name": "LOS Seconds",
                            "desc": "The number of seconds a link failure has been detected. The value only increments by one for any number of link failures over a one second interval. Cleared by writing '1' to the Link Failure Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_ethertype_register": {
                    "name": "Meta Frame Ethertype Register",
                    "addressOffset": "0x24",
                    "desc": "",
                    "fields": {
                        "meta_ethertype": {
                            "name": "Meta Ethertype",
                            "desc": "Should be 0xFEED for all packets received. Not actively monitored by the WIB.",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_dish_band_id_register": {
                    "name": "Meta Frame Dish ID and Band ID Register",
                    "addressOffset": "0x28",
                    "desc": "",
                    "fields": {
                        "meta_dish_id": {
                            "name": "Meta Dish_ID",
                            "desc": "16-bit unsigned integer.",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        },
                        "meta_band_id": {
                            "name": "Meta Band ID",
                            "desc": "8-bit unsigned integer assigned to values over the range of decimal 1-6 for Bands 1-4, 5a, and 5b respectively.",
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_utc_time_code_register": {
                    "name": "Meta Frame UTC Time Code Register",
                    "addressOffset": "0x2C",
                    "desc": "",
                    "fields": {
                        "meta_utc_time_code": {
                            "name": "Meta UTC Time Code",
                            "desc": "Not actively used by the WIB to detect faults. Monitoring is provided by the WIB for integration test and as a check that the link and time code is operating correctly.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_transport_sample_rate_lsw_register": {
                    "name": "Meta Frame Transport Sample Rate Register (LSW)",
                    "addressOffset": "0x30",
                    "desc": "",
                    "fields": {
                        "meta_transport_sample_rate_lsw": {
                            "name": "Meta Transport Sample Rate (LSW)",
                            "desc": "The sample rate in samples per second. Not actively used by the WIB to detect faults. Monitoring is provided by the WIB for software to check for configuration faults. The Expected Sample Rate register configured by software is checked against the actual number of received samples for fault detection.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_transport_sample_rate_msw_register": {
                    "name": "Meta Frame Transport Sample Rate Register (MSW)",
                    "addressOffset": "0x34",
                    "desc": "",
                    "fields": {
                        "meta_transport_sample_rate_msw": {
                            "name": "Meta Transport Sample Rate (MSW)",
                            "desc": "See Meta Transport Sample Rate (LSW) for description",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_hardware_source_id_lsw_register": {
                    "name": "Meta Frame Hardware Source ID Register (LSW)",
                    "addressOffset": "0x38",
                    "desc": "",
                    "fields": {
                        "meta_hardware_source_id_lsw": {
                            "name": "Meta Hardware Source ID (LSW)",
                            "desc": "Not currently defined or used by WIB. The WIB still latches this field for potential future use.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "meta_hardware_source_id_msw_register": {
                    "name": "Meta Frame Hardware Source ID Register (MSW)",
                    "addressOffset": "0x3C",
                    "desc": "",
                    "fields": {
                        "meta_hardware_source_id_msw": {
                            "name": "Meta Hardware Source ID (MSW)",
                            "desc": "See Meta Hardware Source ID (LSW) for description",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "rx_packet_rate_register": {
                    "name": "Received Packet Rate Register",
                    "addressOffset": "0x40",
                    "desc": "",
                    "fields": {
                        "rx_packet_rate": {
                            "name": "Recieved Packet Rate",
                            "desc": "Counts the number of packets received per second. The value set in the Packet Rate Register should equal 450e6 (the 450MHz system clock) divided by the value in this register rounded down to the nearest integer.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "rx_sample_rate_register": {
                    "name": "Received Sample Rate Register",
                    "addressOffset": "0x44",
                    "desc": "",
                    "fields": {
                        "rx_sample_rate": {
                            "name": "Received Sample Rate",
                            "desc": "Counts the number of sample pairs received per PPS interval. The rate is accumulated from the number of samples indicated in the packet meta frame. The rate should equal the rate set in the Stream Rate Register muliplied by the number of output streams. The value will wrap for bands 4/5 by 2^32.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                }
            }
        },
        "packet_stream_repair.packet_stream_repair_reg_pkg": {
            "name": "Packet Stream Repair",
            "mnemonic": "packet_stream_repair",
            "desc": "FW IP Packet Stream Repair",
            "version": "1.1.0",
            "author": "Richard Hein",
            "email": "richard.hein@mda.space",
            "date": "2022-03-24",
            "registers": {
                "transport_link_fault_register": {
                    "name": "SLIM Link Fault Register",
                    "desc": "The status of SLIM packets received. Normally all '0's to indicate no fault conditions. Any faults are latched high until cleared by writing a '1' to the corresponding register bit.",
                    "addressOffset": "0x04",
                    "fields": {
                        "packet_error": {
                            "name": "Packet Error",
                            "desc": "Packets tagged as errored by the SLIM receiver or packets received that are not 512 words in length. Errored packets are considered and treated the same as lost packets with the PSR generating and inserting invalid tagged packets to maintain the expected packet rate for downstream processing. The 32 bit Packet Error Count Register is provided for monitoring. Clearing this bit by writing a '1' also clears the Packet Error Count Register.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "packet_loss": {
                            "name": "Packet Loss",
                            "desc": "Packet loss is detected when the SLIM packet sequence number in the meta-frame doesn't match the expected packet sequence number. Lost packets may result from severely corrupted packets or complete link failure. The PSR will auto generate packet slice data for downstream processing where all data has a most-negative data pattern of 0x80008000 and tagged as invalid. A 32 bit Packet Loss Count Register is provided for monitoring. Clearing this bit by writing a '1' also clears the Packet Loss Count Register.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "link_failure": {
                            "name": "Link Failure",
                            "desc": "Set when no packets are being received. Flagged when a set number of lost packets have been detected. At initial release this will be 16 packets. A 32 bit Loss of Signal Seconds Register indicating the number of seconds of link failure is provided for monitoring. Clearing this bit by writing a '1' also clears the Loss of Signal Seconds Register.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        },
                        "short_packet_error": {
                            "name": "Short Packet Error",
                            "desc": "Packets received that are less than the expected length. The 32 bit Short Packet Error Count Register is provided for monitoring. Clearing this bit by writing a '1' (rc_w1) also clears the Short Packet Error Count Register.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "packet_rate_register": {
                    "name": "Packet Rate Register",
                    "addressOffset": "0x10",
                    "desc": "",
                    "fields": {
                        "packet_rate": {
                            "name": "Packet Rate",
                            "desc": [
                                "This value is used to auto generate invalid slice data packets for lost packets. The value is calculated so as to generate lost SLIM packets at the required rate. The value corresponds to the number of 450MHz clock cycles per expected packet interarrival time. The calculated value for the expected packet interarrival time should be rounded down to the next integer value. At initial release the value should be set to 521 for the expected packet interarrival of 521.11 clock cycles."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 521,
                            "access": "rw"
                        }
                    }
                },
                "packet_error_count_register": {
                    "name": "Packet Error Count Register",
                    "addressOffset": "0x18",
                    "desc": "",
                    "fields": {
                        "packet_error_count": {
                            "name": "Packet Error Count",
                            "desc": "Number of packets flagged as errored received from the SLIM interface or are not 512 words in length. Cleared by writing '1' to the Packet Error Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "packet_loss_count_register": {
                    "name": "Packet Loss Count Register",
                    "addressOffset": "0x1C",
                    "desc": "",
                    "fields": {
                        "packet_loss_count": {
                            "name": "Packet Loss Count",
                            "desc": "Count of the number of packets missed where the packet sequence number does not match the expected packet sequence number or no packets are received within the defined time interval threshold. Cleared by writing '1' to the Packet Loss Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "los_seconds_register": {
                    "name": "Loss of Signal Seconds Register.",
                    "addressOffset": "0x20",
                    "desc": "",
                    "fields": {
                        "los_seconds": {
                            "name": "LOS Seconds",
                            "desc": "The number of seconds a link failure has been detected where more than 16 consecutive packets have been lost. The value only increments by one for any number of link failures over a one second interval. Cleared by writing '1' to the Link Failure Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "rx_packet_rate_register": {
                    "name": "Received Packet Rate Register",
                    "addressOffset": "0x24",
                    "desc": "",
                    "fields": {
                        "rx_packet_rate": {
                            "name": "Received Packet Rate",
                            "desc": "Counts the number of packets received per second. The value set in the Packet Rate Register should equal 450e6 (the 450MHz system clock) divided by the value in this register rounded down to the nearest integer.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "short_packet_error_count_register": {
                    "name": "Short Packet Error Count Register",
                    "addressOffset": "0x28",
                    "desc": "",
                    "fields": {
                        "short_packet_error_count": {
                            "name": "Short Packet Error Count",
                            "desc": "Number of short packets that are less than the expected length. Cleared by writing '1' to the Short Packet Error Fault register bit.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                }
            }
        },
        "resampler_delay_tracker.resampler_delay_tracker_reg_pkg": {
            "name": "Resampler Delay Tracker",
            "mnemonic": "resampler_delay_tracker",
            "desc": [
                "The resampler delay tracker",
                "1. Applies first order delay models at intervals (nominally every 10ms, but up to 1 second).",
                "2. Resamples the delay corrected data to a output sample rate.",
                "3. These functions are combined into the same interpolation."
            ],
            "version": "1.3.0",
            "date": "2023-07-12",
            "author": "William Kamp",
            "email": "william.kamp@nrc-cnrc.gc.ca",
            "registers": {
                "ctrl_status": {
                    "name": "Resampler Delay Tracker Control and Status",
                    "desc": "Status and control information.",
                    "addressOffset": "0x00",
                    "width": 32,
                    "fields": {
                        "input_buffer_depth": {
                            "name": "Input Sample Buffer Depth",
                            "desc": "The depth of the input buffer of samples. The RDT module attempts to keep the buffer half full. This depth effectively sets the maximum jump in delay that can be achieved, being less than half the depth times the input-rate sample time.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 16,
                            "bitWidth": 16
                        },
                        "fodm_buffer_depth": {
                            "name": "First Order Delay Model Buffer Depth",
                            "desc": "The depth of the buffer. The read pointer will be between 0 (inclusive) and this value (exclusive). It is a static value derived from the configuration of the firmware.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 4,
                            "bitWidth": 12
                        },
                        "timestamp_gap_detected": {
                            "name": "Timestamp gap detection",
                            "desc": [
                                "Set when a timestamp gap is detected. A gap is flagged when the timestamp increments by more than 1 second.",
                                "When a timestamp gap is detected the run register bit is cleared and the resampler processing stops.",
                                "Writing '1' to this register bit clears the register bit to '0'."
                            ],
                            "ftype": "boolean",
                            "access": "rw",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "reset": 1
                        },
                        "enable_phase_correction_dithering": {
                            "name": "Enable Phase Correction Dithering.",
                            "desc": [
                                "Write '1' to enable, Write '0' to disable.",
                                "When enabled, dithering is applied the phase correction. When the fractional phase is truncated to a fixed number of bits then it is rounded up with a probability according to the least significant bits that are truncated.",
                                "Therefore, on average a greater resolution is achieved, without introducing harmonics.",
                                "Read '1' then dithering is enabled. Read '0' and dithering is disabled or not available."
                            ],
                            "ftype": "boolean",
                            "access": "rw",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "reset": 1
                        },
                        "enable_resampler_dithering": {
                            "name": "Enable Resampler and Delay Tracker Dithering.",
                            "desc": [
                                "Write '1' to enable, Write '0' to disable.",
                                "When enabled, dithering is applied the filter coefficient selection. When the fractional sample time is truncated to a fixed number of bits (10) then it is rounded up with a probability according to the least significant bits that are truncated.",
                                "Therefore, on average a greater resolution is achieved, without introducing harmonics.",
                                "Read '1' then dithering is enabled. Read '0' and dithering is disabled or not available."
                            ],
                            "ftype": "boolean",
                            "access": "rw",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "reset": 1
                        },
                        "run": {
                            "name": "Run",
                            "desc": [
                                "Write 1 to start the resampler delay tracker generating output when the input finds the correct timestamp for the first index in the delay models. Write 0 to stop and reset.",
                                "Output will actually start being generated when the input timestamp specified in the FODM is present in the input buffer."
                            ],
                            "ftype": "boolean",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 1
                        }
                    }
                },
                "fodm_read_pointers": {
                    "name": "First Order Delay Model Buffer Read Pointers",
                    "desc": [
                        "First Order Delay Model read pointers between 0 and `fodm_buffer_depth - 1`.",
                        "Software monitors this register and refills the circular buffer.",
                        "One field for each polarisation. Polarisation X at index 0, Polarisation Y at index 1 of this array."
                    ],
                    "addressOffset": "0x04",
                    "width": 32,
                    "fields": {
                        "fodm_read_pointer": {
                            "name": "First Order Delay Model Buffer Read Pointer",
                            "desc": [
                                "FODM buffer read pointers, one for each polarisation. The firmware will consume models from the corresponding buffer in order.",
                                "This value is the index of the next model to be used by firmware.",
                                "Software shall maintain the corresponding write-pointer. to create a circular buffer.",
                                "Software shall maintain the buffer in a sufficiently full state such that the firmware does not under-run the buffer, i.e. this fodm entry is written prior to it being used.",
                                "Software shall not over-run the buffer by writing to a FODM index at or past this value, except when `run = '0'`",
                                "At reset (`run = '0'`), the value will be zero."
                            ],
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "repeat": 2
                        }
                    }
                },
                "random_seed_x": {
                    "name": "Random Seed Polarisation X",
                    "desc": "Seed to initialise this instance's random number generators.",
                    "addressOffset": "0x08",
                    "repeat": 1,
                    "width": 32,
                    "fields": {
                        "dither_seed_x": {
                            "name": "Dithering Seed for Polarisation X",
                            "desc": "Seed to initialise the resampler's dithering for polarisation X. Random number generators are loaded with the seed when `run` is '0'.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": 0,
                            "repeat": 1
                        }
                    }
                },
                "random_seed_y": {
                    "name": "Random Seed Polarisation Y",
                    "desc": "Seed to initialise this instance's random number generators.",
                    "addressOffset": "0x0C",
                    "repeat": 1,
                    "width": 32,
                    "fields": {
                        "dither_seed_y": {
                            "name": "Dithering Seed for Polarisation Y",
                            "desc": "Seed to initialise the resampler's dithering for polarisation Y. Random number generators are loaded with the seed when `run` is '0'.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": 0,
                            "repeat": 1
                        }
                    }
                },
                "current_time": {
                    "name": "Current Time",
                    "desc": "The current time according to the IP block input.",
                    "addressOffset": "0x10",
                    "repeat": 1,
                    "width": 64,
                    "fields": {
                        "input_timestamp": {
                            "name": "Input Timestamp",
                            "desc": [
                                "Read the latest timestamp seen at the input.",
                                "The timestamp is in units of samples since the epoch, at the input sample rate.",
                                "Take care when reading this register if no data in flowing, consecutive reads should return increasing values."
                            ],
                            "ftype": "integer",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "ro",
                            "reset": 0,
                            "repeat": 1
                        }
                    }
                },
                "error_status": {
                    "name": "Error Status",
                    "desc": "Register to report error conditions.",
                    "addressOffset": "0x18",
                    "repeat": 1,
                    "width": 32,
                    "fields": {
                        "output_fifo_overflow_polx": {
                            "name": "Output FIFO overflow polarisation X",
                            "desc": [
                                "'1' indicates that an overflow condition was detected on the output fifo.",
                                "This may indicate that the other polarisation processing is being slow.",
                                "This is a fatal condition.",
                                "To recover stop and restart. This bit will be reset when `run` = False."
                            ],
                            "ftype": "boolean",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "access": "ro",
                            "reset": 0,
                            "repeat": 1
                        },
                        "output_fifo_overflow_poly": {
                            "name": "Output FIFO overflow polarisation Y",
                            "desc": [
                                "'1' indicates that an overflow condition was detected on the output fifo.",
                                "This may indicate that the other polarisation processing is being slow.",
                                "This is a fatal condition.",
                                "To recover stop and restart. This bit will be reset when `run` = False."
                            ],
                            "ftype": "boolean",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "access": "ro",
                            "reset": 0,
                            "repeat": 1
                        },
                        "input_buffer_overflowed": {
                            "name": "Input Buffer Overflowed",
                            "desc": [
                                "'1' indicates that an overflow condition was detected on the input buffer.",
                                "This is a fatal condition.",
                                "To recover stop and restart. This bit will be reset when `run` = False."
                            ],
                            "ftype": "boolean",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "access": "ro",
                            "reset": 0,
                            "repeat": 1
                        }
                    }
                }
            }
        },
        "resampler_delay_tracker.first_order_delay_models_reg_pkg": {
            "name": "First Order Delay Models (FODMs) register set.",
            "mnemonic": "first_order_delay_models",
            "desc": [
                "First order delay models (FODMs) are short linear segments derived from a higher order polynomial delay model that is valid over a longer time period.",
                "This is a circular buffer of FODMs that the firmware applies to the input signal to generate a delayed and resampled output signal.",
                "As the firmware consumes FODMs from the buffer the software must monitor (poll) the read_pointer register in the resampler_delay_tracker register set, and refill this circular buffer with new FODMs.",
                "Note, that as a RAM type register set, all values are written to the FODM RAM only when the last register in the set is written. The values read back (at all indices) reflect the last values written (not those at that index).",
                "",
                "A FODM relates the input timestamp to an output timestamp. Timestamps are measured in samples since an (arbitrary) epoch. At the time t0 the FODM becomes valid.",
                "The output sample at `t_0` is interpolated from input samples at time `first_input_timestamp + delay_constant`.",
                "The output sample at `t_1` is interpolated from input samples at time `first_input_timestamp + delay_constant + 1 * delay_linear`.",
                "The output sample at `t_n` is interpolated from input samples at time `first_input_timestamp + delay_constant + n * delay_linear`.",
                "",
                "The `delay_linear` parameter should be approximately one.",
                "If delay_linear is less than 1, then there will be more output samples than input samples, effectively up-sampling the input signal.",
                "If delay_linear is greater than 1, then there will be fewer output samples than input samples, effectively down-sampling the input signal.",
                "This provides the 'resampling' functionality in addition to the delay tracking.",
                "",
                "A linear phase rotation can also be applied to the output samples to correct for frequency shifts.",
                "At output sample `t_0` a phase rotation of `phase_constant` is applied.",
                "At output sample `t_1` a phase rotation of `phase_constant + 1 * phase_linear` is applied.",
                "At output sample `t_n` a phase rotation of `phase_constant + n * phase_linear` is applied."
            ],
            "author": "William Kamp",
            "email": "william.kamp@nrc-cnrc.gc.ca",
            "version": "1.0.0",
            "ram": true,
            "repeat": 512,
            "registers": {
                "start": {
                    "name": "FODM Start Condition",
                    "desc": "Configure the first input timestamp.",
                    "addressOffset": "0x00",
                    "width": 64,
                    "fields": {
                        "first_input_timestamp": {
                            "name": "First Input Timestamp",
                            "desc": "The input timestamp that shall be used to generate the first output sample for this FODM. Timesamp value is in input-rate samples since the epoch.",
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 64
                        }
                    }
                },
                "fodm_constant_delay": {
                    "name": "FODM Constant Delay",
                    "desc": "Configure the constant delay applied for the FODM.",
                    "addressOffset": "0x08",
                    "width": 32,
                    "fields": {
                        "delay_constant": {
                            "name": "Delay Constant Fraction",
                            "desc": "The constant fractional delay component of the FODM. The unit is 'input-rate samples'. This is appended to the first_input_timestamp.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "fodm_linear_delay": {
                    "name": "FODM Linear Delay and Resampling Ratio",
                    "desc": "Controls the resampling rate, which depends on the input sample rate (Ri) and the common output sample rate (Ro), and the rate of change of delay (dD).",
                    "addressOffset": "0x0C",
                    "width": 32,
                    "fields": {
                        "delay_linear": {
                            "name": "Linear Delay and Resampling Ratio",
                            "desc": "This sets the resampling rate to convert samples between the input and output sample rates, and applies a linear change in delay from the FODM. It is effectively the increment in input-rate samples per output sample. This value should be set to ((Ri / Ro) + dD) * 2**31. It is expected that this value is close to 1. If it is > 1 then we are down-sampling, if it is < 1.0 then we are up-sampling. Unit is 'input samples'",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": "0x40000000"
                        }
                    }
                },
                "fodm_constant_phase": {
                    "name": "FODM Constant phase",
                    "desc": "Controls the Phase Correction Module, configure the constant phase applied for the FODM.",
                    "addressOffset": "0x10",
                    "width": 32,
                    "fields": {
                        "phase_constant": {
                            "name": "Constant Phase",
                            "desc": "The constant phase component of the FODM. This is a value between [-0.5, 0.5) representing a phase angle corresponding to the range [-pi and pi) radians. Scale be 2**32.",
                            "ftype": "integer",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "fodm_linear_phase": {
                    "name": "FODM Linear Phase Correction",
                    "desc": "Controls the Phase Correction Module, configure the rate of change of phase (dP) for the FODM.",
                    "addressOffset": "0x14",
                    "width": 32,
                    "fields": {
                        "phase_linear": {
                            "name": "Linear Phase",
                            "desc": "The change in phase per output-rate sample. This is a value between (-0.5, 0.5) representing a phase angle increment corresponding to the range (-pi and pi) radians, Scale be 2**32.",
                            "ftype": "integer",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "access": "rw",
                            "reset": 0
                        }
                    }
                },
                "fodm_validity_period": {
                    "name": "FODM Validity Period",
                    "desc": "Configure the length of the FODM.",
                    "addressOffset": "0x18",
                    "width": 32,
                    "fields": {
                        "validity_period": {
                            "name": "Validity Period",
                            "desc": "The number of output samples that should be output for this FODM less 1. The next FODM will be loaded after this many samples.",
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "PPS": {
                    "name": "PPS",
                    "desc": "Configure output PPS marking.",
                    "addressOffset": "0x1C",
                    "width": 32,
                    "fields": {
                        "output_PPS": {
                            "name": "PPS",
                            "desc": [
                                "The lower bits of the output timestamp in this FODM that should be flagged with a PPS marker.",
                                "Typically, `output_timestamp` when `output_timestamp mod output_rate = 0`.",
                                "Set to a value greater than `(first_output_timestamp + validity)` to indicate no samples in this FODM should be marked with a PPS."
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "first_output_timestamp": {
                    "name": "First Output Timestamp",
                    "desc": "The timestamp of the first output sample for this FODM.",
                    "addressOffset": "0x20",
                    "repeat": 1,
                    "width": 64,
                    "fields": {
                        "first_output_timestamp": {
                            "name": "First Output Sample Timestamp.",
                            "desc": "The timestamp of the first output sample for this FODM in output samples since the epoch.",
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "access": "rw",
                            "reset": 0
                        }
                    }
                }
            }
        },
        "pstc_ch4k.pstc_ch4k_reg_pkg": {
            "name": "Pulsar Timing (PST) Channelizer - 4,096 Channel Version",
            "desc": [
                "The firmware block for the 'Pulsar Timing (PST) Channelizer - 4,096 Channel Version'.",
                "The configuration registers set the signal level of the PST Channels (ICs)",
                "before the final quantization."
            ],
            "mnemonic": "pstc_ch4k",
            "version": "1.0.0",
            "author": "T. Gunaratne",
            "email": "Thushara.Gunaratne@nrc-cnrc.gc.ca",
            "date": "2021-01-18",
            "referenceDocumentTitle": "None",
            "referenceDocument": "None",
            "registers": {
                "config_pstc_sft_scl": {
                    "name": "Config_PSTC_Sft_Scl",
                    "addressOffset": "0x0",
                    "fields": {
                        "pstc_sft": {
                            "name": "PSTC_SFT",
                            "desc": [
                                "4-bit unsigned integer 'SFT', specifying the the magnification factor",
                                "applied to magnitudes of each PST Channel (PSTC).",
                                "The magnification factor is applied as the power of two of 'SFT'.",
                                "Entries 0-4095 correspond to polarization 0, while entries 4096-8191",
                                "correspond to polarization 1."
                            ],
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": "0x6",
                            "access": "rw"
                        },
                        "pstc_scl": {
                            "name": "PSTC_SCL",
                            "desc": [
                                "16-bit signed integer 'SCL', specifying the the scaling factor",
                                "applied to magnitudes of each PST Channel (PSTC).",
                                "The scaling factor is applied as the fraction of 'SCL'/65536.",
                                "Entries 0-4095 correspond to polarization 0, while entries 4096-8191",
                                "correspond to polarization 1."
                            ],
                            "ftype": "natural",
                            "bitOffset": 4,
                            "bitWidth": 16,
                            "reset": "0xffff",
                            "access": "rw"
                        }
                    }
                }
            },
            "ram": true,
            "repeat": 8192,
            "ramAddress": 0
        },
        "tst_vector_gen.tst_vector_gen_reg_pkg": {
            "name": "Test Vector Generator Register Set",
            "mnemonic": "tst_vector_gen",
            "desc": [
                "The tst_vector_gen (TVG) generates predetermined test streams.",
                "The streams could be used to confirm and test the behaviour of the downstream IP blocks in the signal chain.",
                "This IP block could be included in the design using conditional generate statements in the top level.",
                "One of the main reasons to include this block is to generate a realistic model of the incoming/outgoing data on the hardware during the development or post deployment.",
                "The block generates a full frame of data streams, i.e. 3700 channels of time samples, at a rate of 61440 frames/second.",
                "Since the sample rate is 333.33MHz, it generates 3700 samples over as many clock cycles, then waits 1725 more, to reach a total of 333.333e6/61440 = 5425 clock cycles before beginning the process of generation over again.",
                "The samples consist of complex data, meaning that each has a real and imaginary component, and these are represented as 17 bit signed fixed point numbers.",
                "The real and imaginary components of the sample values begin at the 'sample start' value written to those registers.",
                "On each clock cycle during generation, each component of the complex sample value is its previous value incremented by the 'sample increment value' of that component, from the 'sample start value' on.",
                "e.g. if sample_start_value_re = 0, sample_start_value_im = 0, sample_inc_value_re = 0.0625, sample_inc_value_im = 0.125",
                "the sample values output by that block are {re=0.0, im=0.0}, {0.0625, 0.125}, {0.125, 0.250}, {0.1875, 0.375}, {0.250, 0.500}, etc.",
                "These complex samples are packed into 'complex stream' data types, which also carry the timestamp of the sample and other single-bit indicators such as the 'polarization' of the data, the 'PPS' flag, the end-of-frame flag, etc.",
                "These complex streams are ultimately what are generated and output by each test vector generator, to be ingested by the other IP blocks.",
                "A chain of TVG blocks can be instantiated in the top level with generate statements. Use as many blocks as the number of 'antennas' to be simulated.",
                "Each block can be enabled or disabled by its 'enable' input port.",
                "When a TVG block is disabled, it is in passthrough mode, and only outputs the data that arrives on its input ports.",
                "For control purposes, the zero'th TVG instance in the chain acts as the master, while the others act as slaves.",
                "To use this IP: keep the start bit LOW for the very first block in the chain (the 'master'). Set enable HIGH for each desired block. Set the delay, start value and increment registers for each block.",
                "Finally, start the vector generation by bringing the 'start' register HIGH for the master block, and all blocks will begin generation at the same time."
            ],
            "author": "Nick Lamb",
            "email": "nick.lamb@mda.space",
            "date": "2024-04-22",
            "version": "1.0.1",
            "registers": {
                "sample_start_value_im": {
                    "name": "imaginary sample start value",
                    "desc": "imaginary component of first sample value",
                    "addressOffset": "0x00",
                    "width": 32,
                    "fields": {
                        "start_im": {
                            "name": "sample start imaginary value",
                            "desc": "Ramp up/down from this value.",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 18,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "sample_start_value_re": {
                    "name": "real sample start value",
                    "desc": "real component of first sample value",
                    "addressOffset": "0x04",
                    "width": 32,
                    "fields": {
                        "start_re": {
                            "name": "sample start real value",
                            "desc": "Ramp up/down from this value.",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 18,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "sample_inc_value_im": {
                    "name": "imaginary sample increment value",
                    "desc": "The imaginary component of the sample is incremented by this value. Can be negative",
                    "addressOffset": "0x08",
                    "width": 32,
                    "fields": {
                        "inc_im": {
                            "name": "sample increment value",
                            "desc": "Increment value of this component of the sample value.",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 18,
                            "bitOffset": 0,
                            "reset": 1
                        }
                    }
                },
                "sample_inc_value_re": {
                    "name": "real sample increment value",
                    "desc": "The real component of the sample is incremented by this value. Can be negative",
                    "addressOffset": "0x0C",
                    "width": 32,
                    "fields": {
                        "inc_re": {
                            "name": "sample increment value",
                            "desc": "Increment value of this component of the sample value.",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 18,
                            "bitOffset": 0,
                            "reset": 1
                        }
                    }
                },
                "start_delay": {
                    "name": "stream start delay",
                    "desc": "delays test vector generation by a certain amount. Unit is the IP block's clock cycles",
                    "addressOffset": "0x10",
                    "width": 32,
                    "fields": {
                        "start_delay": {
                            "name": "test vector start delay",
                            "desc": [
                                "the test vector stream is delayed by this value. Ip block clock is 450Mhz.",
                                "The delay is applied in mutiples of clock cycles"
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "configuration": {
                    "name": "configuration register",
                    "desc": "controls the various aspects of the test vector generation",
                    "addressOffset": "0x14",
                    "width": 32,
                    "fields": {
                        "enable": {
                            "name": "enable",
                            "desc": "setting this field to 1 (one) enables the output test stream",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "start": {
                    "name": "start register",
                    "desc": "test vector generation start register",
                    "addressOffset": "0x18",
                    "width": 32,
                    "fields": {
                        "start": {
                            "name": "start",
                            "desc": [
                                "setting this field to 1 (one) starts the stream generation"
                            ],
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "pst_sync_buffer.pst_sync_buffer_reg_pkg": {
            "name": "PST Sync Buffer Register Set",
            "mnemonic": "pst_sync_buffer",
            "version": "1.0.0",
            "desc": [
                "The sync buffer takes in all receptors' dual polarized, channelized complex streams and buffers them in the ddr memory.",
                "It then outputs synchronized, channelized, dual pol complex streams for a given timestamp.",
                "The sync buffer could be thought of as a large fifo with asynchronous writes and synchronous reads."
            ],
            "author": "Richard Hein",
            "email": "richard.hein@mda.space",
            "date": "2024-09-17",
            "registers": {
                "first_write_timestamp_register": {
                    "name": "First Write Timestamp Register",
                    "desc": "Shows the initial write timestamp per receptor after reset. Zero if no timesample has been received. Used by software to sync across Talons by selecting approriate point to start.",
                    "repeat": 8,
                    "width": 64,
                    "addressOffset": "0x00",
                    "fields": {
                        "first_write_timestamp": {
                            "name": "First write timestamp after reset. Zero if no timesample has been received yet.",
                            "desc": "initial write timestamp per receptor",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "write_timestamp_register": {
                    "name": "Write Timestamp Register",
                    "desc": "the write (input of sync buffer) snapshot",
                    "repeat": 8,
                    "width": 64,
                    "addressOffset": "0x40",
                    "fields": {
                        "write_timestamp": {
                            "name": "Write Timestamp",
                            "desc": "Snapshot write timestamp",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "read_timestamp_register": {
                    "name": "Read Timestamp Register",
                    "desc": "the read (output of sync buffer) snapshot",
                    "repeat": 1,
                    "width": 64,
                    "addressOffset": "0x80",
                    "fields": {
                        "read_timestamp": {
                            "name": "Read Timestamp",
                            "desc": "Snapshot read timestamp",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "snapshot_timestamps_register": {
                    "name": "Snapshot Timestamps Register",
                    "desc": "Snapshot the write and read timestamps for readout",
                    "addressOffset": "0x88",
                    "width": 32,
                    "fields": {
                        "snapshot_timestamps": {
                            "name": "Snapshot Timestamps",
                            "desc": "Snapshot the write and read timestamps for readout",
                            "ftype": "boolean",
                            "access": "wr",
                            "bitOffset": 0,
                            "bitWidth": 1
                        }
                    }
                },
                "reset_register": {
                    "name": "Reset Register",
                    "desc": "resets the sync buffer",
                    "width": 32,
                    "addressOffset": "0x8C",
                    "fields": {
                        "reset": {
                            "name": "Reset",
                            "desc": "Write a 1 (one) to reset the sync buffer",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 0,
                            "ftype": "boolean",
                            "access": "wr"
                        }
                    }
                },
                "start_read_timestamp_register": {
                    "name": "Start Read Timestamp Register",
                    "desc": "start read timestamp in number of fine channel samples since UTC",
                    "addressOffset": "0x90",
                    "width": 64,
                    "fields": {
                        "start_read_timestamp": {
                            "name": "Start Read Timestamp",
                            "desc": "Start read timestamp in number of fine channel samples since UTC",
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": "0x7FFFFFFFFFFFFFFF"
                        }
                    }
                },
                "read_threshold_register": {
                    "name": "Read Threshold Register",
                    "desc": "Read starts when one of more antennas have a depth above this threshold",
                    "addressOffset": "0x98",
                    "width": 32,
                    "fields": {
                        "read_threshold": {
                            "name": "Read Threshold",
                            "desc": "Read starts when one of more antennas have a depth above this threshold. Read threshold in number of fine channel samples",
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "read_timeout_threshold_register": {
                    "name": "Read Timeout Threshold Register",
                    "desc": "Threshold to raise set the read_timeout status, in number of 333MHz clocks",
                    "addressOffset": "0x9C",
                    "width": 32,
                    "fields": {
                        "read_timeout_threshold": {
                            "name": "Read Timeout Threshold",
                            "desc": "Threshold to raise set the read_timeout status, in number of 333MHz clocks. Setting must be greater than 61440 timesamples per second => 5425 clocks at 333MHz.",
                            "ftype": "natural",
                            "access": "rw",
                            "reset": 8192,
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "status_register": {
                    "name": "Status Register",
                    "desc": "status",
                    "addressOffset": "0xA0",
                    "width": 32,
                    "fields": {
                        "antenna_status": {
                            "name": "Antenna Status",
                            "desc": "Set when timesamples are actively being received.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 8
                        },
                        "under_run_status": {
                            "name": "Antenna Under-run",
                            "desc": "Set when read timestamp > write timestamp. Sticky bits. Clear by writing '1'",
                            "ftype": "natural",
                            "access": "rw",
                            "bitOffset": 8,
                            "bitWidth": 8
                        },
                        "over_run_status": {
                            "name": "receptor over run status",
                            "desc": [
                                "sticky bit.",
                                "overrun can happen if the dwell time is set too high or in case of a hw bug.",
                                "Write a 1 (one) to to clear this bit."
                            ],
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "reset": 0,
                            "access": "rw"
                        },
                        "read_status": {
                            "name": "Read Status",
                            "desc": "common read status, the stream timestamp on at least one of the streams has exceeded the starting tigger point and reads from buffer enabled.",
                            "ftype": "boolean",
                            "access": "ro",
                            "bitOffset": 24,
                            "bitWidth": 1
                        },
                        "read_timeout_status": {
                            "name": "Read Timeout Status",
                            "desc": "read timeout, raised once the read stopped for longer than the read timeout threshold, sticky bit ",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitOffset": 25,
                            "bitWidth": 1
                        }
                    }
                },
                "test_register": {
                    "name": "Test Register",
                    "desc": "Only used for developer testing",
                    "addressOffset": "0xA4",
                    "width": 32,
                    "fields": {
                        "test_bypass": {
                            "name": "Test Bypass",
                            "desc": "Set to bypass sync buffer. Inputs are passed directly through to outputs bypassing the sync buffer.",
                            "ftype": "boolean",
                            "access": "rw",
                            "reset": 0,
                            "bitOffset": 0,
                            "bitWidth": 1
                        }
                    }
                },
                "test_input_fifo_ovf_register": {
                    "name": "Test Input FIFO Overflow Register",
                    "desc": "Only used for developer testing",
                    "addressOffset": "0xA8",
                    "width": 32,
                    "fields": {
                        "test_input_fifo_ovf": {
                            "name": "Test Input FIFO Overflow",
                            "desc": "Set when input buffer overflows. Indicates failure of EMIF to maintain required throughput. Write '1' to clear",
                            "bitOffset": 0,
                            "bitWidth": 8,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "pst_beam_summer.pst_beam_summer_reg_pkg": {
            "name": "PST Beam Summer Register Set",
            "mnemonic": "pst_beam_summer",
            "desc": [
                "The beam summer adds dual polarized samples from each antenna for each channel per timestamp"
            ],
            "author": "Abtin Ghodoussi",
            "email": "abtin.ghodoussi@mda.space",
            "date": "2023-07-27",
            "version": "1.0.0",
            "registers": {
                "control": {
                    "name": "control register",
                    "desc": "This register controls the inclusion/exclusion of a given receptor in the beam",
                    "addressOffset": "0x0",
                    "fields": {
                        "enable": {
                            "name": "enable",
                            "desc": [
                                "bit[7:0]: Active high, put 0 (zero) to exclude the receptor from summing, put 1 (one) to include the receptor in the beam.",
                                "Bit index corresponds to the receptor index.",
                                "The default setting after reset is to include all receptors"
                            ],
                            "bitOffset": 0,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "reset": 1,
                            "access": "rw"
                        }
                    }
                },
                "status": {
                    "name": "status register",
                    "desc": "This register reports the status of the summer",
                    "addressOffset": "0x4",
                    "fields": {
                        "overflow": {
                            "name": "overflow",
                            "desc": [
                                "Sticky bit. when HIGH, indicates an overflow during the summing.",
                                "write 1 to clear."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 0,
                            "ftype": "boolean",
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "pst_packetiser.pst_packetiser_reg_pkg": {
            "name": "pst_packetiser",
            "desc": "PST Packetiser",
            "mnemonic": "pst_packetiser",
            "version": "1.0.0",
            "author": "Richard Hein",
            "email": "richard.hein@mda.space",
            "registers": {
                "configuration_register": {
                    "name": "Configuration Register",
                    "addressOffset": "0x0",
                    "desc": "This register is read only returning the default packet format settings for the initial release version. In future versions the packet format may be configured through this register as read/write.",
                    "fields": {
                        "channels_per_packet": {
                            "name": "Channels per Packet",
                            "desc": "A 16-bit unsigned integer Channels per Packet field that identifies the range of contiguous frequency channels contained in the packet. (default 185)",
                            "bitOffset": 0,
                            "bitWidth": 12,
                            "reset": 185,
                            "access": "ro"
                        },
                        "time_samples_per_packet": {
                            "name": "Time Samples per Packet",
                            "desc": "A 16-bit unsigned integer Number of Time Samples field that identifies the number time samples for each frequency channel contained within the packet. (default 4)",
                            "bitOffset": 12,
                            "bitWidth": 12,
                            "reset": 4,
                            "access": "ro"
                        },
                        "time_samples_per_weight": {
                            "name": "Time Samples per Relative Weight",
                            "desc": "An 8-bit unsigned integer Number of time samples per relative weight (# ts per rel wt) field will identify the number of times samples, for each frequency channel, over which a relative weight is calculated. The Number of Time Samples is an integer multiple of the Number of time samples per relative weight. (default 4)",
                            "bitOffset": 24,
                            "bitWidth": 8,
                            "reset": 4,
                            "access": "ro"
                        }
                    }
                },
                "reset_register": {
                    "name": "Reset Register",
                    "addressOffset": "0x4",
                    "desc": "Resets the packetizer",
                    "fields": {
                        "reset": {
                            "name": "Reset",
                            "desc": "Write 1 to put the packetizer into a reset state ready to accept samples. Must be done before samples are first received at the packetizer.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "access": "wr"
                        }
                    }
                },
                "meta_channel_separation_register": {
                    "name": "Meta Channel Separation Register",
                    "addressOffset": "0x8",
                    "desc": "This register is read only returning the default packet format settings for the initial release version. In future versions the packet format may be configured through this register as read/write.",
                    "fields": {
                        "meta_channel_separation": {
                            "name": "Meta Channel Separation",
                            "desc": "A 32-bit unsigned integer Channel Separation field that identifies the frequency spacing between channels in the packet in units of mHz. The maximum frequency that can be represented is ~4.3MHz. This value is only used to set the Channel Separation field in the UDP payload meta data. For AA1.0 this will be fixed to the 4K channeliser configuration of 220,200,960 / 4096 = 53,760,000 mHz",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 53760000,
                            "access": "ro"
                        }
                    }
                },
                "meta_channel_packet_frequency_increment_register": {
                    "name": "Meta Channel Packet Frequecy Increment Register",
                    "addressOffset": "0x10",
                    "width": 64,
                    "desc": "This register is read only returning the default packet format settings for the initial release version. In future versions the packet format may be configured through this register as read/write.",
                    "fields": {
                        "meta_channel_packet_frequency_increment": {
                            "name": "Meta Channel Packet Frequecy Increment",
                            "desc": "The frequency increment in mHz between packets. Set to the value in the Channels per Packet register multiplied by the Meta Channel Separation Register value. This value is used to determine and set the UDP meta data First Channel Frequency field for each UDP packet. For AA1.0 this will be fixed to 185 channels * 53,760 Hz = 9,945,600,000 mHz",
                            "bitOffset": 0,
                            "bitWidth": 48,
                            "reset": 9945600000,
                            "access": "ro"
                        }
                    }
                },
                "meta_first_channel_frequency_register": {
                    "name": "Meta First Channel Frequency Register",
                    "addressOffset": "0x18",
                    "width": 64,
                    "desc": "",
                    "fields": {
                        "meta_first_channel_frequency": {
                            "name": "Meta First Channel Frequency",
                            "desc": "A 64-bit unsigned integer First channel frequency field that identifies the channel centre frequency of the First Channel Number in units of mHz. This value is used to determine and set the UDP meta data First Channel Frequency field.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "meta_first_channel_number_register": {
                    "name": "Meta First Channel Number Register",
                    "addressOffset": "0x20",
                    "desc": "",
                    "fields": {
                        "meta_first_channel_number": {
                            "name": "Meta First Channel Number",
                            "desc": "Sets the first value of the UDP meta data First Channel Number field which increments by the number of channels in each packet.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "meta_beam_number_register": {
                    "name": "Meta Beam Number Register",
                    "addressOffset": "0x24",
                    "desc": "",
                    "fields": {
                        "meta_beam_number": {
                            "name": "Meta Beam Number",
                            "desc": "A 4-bit unsigned integer Beam Number will identify the beam (of 16 possible beams for PST and 1500 for Mid.PSS) to which the data in the packet belongs. This value is used in the lookup for the host ID and to set the Beam Number field in the UDP payload meta data. Range 0 (beam 1) to 15 (beam 16). Default 0",
                            "bitOffset": 0,
                            "bitWidth": 4,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "meta_magic_word_register": {
                    "name": "Meta Magic Word Register",
                    "addressOffset": "0x28",
                    "desc": "",
                    "fields": {
                        "meta_magic_word": {
                            "name": "Meta Magic Word",
                            "desc": "A 32-bit unsigned integer Magic Number field to enable a basic check of the packet contents during decoding. This value is only used to set the Magic Word field in the UDP payload meta data. Default 0xBEADFEED",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 3199074029,
                            "access": "rw"
                        }
                    }
                },
                "meta_scan_id_register": {
                    "name": "Meta Scan ID Register",
                    "addressOffset": "0x30",
                    "width": 64,
                    "desc": "",
                    "fields": {
                        "meta_scan_id": {
                            "name": "Meta Scan ID",
                            "desc": "A 64-bit unsigned integer Scan ID field is provided by LMC and included by CBF in the packet so that the pulsar processor can independently check the observational parameters of the current beam data. This value is only used to set the Scan ID field in the UDP payload meta data.",
                            "bitOffset": 0,
                            "bitWidth": 64,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "test_sample_limit_register": {
                    "name": "Test Sample Limit Register",
                    "addressOffset": "0x38",
                    "desc": "",
                    "fields": {
                        "test_sample_limit": {
                            "name": "Test Sample Limit",
                            "desc": "Test register to burst out only a limited number of time samples. Each time sample results in 20 PST packets. Writing a non-zero value will send out the given number of 20 packet time sample sequences then stopping to send futher packets. Writing 0 disables limiting mode and returns to full rate output.",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "lstv_replay.lstv_replay_reg_pkg": {
            "name": "Long Sequence Test Vector Replayer register set",
            "mnemonic": "lstv_replay",
            "desc": "Reads long sequence test vectors from the external DDR4 memory and converts them to a stream of samples suitable for transmitting with the SPFRX packetiser.",
            "version": "2.0.0",
            "author": "William Kamp",
            "email": "will@kamputed.com",
            "date": "2022-06-22",
            "registers": {
                "control": {
                    "name": "Control",
                    "desc": "Control and Status register.",
                    "fields": {
                        "run": {
                            "name": "run",
                            "desc": "Write '1' to start reading the LSTV from DDR4 memory, Write '0' to stop and reset to `lstv_start_addr`.",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "lstv_current_addr_register": {
                    "name": "LSTV current address register",
                    "desc": "LSTV current address",
                    "fields": {
                        "lstv_current_addr": {
                            "name": "LSTV current address",
                            "desc": [
                                "The current read address, in units of 64-byte words.",
                                "Can monitor this to see how far through the long sequence test vector we are.",
                                "Note that when `lstv_end_addr` is reached, the address is reset to `lstv_start_addr`."
                            ],
                            "ftype": "natural",
                            "access": "ro",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "lstv_start_addr_register": {
                    "name": "LSTV start address register",
                    "desc": "LSTV start address",
                    "fields": {
                        "lstv_start_addr": {
                            "name": "LSTV start address",
                            "desc": "The start address, in units of 64-byte words",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "lstv_end_addr_register": {
                    "name": "LSTV end address register",
                    "desc": "LSTV end address",
                    "fields": {
                        "lstv_end_addr": {
                            "name": "LSTV end address",
                            "desc": "The end address, in units of 64-byte words",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "sample_rate": {
                    "name": "Sample Rate",
                    "desc": "Sample rate",
                    "width": 64,
                    "fields": {
                        "sample_rate": {
                            "name": "Sample Rate",
                            "desc": "The desired number of samples in a 1 second interval.",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 33,
                            "bitOffset": 0,
                            "reset": 3963617280
                        }
                    }
                },
                "ref_clk_freq": {
                    "name": "ref_clk_freq",
                    "desc": "The frequency of the reference clock.",
                    "width": 64,
                    "fields": {
                        "ref_clk_freq": {
                            "name": "ref_clk_freq",
                            "desc": [
                                "The reference sample clock frequency from the external memory.",
                                "This is effectivly the DDR clock rate (e.g. 333MHz) times the number of samples per DDR word (e.g. 21)."
                            ],
                            "ftype": "natural",
                            "access": "ro",
                            "bitWidth": 64,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "samples_per_cycle": {
                    "name": "Samples per Cycle Rate Control",
                    "desc": "Controls the rate that LSTV words are output.",
                    "fields": {
                        "samples_per_cycle": {
                            "name": "Samples per Cycle Rate Control",
                            "desc": [
                                "The number of samples per cycle. Set to `(sample_rate / ref_clk_freq) * 2**32`.",
                                "This value can be reduced to slow time down, i.e. multiply by 0.75 to run at 75% actual sample rate."
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "start_utc_time_code": {
                    "name": "start UTC time code",
                    "desc": "Set the timestamp of the first sample.",
                    "fields": {
                        "start_utc_time_code": {
                            "name": "start UTC time code",
                            "desc": [
                                "The 32-bit UTC time code in seconds for the first sample.",
                                "This is loaded when `run` is asserted."
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "spfrx_packetizer.spfrx_packetizer_reg_pkg": {
            "name": "spfrx_packetizer",
            "desc": "SPFRx Packetizer.",
            "version": "0.1.0",
            "width": 32,
            "registers": {
                "id": {
                    "name": "id",
                    "desc": "IP Block ID Register.",
                    "addressOffset": "0x0",
                    "fields": {
                        "id": {
                            "name": "id",
                            "desc": "Hardcoded block ID.",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": "0x6bf742a9"
                        }
                    }
                },
                "version": {
                    "name": "version",
                    "addressOffset": "0x4",
                    "desc": "IP Block Version Register.",
                    "fields": {
                        "version": {
                            "name": "version",
                            "desc": "Block Version Code.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": "0x00010000",
                            "access": "ro"
                        }
                    }
                },
                "ctrl": {
                    "name": "ctrl",
                    "addressOffset": "0xC",
                    "desc": "IP Block General Control and Status Register.",
                    "fields": {
                        "sw_rst": {
                            "name": "sw_rst",
                            "desc": "Reset the core. Does not reset the register file.\\newline Logic 0: Module is operational. \\newline Logic 1: Module is held in the reset state.",
                            "access": "rw",
                            "ftype": "boolean",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "reset": 1
                        },
                        "sf_fifo_ovf": {
                            "name": "sf_fifo_ovf",
                            "desc": "When read as '1' this bit indicates that the store-and-forward FIFO has overflowed and data in the stream has been lost. The packetizer must be reset.",
                            "access": "ro",
                            "ftype": "boolean",
                            "bitOffset": 1,
                            "bitWidth": 1
                        },
                        "metafifo_ovf": {
                            "name": "metafifo_ovf",
                            "desc": "When read as '1' this bit indicates that the metaframe FIFO has overflowed and data in the stream has been lost. The packetizer must be reset.",
                            "access": "ro",
                            "ftype": "boolean",
                            "bitOffset": 2,
                            "bitWidth": 1
                        }
                    }
                },
                "loc_mac_h": {
                    "name": "loc_mac_h",
                    "desc": "Local MAC address register.",
                    "addressOffset": "0x10",
                    "fields": {
                        "loc_mac_h": {
                            "name": "loc_mac_h",
                            "desc": "Local MAC address, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": "0x1122"
                        }
                    }
                },
                "loc_mac_l": {
                    "name": "loc_mac_l",
                    "desc": "Local MAC address register.",
                    "addressOffset": "0x14",
                    "fields": {
                        "loc_mac_l": {
                            "name": "loc_mac_l",
                            "desc": "Local MAC address, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": "0x33445566"
                        }
                    }
                },
                "rem_mac_h": {
                    "name": "rem_mac_h",
                    "desc": "Remote MAC address register.",
                    "addressOffset": "0x18",
                    "fields": {
                        "rem_mac_h": {
                            "name": "rem_mac_h",
                            "desc": "Remote MAC address, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": "0x7788"
                        }
                    }
                },
                "rem_mac_l": {
                    "name": "rem_mac_l",
                    "desc": "Remote MAC address register.",
                    "addressOffset": "0x1C",
                    "fields": {
                        "rem_mac_l": {
                            "name": "rem_mac_l",
                            "desc": "Remote MAC address, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": "0x99AABBCC"
                        }
                    }
                },
                "pkt_cfg": {
                    "name": "pkt_cfg",
                    "desc": "Packet Configuration Register.",
                    "addressOffset": "0x20",
                    "fields": {
                        "ethertype": {
                            "name": "ethertype",
                            "desc": "Ethernet protocol field. Default as required by SaDT.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": "0xFEED"
                        },
                        "dish_id": {
                            "name": "dish_id",
                            "desc": "Dish ID field.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "hw_src_id_h": {
                    "name": "hw_src_id_h",
                    "desc": "Hardware source ID register.",
                    "addressOffset": "0x28",
                    "fields": {
                        "hw_src_id_h": {
                            "name": "hw_src_id_h",
                            "desc": "Hardware Source ID field, bits [63:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "hw_src_id_l": {
                    "name": "hw_src_id_l",
                    "desc": "Hardware source ID register.",
                    "addressOffset": "0x2C",
                    "fields": {
                        "hw_src_id_l": {
                            "name": "hw_src_id_l",
                            "desc": "Hardware Source ID field, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band12_h": {
                    "name": "sample_rate_band12_h",
                    "desc": "Band 1/2 Sample Rate Register.",
                    "addressOffset": "0x30",
                    "fields": {
                        "sample_rate_band12_h": {
                            "name": "sample_rate_band12_h",
                            "desc": "Transport sample rate, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band12_l": {
                    "name": "sample_rate_band12_l",
                    "desc": "Band 1/2 Sample Rate Register.",
                    "addressOffset": "0x34",
                    "fields": {
                        "sample_rate_band12_l": {
                            "name": "sample_rate_band12_l",
                            "desc": "Transport sample rate, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band3_h": {
                    "name": "sample_rate_band3_h",
                    "desc": "Band 3 sample rate register.",
                    "addressOffset": "0x38",
                    "fields": {
                        "sample_rate_band3_h": {
                            "name": "sample_rate_band3_h",
                            "desc": "Transport sample rate, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band3_l": {
                    "name": "sample_rate_band3_l",
                    "desc": "Band 3 sample rate register.",
                    "addressOffset": "0x3C",
                    "fields": {
                        "sample_rate_band3_l": {
                            "name": "sample_rate_band3_l",
                            "desc": "Transport sample rate, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band45b_h": {
                    "name": "sample_rate_band45b_h",
                    "desc": "Band 4/5B Sample Rate register.",
                    "addressOffset": "0x40",
                    "fields": {
                        "sample_rate_band45b_h": {
                            "name": "sample_rate_band45b_h",
                            "desc": "Transport sample rate, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band45b_l": {
                    "name": "sample_rate_band45b_l",
                    "desc": "Band 4/5B Sample Rate register.",
                    "addressOffset": "0x44",
                    "fields": {
                        "sample_rate_band45b_l": {
                            "name": "sample_rate_band45b_l",
                            "desc": "Transport sample rate, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band5a_h": {
                    "name": "sample_rate_band5a_h",
                    "desc": "Band 5A Sample rate register.",
                    "addressOffset": "0x48",
                    "fields": {
                        "sample_rate_band5a_h": {
                            "name": "sample_rate_band5a_h",
                            "desc": "Transport sample rate, bits [47:32].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "sample_rate_band5a_l": {
                    "name": "sample_rate_band5a_l",
                    "desc": "Band 5A sample rate register.",
                    "addressOffset": "0x4C",
                    "fields": {
                        "sample_rate_band5a_l": {
                            "name": "sample_rate_band5a_l",
                            "desc": "Transport sample rate, bits [31:0].",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "gpi": {
                    "name": "gpi",
                    "desc": "General Purpose Input Register.",
                    "addressOffset": "0x50",
                    "fields": {
                        "gpi": {
                            "name": "gpi",
                            "desc": "32 GPI bits, for debugging.",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "gpo": {
                    "name": "gpo",
                    "desc": "General Purpose Output Register.",
                    "addressOffset": "0x54",
                    "fields": {
                        "gpo": {
                            "name": "gpo",
                            "desc": "32 GPO bits, for debugging.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0
                        }
                    }
                },
                "band1_holdoff": {
                    "name": "band1_holdoff",
                    "desc": "Band 1 Noise Diode Holdoff Register.",
                    "addressOffset": "0x58",
                    "fields": {
                        "band1_holdoff_rise": {
                            "name": "band1_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band1_holdoff_fall": {
                            "name": "band1_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "band2_holdoff": {
                    "name": "band2_holdoff",
                    "desc": "Band 2 Noise Diode Holdoff Register.",
                    "addressOffset": "0x5C",
                    "fields": {
                        "band2_holdoff_rise": {
                            "name": "band2_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band2_holdoff_fall": {
                            "name": "band2_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "band3_holdoff": {
                    "name": "band3_holdoff",
                    "desc": "Band 3 Noise Diode Holdoff Register.",
                    "addressOffset": "0x60",
                    "fields": {
                        "band3_holdoff_rise": {
                            "name": "band3_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band3_holdoff_fall": {
                            "name": "band3_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "band4_holdoff": {
                    "name": "band4_holdoff",
                    "desc": "Band 4 Noise Diode Holdoff Register.",
                    "addressOffset": "0x64",
                    "fields": {
                        "band4_holdoff_rise": {
                            "name": "band4_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band4_holdoff_fall": {
                            "name": "band4_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "band5a_holdoff": {
                    "name": "band5a_holdoff",
                    "desc": "Band 5A Noise Diode Holdoff Register.",
                    "addressOffset": "0x68",
                    "fields": {
                        "band5a_holdoff_rise": {
                            "name": "band5a_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band5a_holdoff_fall": {
                            "name": "band5a_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                },
                "band5b_holdoff": {
                    "name": "band5b_holdoff",
                    "desc": "Band 5B Noise Diode Holdoff Register.",
                    "addressOffset": "0x6C",
                    "fields": {
                        "band5b_holdoff_rise": {
                            "name": "band5b_holdoff_rise",
                            "desc": "Holdoff (in sample frames) for the OFF-ON transition.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0
                        },
                        "band5b_holdoff_fall": {
                            "name": "band5b_holdoff_fall",
                            "desc": "Holdoff (in sample frames) for the ON-OFF transition.",
                            "access": "rw",
                            "bitOffset": 16,
                            "bitWidth": 16,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "lstv_gen.lstv_gen_reg_pkg": {
            "name": "Long Sequence Test Vector generator register set",
            "mnemonic": "lstv_gen",
            "desc": "Long Sequence Test Vector generator register set",
            "version": "2.1.0",
            "author": "Jun Li",
            "email": "jun.li@mdacoroporation.com",
            "date": "2020-09-15",
            "registers": {
                "magic_number_register": {
                    "name": "magic number register",
                    "desc": "Unique identification of the IP type",
                    "addressOffset": "0x00",
                    "fields": {
                        "magic_number": {
                            "name": "magic number",
                            "desc": "Unique identification of the IP type",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "revision_register": {
                    "name": "revision register",
                    "desc": "Revision of this IP",
                    "addressOffset": "0x04",
                    "fields": {
                        "revision": {
                            "name": "revision",
                            "desc": "Revision of this IP",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "control_register": {
                    "name": "control register",
                    "desc": "controls the LSTV generation",
                    "addressOffset": "0x08",
                    "fields": {
                        "ip_control": {
                            "name": "ip control",
                            "desc": "controls the start and stop of LSTV generation",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "status_register": {
                    "name": "status register",
                    "desc": "LSTV generator status",
                    "addressOffset": "0x0C",
                    "fields": {
                        "ip_status": {
                            "name": "ip status",
                            "desc": "LSTV generator status: generation in progress",
                            "ftype": "boolean",
                            "access": "ro",
                            "bitWidth": 1,
                            "bitOffset": 0
                        },
                        "memory_ready": {
                            "name": "Memory Ready Status",
                            "desc": "Set when the DDR4 Memory interface is ready to accept data.",
                            "ftype": "boolean",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "access": "ro",
                            "reset": 0
                        }
                    }
                },
                "ddr4_current_addr_register": {
                    "name": "DDR4 Current Write Address",
                    "desc": "The DDR4 address that was last written.",
                    "addressOffset": "0x10",
                    "fields": {
                        "ddr4_current_addr": {
                            "name": "DDR4 Current Write Address",
                            "desc": "The DDR4 address that was last written by the LSTV generator, in unit of 64-bytes. Can be used to indicate percentage complete.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "ddr4_start_addr_register": {
                    "name": "ddr4 start addr register",
                    "desc": "ddr4 start address",
                    "addressOffset": "0x14",
                    "fields": {
                        "ddr4_start_addr": {
                            "name": "ddr4 start address for the lstv",
                            "desc": "ddr4 start address for lstv, in unit of 64-bytes",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "ddr4_end_addr_register": {
                    "name": "ddr4 end address register",
                    "desc": "ddr4 end address",
                    "addressOffset": "0x18",
                    "fields": {
                        "ddr4_end_addr": {
                            "name": "ddr4 end address for the lstv",
                            "desc": "ddr4 end address for lstv, in unit of 64-bytes",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "input_select_register": {
                    "name": "LSTV input select register",
                    "desc": "bitmask to select LSTV input sources",
                    "addressOffset": "0x1C",
                    "fields": {
                        "tone_select": {
                            "name": "tone select",
                            "desc": [
                                "select from the 4 RFI tones",
                                "bit[3:0]: RFI tone 3:0"
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 4,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "source_select": {
                            "name": "source select",
                            "desc": [
                                "select from the 4 source noises",
                                "bit[3:0]: source noises 3:0"
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 4,
                            "bitOffset": 4,
                            "reset": 0
                        },
                        "receiver_select": {
                            "name": "receiver select",
                            "desc": "select from the 1 receiver noise",
                            "ftype": "boolean",
                            "access": "rw",
                            "bitWidth": 1,
                            "bitOffset": 8,
                            "reset": 0
                        }
                    }
                },
                "source_mean_register": {
                    "name": "mean register for source noise",
                    "desc": "mean for source noise",
                    "repeat": 4,
                    "addressOffset": "0x20",
                    "fields": {
                        "source_mean_polX": {
                            "name": "mean for source noise, polarization X",
                            "desc": "mean for source noise, polarization X, signed 16-bit, in two's complement format",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "source_mean_polY": {
                            "name": "mean for source noise, polarization Y",
                            "desc": "mean for source noise, polarization Y, signed 16-bit, in two's complement format",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 16,
                            "reset": 0
                        }
                    }
                },
                "source_std_register": {
                    "name": "std register for source noise",
                    "desc": "std for source noise",
                    "repeat": 4,
                    "addressOffset": "0x30",
                    "fields": {
                        "source_std_polX": {
                            "name": "std for source noise, polarization X",
                            "desc": "std for source noise, polarization X, unsigned 16-bit",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "source_std_polY": {
                            "name": "std for source noise, polarization Y",
                            "desc": "std for source noise, polarization Y, signed 16-bit",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 16,
                            "reset": 0
                        }
                    }
                },
                "receiver_mean_register": {
                    "name": "mean register for receiver noise",
                    "desc": "mean for receiver noise",
                    "addressOffset": "0x40",
                    "fields": {
                        "receiver_mean_polX": {
                            "name": "mean for receiver noise, polarization X",
                            "desc": "mean for receiver noise, polarization X, signed 16-bit, in two's complement format",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "receiver_mean_polY": {
                            "name": "mean for receiver noise, polarization Y",
                            "desc": "mean for receiver noise, polarization Y, signed 16-bit, in two's complement format",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 16,
                            "reset": 0
                        }
                    }
                },
                "receiver_std_register": {
                    "name": "std register for receiver noise",
                    "desc": "std for receiver noise",
                    "addressOffset": "0x44",
                    "fields": {
                        "receiver_std_polX": {
                            "name": "std for receiver noise, polarization X",
                            "desc": "std for receiver noise, polarization X, unsigned 16-bit",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "receiver_std_polY": {
                            "name": "std for receiver noise, polarization Y",
                            "desc": "std for receiver noise, polarization Y, signed 16-bit",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 16,
                            "reset": 0
                        }
                    }
                },
                "ext_mem_start": {
                    "name": "External Memory Start Address Limit",
                    "desc": "The lowest address that the LSTV can start.",
                    "addressOffset": "0x48",
                    "fields": {
                        "low_address_allocation": {
                            "name": "Low Address Allocation",
                            "desc": "The external memory (ddr4) lower limit for the start address, in units of 64-bytes.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "ext_mem_end": {
                    "name": "External Memory End Address Limit",
                    "desc": "The highest address that the LSTV can end.",
                    "addressOffset": "0x4C",
                    "fields": {
                        "high_address_allocation": {
                            "name": "Low Address Allocation",
                            "desc": "The external memory (ddr4) upper limit for the end address, in units of 64-bytes.",
                            "ftype": "natural",
                            "access": "ro",
                            "bitWidth": 32,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "gaussian_noise.gaussian_reg_pkg": {
            "name": "Gaussian Noise Generator register set",
            "mnemonic": "gaussian",
            "desc": "Gaussian Noise Generator using the Box-Muller Transformation",
            "version": "1.0.0",
            "author": "Jun Li",
            "email": "jun.li@mdacoroporation.com",
            "date": "2020-04-20",
            "registers": {
                "magic_number_register": {
                    "name": "magic number register",
                    "desc": "Unique identification of the IP type",
                    "fields": {
                        "magic_number": {
                            "name": "magic number",
                            "desc": "Unique identification of the IP type, fixed at 0x11111111",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "revision_register": {
                    "name": "revision register",
                    "desc": "Revision of this IP",
                    "fields": {
                        "revision": {
                            "name": "revision",
                            "desc": "Revision of this IP, fixed at 0x20200420",
                            "ftype": "natural",
                            "access": "ro",
                            "bitOffset": 0,
                            "bitWidth": 32
                        }
                    }
                },
                "seed_register": {
                    "name": "seed register for the pseudo-random sequences",
                    "desc": "pseudo-random number generator seed, Box-Muller Transformation",
                    "fields": {
                        "seed_ln": {
                            "name": "seed natural logarithm part",
                            "desc": "pseudo-random number generator seed, natural logarithm part",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        },
                        "seed_cos": {
                            "name": "seed cosine part",
                            "desc": "pseudo-andom number generator seed, cosine part",
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 16,
                            "reset": 0
                        }
                    }
                },
                "mean_register": {
                    "name": "mean register",
                    "desc": "mean for the Gaussian noise",
                    "fields": {
                        "mean": {
                            "name": "mean",
                            "desc": "mean for the Gaussian noise",
                            "ftype": "integer",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                },
                "std_register": {
                    "name": "standard deviation register",
                    "desc": "standard deviation for the Gaussian noise",
                    "fields": {
                        "std": {
                            "name": "standard deviation",
                            "desc": [
                                "standard deviation for the Gaussian noise, unsigned 16-bit",
                                "range: [0, 0xFFFF]",
                                "actual std = 3718.8 * std_register / 65,536"
                            ],
                            "ftype": "natural",
                            "access": "rw",
                            "bitWidth": 16,
                            "bitOffset": 0,
                            "reset": 0
                        }
                    }
                }
            }
        },
        "bite_fir_filter.bite_fir_filter_reg_pkg": {
            "name": "BITE FIR Filter Coefficients",
            "desc": [
                "These registers hold the coefficients of the FIR filter.",
                "This register set represents the coefficients as a random access memory, *however*,",
                "the implementation is as a shift register.",
                "A write to any register in this set will push the coefficients into the shift register.",
                "A read to any register in this set will return the *next* coefficient to be pushed out by the next write.",
                "",
                "Therefore, to load a set of coefficients, write them sequentially, from offset zero (the first).",
                "To read the coefficients, read a coefficient (starting at offset zero) and write it back to the same offset, before reading the next coefficient.",
                "The write-back will advance the shift register so that the read will give you the next coefficient.",
                "",
                "Note that as such the address that a coefficients is read or written to does not matter to the firmware, however for asthetics in software write/read to sequential addresses.",
                "It is important that you read/write *all* the coefficients, so that the coefficients are shifted into the correct position in the FIR filter."
            ],
            "mnemonic": "bite_fir_filter",
            "version": "2.0.0",
            "author": "William Kamp",
            "email": "will@kamputed.com",
            "date": "2022-12-20",
            "referenceDocumentTitle": "None",
            "referenceDocument": "None",
            "registers": {
                "filter_coeff": {
                    "name": "filter_coeff",
                    "addressOffset": "0x0",
                    "fields": {
                        "filter_coeff": {
                            "name": "filter_coeff",
                            "desc": [
                                "Coefficients for the FIR filter in the range [-1, 1).",
                                "These are represented as 16-bit two's complement integers, with 1 sign-bit and 15 fractional bits."
                            ],
                            "ftype": "integer",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0,
                            "access": "wodr"
                        }
                    }
                }
            },
            "repeat": 1024,
            "ram": true
        },
        "bite_tone_gen.bite_tone_gen_reg_pkg": {
            "name": "BITE TONE GENERATOR",
            "desc": [
                "Sinusoidal signal generation firmware-block.",
                "The registers 'phase_inc' and 'mag_scale' that configure",
                "the frequency and magnitude of the sinusoid, respectively."
            ],
            "mnemonic": "bite_tone_gen",
            "version": "1.1.0",
            "author": "T. Gunaratne",
            "email": "Thushara.Gunaratne@nrc-cnrc.gc.ca",
            "date": "2020-06-23",
            "referenceDocumentTitle": "None",
            "referenceDocument": "None",
            "registers": {
                "config_bite_tone_gen_phs": {
                    "name": "Config_bite_tone_gen_phs",
                    "addressOffset": "0x0",
                    "fields": {
                        "phase_inc": {
                            "name": "phase_inc",
                            "desc": [
                                "Parameter sepcifying the frequency of the sinusoid.",
                                "The value is the normalized frequnecy with respect to the",
                                "sampling rate and is expressed in unsigned 32-bit format."
                            ],
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "config_bite_tone_gen_mag": {
                    "name": "Config_bite_tone_gen_mag",
                    "addressOffset": "0x4",
                    "fields": {
                        "mag_scale": {
                            "name": "mag_scale",
                            "desc": [
                                "Parameters specifying the magnitude of the sinusoid",
                                "The value ranges from 0 to 65,535 and is expressed in",
                                "Unsigned 16-bit format."
                            ],
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "config_bite_tone_gen_delta_int": {
                    "name": "Config_bite_tone_gen_delta_int",
                    "addressOffset": "0x8",
                    "fields": {
                        "delta_int": {
                            "name": "delta_int",
                            "desc": [
                                "Delta register integer part where delta = [delta_int].[delta_frac]",
                                "This parameter sets the rate change of the phase incremment in Hz/sample;",
                                "it gets added to phase_inc (normalized simusoidal frequency) every clock cycle.",
                                "It's used to provide the capability to linearly sweep the frequency in an",
                                "increasing direction.",
                                "delta_int: unsigned 32-bit value, range = [2^31 : 2^0]."
                            ],
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "config_bite_tone_gen_delta_frac": {
                    "name": "Config_bite_tone_gen_delta_frac",
                    "addressOffset": "0xC",
                    "fields": {
                        "delta_frac": {
                            "name": "delta_frac",
                            "desc": [
                                "Delta register fractional part where delta = [delta_int].[delta_frac]",
                                "This parameter sets the rate change of the phase incremment in Hz/sample;",
                                "it gets added to phase_inc (normalized simusoidal frequency) every clock cycle.",
                                "It's used to provide the capability to linearly sweep the frequency in an",
                                "increasing direction.",
                                "delta_frac: unsigned 24-bit value, range = 0.[2^-1 : 2^-24]."
                            ],
                            "ftype": "natural",
                            "bitOffset": 0,
                            "bitWidth": 24,
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "polarization_coupler.polarization_coupler_reg_pkg": {
            "name": "polarization_coupler",
            "desc": [
                "The polarization coupler for the TDC/Mid.CBF built-in test environment (BITE) is used to create partially-correlated outputs from two independent Gaussian inputs for the purpose of modelling astronomical sources.",
                "This block uses the asymmetric two-generator method (see https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3155589/).",
                "A one-sample delay can be inserted in the cross-connected path, which has the effect of creating a predictable 180 degree phase ramp in the cross-power spectrum for testing purposes."
            ],
            "version": "1.0.0",
            "registers": {
                "configuration": {
                    "name": "configuration",
                    "addressOffset": "0x0",
                    "fields": {
                        "delay_enable": {
                            "name": "delay_enable",
                            "desc": [
                                "0: Delay element in cross-connected path is disabled.",
                                "1: Delay element in cross-connected path is enabled."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "coeff_alpha": {
                    "name": "coeff_alpha",
                    "addressOffset": "0x4",
                    "fields": {
                        "alpha": {
                            "name": "alpha",
                            "desc": [
                                "Linear scaling coefficient of the cross-connected path.",
                                "Set this value to the desired correlation coefficient (rho) in the range [-1, 1].",
                                "This coefficient is scaled by a factor of 2^16."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 18,
                            "reset": 0,
                            "ftype": "integer",
                            "access": "rw"
                        }
                    }
                },
                "coeff_beta": {
                    "name": "coeff_beta",
                    "addressOffset": "0x8",
                    "fields": {
                        "beta": {
                            "name": "beta",
                            "desc": [
                                "Linear scaling coefficient of the straight-thru path.",
                                "Set this value to sqrt(1-rho^2).",
                                "This coefficient is scaled by a factor of 2^16."
                            ],
                            "bitOffset": 0,
                            "bitWidth": 18,
                            "reset": 65536,
                            "ftype": "integer",
                            "access": "rw"
                        }
                    }
                }
            }
        },
        "visibility_packetiser.host_lut_s2_reg_pkg": {
            "name": "Stage 2 Host Lookup",
            "mnemonic": "host_lut_s2",
            "desc": "Second stage of host lookup that converts a Host ID into an Ethernet MAC address, IP address, and UDP port offset.",
            "version": "1.0.0",
            "author": "William Kamp",
            "email": "william.kamp@aut.ac.nz",
            "referenceDocumentTitle": "SPEAD Visibility Writer Design Document.",
            "referenceDocument": "https://docs.google.com/document/d/1jC1d6QekTpgrb-0MZRIFAKJT-YhJ6J0lXlfAE4BAgLc/edit?usp=sharing",
            "registers": {
                "data_mac_address_hi": {
                    "name": "MAC Address Data High",
                    "desc": "Register for programming the lookup table.",
                    "addressOffset": "0x00",
                    "fields": {
                        "mac_addr_high": {
                            "name": "MAC address High 16bits",
                            "desc": "The MAC address of the destination host.",
                            "access": "wo",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "repeat": 1
                        }
                    },
                    "width": 32
                },
                "data_mac_address_lo": {
                    "name": "MAC Address Data Low",
                    "desc": "Register for programming the lookup table.",
                    "addressOffset": "0x04",
                    "fields": {
                        "mac_addr_low": {
                            "name": "MAC address Low 32bits",
                            "desc": "The low 32 bits of the MAC address of the destination host.",
                            "access": "wo",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "repeat": 1
                        }
                    },
                    "width": 32
                },
                "data_ip_address": {
                    "name": "IP Address Data",
                    "desc": "Register for programming the lookup table.",
                    "addressOffset": "0x08",
                    "fields": {
                        "ip_address": {
                            "name": "IP address",
                            "desc": "The IP address of the host.",
                            "access": "wo",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "repeat": 1
                        }
                    },
                    "width": 32
                },
                "data_udp_port": {
                    "name": "UDP port Data",
                    "desc": "Register for programming the lookup table.",
                    "addressOffset": "0x0C",
                    "fields": {
                        "udp_offset": {
                            "name": "UDP port offset",
                            "desc": [
                                "The UDP port number is the addition of a udp-port-offset and the channel-id.",
                                "The udp-port-offset can be negative so that the UDP port is less than the channel-id.",
                                "This does limit higher index channels to higher UDP ports.",
                                "Note also that the same physical machine address (MAC/IP) can be assigned multiple host-ids to obtain different udp-port-offsets."
                            ],
                            "access": "wo",
                            "bitOffset": 0,
                            "bitWidth": 17,
                            "ftype": "integer",
                            "reset": 0,
                            "repeat": 1
                        }
                    },
                    "width": 32
                },
                "address": {
                    "name": "Address",
                    "desc": "Register for programming the lookup table. Writing to this register triggers the write into the lookup table at the address corresponding to the contained field.",
                    "addressOffset": "0x10",
                    "fields": {
                        "host_id": {
                            "name": "Host ID",
                            "desc": "The host ID to be programmed. This is used as the address into the lookup table.",
                            "access": "wo",
                            "bitOffset": 0,
                            "bitWidth": 10,
                            "ftype": "natural",
                            "reset": 0,
                            "repeat": 1
                        }
                    },
                    "width": 32
                }
            },
            "repeat": 1,
            "ram": false
        },
        "visibility_packetiser.visibility_source_host_config_reg_pkg": {
            "name": "Visibility Source Host Configuration",
            "desc": "Registers to define the source network identity.",
            "mnemonic": "visibility_source_host_config",
            "version": "1.1.0",
            "author": "William Kamp",
            "email": "william.kamp@aut.ac.nz",
            "referenceDocumentTitle": "",
            "referenceDocument": "",
            "registers": {
                "mac_address_high": {
                    "name": "MAC Source Address High",
                    "desc": "Register for programming the source MAC address.",
                    "addressOffset": "0x00",
                    "fields": {
                        "mac_addr_high": {
                            "name": "MAC address High 16 bits",
                            "desc": "The MAC address of the source.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0
                        }
                    },
                    "width": 32
                },
                "mac_address_low": {
                    "name": "MAC Source Address Low",
                    "desc": "Register for programming the source MAC address.",
                    "addressOffset": "0x04",
                    "fields": {
                        "mac_addr_low": {
                            "name": "MAC address Low 32bits",
                            "desc": "The low 32 bits of the MAC address of the source.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0
                        }
                    },
                    "width": 32
                },
                "ip_address": {
                    "name": "IP Source Address",
                    "desc": "Register for programming the source IP address.",
                    "addressOffset": "0x08",
                    "fields": {
                        "ip_addr": {
                            "name": "IP address",
                            "desc": "The IP address of the host.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0
                        }
                    },
                    "width": 32
                },
                "udp_port": {
                    "name": "UDP Source Port",
                    "desc": "Register for programming the source UDP Source Port.",
                    "addressOffset": "0x0C",
                    "fields": {
                        "udp_port_offset": {
                            "name": "UDP Source Port Offset",
                            "desc": "The offset applied to calculate the UDP port address. Actual port will be this plus the local channel number.",
                            "access": "rw",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0
                        }
                    },
                    "width": 32
                }
            }
        },
        "histogram.histogram_results_reg_pkg": {
            "name": "Histogram Results Random Access Memory",
            "mnemonic": "histogram_results",
            "desc": "A RAM that reads out the results from a histogram capture. The actual depth of this ram depends on the instance.",
            "version": "1.0.0",
            "registers": {
                "bin": {
                    "name": "bin",
                    "desc": "The results of a histogram capture. The index of this register matches the data value counted.",
                    "fields": {
                        "bin": {
                            "name": "bin",
                            "desc": "Count of histogram entries to the bin of this index.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                }
            },
            "ram": true,
            "repeat": 8192
        },
        "histogram.histogram_control_reg_pkg": {
            "name": "Histogram Control",
            "mnemonic": "histogram_control",
            "desc": [
                "A set of registers/fields that control the histogram capture finite state machine.",
                "Writing '1'/True to each of `start`, `stop`, or `clear` will transition the state machine.",
                "Monitor `done` to check when the action has been completed.",
                "",
                "To capture a histogram of the connected source.",
                "1. Clear the histogram bins, by writing True to `clear`. Wait until `done` is True.",
                "2. Write True to `start`, and either",
                "  a. Wait until `done` = True, meaning that one bin has reached its maximum value.",
                "  b. Write True to `stop`, to terminate the histogram early, (possibly after a timeout period).",
                "3. Read the histogram bins, sum them to work out the total number of samples collected, and divide each bin by the total to get a frequency between 0 and 1."
            ],
            "version": "1.1.0",
            "registers": {
                "ctrl": {
                    "name": "Control",
                    "desc": "A set of fields that control the histogram capture finite state machine.",
                    "fields": {
                        "clear": {
                            "name": "clear",
                            "desc": "Clear the histogram's bins to be zero.",
                            "bitOffset": 0,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "scl"
                        },
                        "start": {
                            "name": "start",
                            "desc": "Start the histogram capturing samples.",
                            "bitOffset": 1,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "scl"
                        },
                        "stop": {
                            "name": "stop",
                            "desc": "Stop the histogram capturing samples.",
                            "bitOffset": 2,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "scl"
                        },
                        "done": {
                            "name": "done",
                            "desc": "Finished clearing the histogram bins and ready to capture samples, or finished capturing samples and ready to readout or clear.",
                            "bitOffset": 3,
                            "bitWidth": 1,
                            "ftype": "boolean",
                            "reset": 0,
                            "access": "ro"
                        },
                        "LOG2_NUM_BINS": {
                            "name": "LOG2_NUM_BINS",
                            "desc": "The number of bins is 2**LOG2_NUM_BINS. This will be the size of the historgram_results RAM.",
                            "bitOffset": 8,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        },
                        "LOG2_MAX_COUNT": {
                            "name": "LOG2_MAX_COUNT",
                            "desc": "The maximum number that any bin will accumulate is 2**LOG2_MAX_COUNT-1. When this occurs the histogram FSM will stop capturing and set `done`.",
                            "bitOffset": 16,
                            "bitWidth": 8,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "select": {
                    "name": "Select",
                    "desc": "Select additional capture conditions.",
                    "fields": {
                        "channel": {
                            "name": "channel",
                            "desc": "Select the channel which you would like to capture from the complex stream.",
                            "bitOffset": 0,
                            "bitWidth": 16,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "rw"
                        }
                    }
                },
                "pps": {
                    "name": "Pulse Per Second",
                    "fields": {
                        "samples_between_pps": {
                            "name": "Samples Between PPS Pulses",
                            "desc": "Count of the number of samples between the last two PPS pulses.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                },
                "flg": {
                    "name": "Flagged samples per second",
                    "fields": {
                        "flagged_between_pps": {
                            "name": "Flagged samples in last second",
                            "desc": "Count of the number of flagged samples between the last two PPS pulses.",
                            "bitOffset": 0,
                            "bitWidth": 32,
                            "ftype": "natural",
                            "reset": 0,
                            "access": "ro"
                        }
                    }
                }
            }
        }
    },
    "DeTrI": {
        "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_BEAM_SUMMER|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 8,
            "firmware_offset": 131080,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_BEAM_SUMMER|E_REG_BANK",
            "regdef": {
                "mnemonic": "pst_beam_summer",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pst_beam_summer.pst_beam_summer_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_PACKETISER|E_PST_PKT_HOST_LOOKUP|STAGE_ONE|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 8,
            "firmware_offset": 131088,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_PACKETISER|E_PST_PKT_HOST_LOOKUP|STAGE_ONE|E_REG_BANK",
            "regdef": {
                "mnemonic": "host_lut_s1",
                "version": "1.0.0"
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_PACKETISER|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 60,
            "firmware_offset": 132352,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_PACKETISER|E_REG_BANK",
            "regdef": {
                "mnemonic": "pst_packetiser",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pst_packetiser.pst_packetiser_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_SYNC_BUFFER|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 172,
            "firmware_offset": 133120,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|E_PST_SYNC_BUFFER|E_REG_BANK",
            "regdef": {
                "mnemonic": "pst_sync_buffer",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pst_sync_buffer.pst_sync_buffer_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 262144,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131200,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 196608,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 229376,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_CSR": {
            "bridge_address": 2147483648,
            "firmware_depth": 16,
            "firmware_offset": 0,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_CSR",
            "regdef": {
                "mnemonic": "histogram_control",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_control_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_HIST_POLX|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 16384,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_HIST_POLX|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_HIST_POLY|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 32768,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL0|E_HIST_POLY|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_CSR": {
            "bridge_address": 2147483648,
            "firmware_depth": 16,
            "firmware_offset": 16,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_CSR",
            "regdef": {
                "mnemonic": "histogram_control",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_control_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_HIST_POLX|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 49152,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_HIST_POLX|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_HIST_POLY|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 65536,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_CH4K_HISTOGRAM_POL1|E_HIST_POLY|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_CSR": {
            "bridge_address": 2147483648,
            "firmware_depth": 16,
            "firmware_offset": 32,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_CSR",
            "regdef": {
                "mnemonic": "histogram_control",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_control_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 81920,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 98304,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_RDT_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_CSR": {
            "bridge_address": 2147483648,
            "firmware_depth": 16,
            "firmware_offset": 48,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_CSR",
            "regdef": {
                "mnemonic": "histogram_control",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_control_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 114688,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS": {
            "bridge_address": 2147483648,
            "firmware_depth": 16384,
            "firmware_offset": 131072,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_HISTOGRAMS|E_POST_VCC_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131232,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[0]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 524288,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131264,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 262144,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 294912,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131296,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[1]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 786432,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131328,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 327680,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 360448,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131360,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[2]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 1048576,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131392,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 393216,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 425984,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131424,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[3]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 1310720,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131456,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 458752,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 491520,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131488,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[4]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 1572864,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131520,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 524288,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 557056,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131552,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[5]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 1835008,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131584,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 589824,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 622592,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131616,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[6]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_4K_CHAN|E_AVMM_BRIDGE": {
            "bridge_address": 2147483648,
            "firmware_depth": 262144,
            "firmware_offset": 2097152,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_4K_CHAN|E_AVMM_BRIDGE",
            "regdef": {
                "mnemonic": "pstc_ch4k",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/pstc_ch4k.pstc_ch4k_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131648,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 655360,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|G_POL[0]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 688128,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|E_RDT|G_POL[1]|E_RDT|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 131680,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FSP|G_ANTENNA_PROCESSING[7]|G_TST_VECTOR_GEN|E_TST_VECTOR_GEN|E_REG_BANK",
            "regdef": {
                "mnemonic": "tst_vector_gen",
                "version": "1.0.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/tst_vector_gen.tst_vector_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|E_CIRCUIT_SWITCH|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 128,
            "firmware_offset": 132736,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|E_CIRCUIT_SWITCH|E_CSR",
            "regdef": {
                "mnemonic": "circuit_switch",
                "version": "2.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/circuit_switch.circuit_switch_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[0]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 131776,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[0]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[1]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 131840,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[1]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[2]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 131904,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[2]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[3]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 131968,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[3]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[4]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 132032,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[4]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[5]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 132096,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[5]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[6]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 132160,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[6]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[7]|E_STREAM_REPAIR|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 132224,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_FS_TRANSPORT|G_RX[7]|E_STREAM_REPAIR|E_REG_BANK",
            "regdef": {
                "mnemonic": "packet_stream_repair",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/packet_stream_repair.packet_stream_repair_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_LED_CTRL|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 4,
            "firmware_offset": 131072,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_LED_CTRL|E_CSR",
            "regdef": {
                "mnemonic": "led_ctrl",
                "version": "0.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/led_ctrl.led_ctrl_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_SYS_ID|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 131104,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_SYS_ID|E_CSR",
            "regdef": {
                "mnemonic": "sys_id",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/sys_id.sys_id_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_PKT_CAP|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 44,
            "firmware_offset": 132288,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_PKT_CAP|E_CSR",
            "regdef": {
                "mnemonic": "pkt_cap",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/dish_pkt_cap.pkt_cap_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 131120,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_CSR",
            "regdef": {
                "mnemonic": "histogram_control",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_control_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS": {
            "bridge_address": 4177526784,
            "firmware_depth": 16384,
            "firmware_offset": 147456,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_HIST_POLX|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS": {
            "bridge_address": 4177526784,
            "firmware_depth": 16384,
            "firmware_offset": 163840,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_PRE_VCC_HISTOGRAM|E_HIST_POLY|E_HISTOGRAM_RESULTS",
            "regdef": {
                "mnemonic": "histogram_results",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/histogram.histogram_results_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_VCC_CH20|E_AVMM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 128,
            "firmware_offset": 132864,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_VCC_CH20|E_AVMM_BRIDGE",
            "parameters": {
                "channels_out" : 10,
                "polarisations" : 2,
                "input_frame_size": 18
            },
            "regdef": {
                "mnemonic": "vcc_ch20",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/vcc_ch20.vcc_ch20_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VCC|E_WIB|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 72,
            "firmware_offset": 132480,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VCC|E_WIB|E_REG_BANK",
            "regdef": {
                "mnemonic": "wideband_input_buffer",
                "version": "1.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/wideband_input_buffer.wideband_input_buffer_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VIS_TO_ETHERNET|B_REGISTER|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 131136,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VIS_TO_ETHERNET|B_REGISTER|E_CSR",
            "regdef": {
                "mnemonic": "visibility_source_host_config",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/visibility_packetiser.visibility_source_host_config_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|E_VIS_TO_ETHERNET|E_MAC_IP_UDP_LOOKUP|E_PROG_REG": {
            "bridge_address": 4177526784,
            "firmware_depth": 20,
            "firmware_offset": 131168,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|E_VIS_TO_ETHERNET|E_MAC_IP_UDP_LOOKUP|E_PROG_REG",
            "regdef": {
                "mnemonic": "host_lut_s2",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/visibility_packetiser.host_lut_s2_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 80,
            "firmware_offset": 256,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_CSR",
            "regdef": {
                "mnemonic": "lstv_gen",
                "version": "2.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/lstv_gen.lstv_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_TONE_X|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 16,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_TONE_X|E_REG_BANK",
            "regdef": {
                "mnemonic": "bite_tone_gen",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/bite_tone_gen.bite_tone_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_TONE_Y|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 32,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|E_TONE_Y|E_REG_BANK",
            "regdef": {
                "mnemonic": "bite_tone_gen",
                "version": "1.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/bite_tone_gen.bite_tone_gen_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 28,
            "firmware_offset": 128,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_CSR",
            "regdef": {
                "mnemonic": "resampler_delay_tracker",
                "version": "1.3.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.resampler_delay_tracker_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_RDT_POL_X|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 32768,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_RDT_POL_X|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_RDT_POL_Y|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE": {
            "bridge_address": 4177526784,
            "firmware_depth": 32768,
            "firmware_offset": 65536,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|B_RESAMPLER_DELAY_TRACKER|E_RDT_POL_Y|E_CONTROL|E_DELAY_MODEL_RAM_BRIDGE",
            "regdef": {
                "mnemonic": "first_order_delay_models",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/resampler_delay_tracker.first_order_delay_models_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_POLARIZATION_COUPLER|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 12,
            "firmware_offset": 0,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_POLARIZATION_COUPLER|E_REG_BANK",
            "regdef": {
                "mnemonic": "polarization_coupler",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/polarization_coupler.polarization_coupler_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_X|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 20,
            "firmware_offset": 64,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_X|E_CSR",
            "regdef": {
                "mnemonic": "gaussian",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/gaussian_noise.gaussian_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_X|E_NOISE_SHAPING_FIR|E_FIR_COEFFS_FIFO": {
            "bridge_address": 4177526784,
            "firmware_depth": 4096,
            "firmware_offset": 4096,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_X|E_NOISE_SHAPING_FIR|E_FIR_COEFFS_FIFO",
            "regdef": {
                "mnemonic": "bite_fir_filter",
                "version": "2.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/bite_fir_filter.bite_fir_filter_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_Y|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 20,
            "firmware_offset": 96,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_Y|E_CSR",
            "regdef": {
                "mnemonic": "gaussian",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/gaussian_noise.gaussian_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_Y|E_NOISE_SHAPING_FIR|E_FIR_COEFFS_FIFO": {
            "bridge_address": 4177526784,
            "firmware_depth": 4096,
            "firmware_offset": 8192,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_LSTV|GEN_SOURCE[0]|E_SOURCE_NOISE_GEN_Y|E_NOISE_SHAPING_FIR|E_FIR_COEFFS_FIFO",
            "regdef": {
                "mnemonic": "bite_fir_filter",
                "version": "2.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/bite_fir_filter.bite_fir_filter_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_REPLAY|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 131712,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_REPLAY|E_CSR",
            "regdef": {
                "mnemonic": "lstv_replay",
                "version": "2.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/lstv_replay.lstv_replay_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_SPFRX_PACKETIZER|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 112,
            "firmware_offset": 132608,
            "fpga_hierarchy": "TOP|E_BASE|E_PERSONA|G_BITE|E_BITE|E_SPFRX_PACKETIZER|E_REG_BANK",
            "regdef": {
                "mnemonic": "spfrx_packetizer",
                "version": "0.1.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/spfrx_packetizer.spfrx_packetizer_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[0]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049152,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[0]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[0]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048640,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[0]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[1]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049216,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[1]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[1]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048704,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[1]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[2]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049280,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[2]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[2]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048768,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[2]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[3]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049344,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[3]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[3]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048832,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_1|G_CHANNEL[3]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[0]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049408,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[0]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[0]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048896,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[0]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[1]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049472,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[1]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[1]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1048960,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[1]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[2]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049536,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[2]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[2]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1049024,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[2]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[3]|G_ENABLED|E_SLIM_RX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 48,
            "firmware_offset": 1049600,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[3]|G_ENABLED|E_SLIM_RX|E_REGISTERS",
            "regdef": {
                "mnemonic": "rx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.rx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[3]|G_ENABLED|E_SLIM_TX|E_REGISTERS": {
            "bridge_address": 4177526784,
            "firmware_depth": 40,
            "firmware_offset": 1049088,
            "fpga_hierarchy": "TOP|E_BASE|E_SLIM_MBO|E_MBO_2|G_CHANNEL[3]|G_ENABLED|E_SLIM_TX|E_REGISTERS",
            "regdef": {
                "mnemonic": "tx_slim",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/slim.tx_slim_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_SYS_ID|E_CSR": {
            "bridge_address": 4177526784,
            "firmware_depth": 16,
            "firmware_offset": 1048592,
            "fpga_hierarchy": "TOP|E_BASE|E_SYS_ID|E_CSR",
            "regdef": {
                "mnemonic": "sys_id",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/sys_id.sys_id_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|E_TALON_ST|E_REG_BANK": {
            "bridge_address": 4177526784,
            "firmware_depth": 112,
            "firmware_offset": 1050240,
            "fpga_hierarchy": "TOP|E_BASE|E_TALON_ST|E_REG_BANK",
            "regdef": {
                "mnemonic": "talon_status",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/talon_status.talon_status_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_PHY": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1050624,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_PHY",
            "regdef": {
                "mnemonic": "Ethernet_100G_PHY",
                "version": "19.2.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_PHY_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_MAC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049664,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_MAC",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_MAC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_MAC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_RSFEC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049728,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_RSFEC",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_RSFEC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_RSFEC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_STAT": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1051136,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_RX_STAT",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_statistics",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_statistics_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_MAC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049792,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_MAC",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_MAC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_MAC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_RSFEC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049856,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_RSFEC",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_RSFEC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_RSFEC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_STAT": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1051648,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|B_REGISTERS|E_TX_STAT",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_statistics",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_statistics_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[0]|E_100GBE|G_QSFP_CTRL|E_QSFP": {
            "bridge_address": 4177526784,
            "firmware_depth": 8,
            "firmware_offset": 1048576,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[0]|E_100GBE|G_QSFP_CTRL|E_QSFP",
            "regdef": {
                "mnemonic": "qsfp_ctrl",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.qsfp_ctrl_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_PHY": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1052160,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_PHY",
            "regdef": {
                "mnemonic": "Ethernet_100G_PHY",
                "version": "19.2.1",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_PHY_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_MAC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049920,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_MAC",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_MAC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_MAC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_RSFEC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1049984,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_RSFEC",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_RSFEC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_RSFEC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_STAT": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1052672,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_RX_STAT",
            "regdef": {
                "mnemonic": "Ethernet_100G_rx_statistics",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_rx_statistics_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_MAC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1050048,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_MAC",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_MAC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_MAC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_RSFEC": {
            "bridge_address": 4177526784,
            "firmware_depth": 64,
            "firmware_offset": 1050112,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_RSFEC",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_RSFEC",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_RSFEC_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_STAT": {
            "bridge_address": 4177526784,
            "firmware_depth": 512,
            "firmware_offset": 1053184,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|B_REGISTERS|E_TX_STAT",
            "regdef": {
                "mnemonic": "Ethernet_100G_tx_statistics",
                "version": "19.2.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.Ethernet_100G_tx_statistics_reg_pkg"
                }
            }
        },
        "TOP|E_BASE|G_100GBE[1]|E_100GBE|G_QSFP_CTRL|E_QSFP": {
            "bridge_address": 4177526784,
            "firmware_depth": 8,
            "firmware_offset": 1048584,
            "fpga_hierarchy": "TOP|E_BASE|G_100GBE[1]|E_100GBE|G_QSFP_CTRL|E_QSFP",
            "regdef": {
                "mnemonic": "qsfp_ctrl",
                "version": "1.0.0",
                "regset": {
                    "$ref": "#/RegisterSetDefinitions/ethernet_100g.qsfp_ctrl_reg_pkg"
                }
            }
        }
    }
}